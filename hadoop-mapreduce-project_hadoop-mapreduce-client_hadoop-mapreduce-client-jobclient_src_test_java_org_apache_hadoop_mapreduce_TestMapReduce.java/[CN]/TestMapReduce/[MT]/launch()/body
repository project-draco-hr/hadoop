{
  Configuration conf=new Configuration();
  int countsToGo=counts;
  int dist[]=new int[range];
  for (int i=0; i < range; i++) {
    double avgInts=(1.0 * countsToGo) / (range - i);
    dist[i]=(int)Math.max(0,Math.round(avgInts + (Math.sqrt(avgInts) * r.nextGaussian())));
    countsToGo-=dist[i];
  }
  if (countsToGo > 0) {
    dist[dist.length - 1]+=countsToGo;
  }
  Path testdir=new Path(TEST_DIR.getAbsolutePath());
  if (!fs.mkdirs(testdir)) {
    throw new IOException("Mkdirs failed to create " + testdir.toString());
  }
  Path randomIns=new Path(testdir,"genins");
  if (!fs.mkdirs(randomIns)) {
    throw new IOException("Mkdirs failed to create " + randomIns.toString());
  }
  Path answerkey=new Path(randomIns,"answer.key");
  SequenceFile.Writer out=SequenceFile.createWriter(fs,conf,answerkey,IntWritable.class,IntWritable.class,SequenceFile.CompressionType.NONE);
  try {
    for (int i=0; i < range; i++) {
      out.append(new IntWritable(i),new IntWritable(dist[i]));
    }
  }
  finally {
    out.close();
  }
  printFiles(randomIns,conf);
  Path randomOuts=new Path(testdir,"genouts");
  fs.delete(randomOuts,true);
  Job genJob=Job.getInstance(conf);
  FileInputFormat.setInputPaths(genJob,randomIns);
  genJob.setInputFormatClass(SequenceFileInputFormat.class);
  genJob.setMapperClass(RandomGenMapper.class);
  FileOutputFormat.setOutputPath(genJob,randomOuts);
  genJob.setOutputKeyClass(IntWritable.class);
  genJob.setOutputValueClass(IntWritable.class);
  genJob.setReducerClass(RandomGenReducer.class);
  genJob.setNumReduceTasks(1);
  genJob.waitForCompletion(true);
  printFiles(randomOuts,conf);
  int intermediateReduces=10;
  Path intermediateOuts=new Path(testdir,"intermediateouts");
  fs.delete(intermediateOuts,true);
  Job checkJob=Job.getInstance(conf);
  FileInputFormat.setInputPaths(checkJob,randomOuts);
  checkJob.setMapperClass(RandomCheckMapper.class);
  FileOutputFormat.setOutputPath(checkJob,intermediateOuts);
  checkJob.setOutputKeyClass(IntWritable.class);
  checkJob.setOutputValueClass(IntWritable.class);
  checkJob.setOutputFormatClass(MapFileOutputFormat.class);
  checkJob.setReducerClass(RandomCheckReducer.class);
  checkJob.setNumReduceTasks(intermediateReduces);
  checkJob.waitForCompletion(true);
  printFiles(intermediateOuts,conf);
  Path finalOuts=new Path(testdir,"finalouts");
  fs.delete(finalOuts,true);
  Job mergeJob=Job.getInstance(conf);
  FileInputFormat.setInputPaths(mergeJob,intermediateOuts);
  mergeJob.setInputFormatClass(SequenceFileInputFormat.class);
  mergeJob.setMapperClass(MergeMapper.class);
  FileOutputFormat.setOutputPath(mergeJob,finalOuts);
  mergeJob.setOutputKeyClass(IntWritable.class);
  mergeJob.setOutputValueClass(IntWritable.class);
  mergeJob.setOutputFormatClass(SequenceFileOutputFormat.class);
  mergeJob.setReducerClass(MergeReducer.class);
  mergeJob.setNumReduceTasks(1);
  mergeJob.waitForCompletion(true);
  printFiles(finalOuts,conf);
  boolean success=true;
  Path recomputedkey=new Path(finalOuts,"part-r-00000");
  SequenceFile.Reader in=new SequenceFile.Reader(fs,recomputedkey,conf);
  int totalseen=0;
  try {
    IntWritable key=new IntWritable();
    IntWritable val=new IntWritable();
    for (int i=0; i < range; i++) {
      if (dist[i] == 0) {
        continue;
      }
      if (!in.next(key,val)) {
        System.err.println("Cannot read entry " + i);
        success=false;
        break;
      }
 else {
        if (!((key.get() == i) && (val.get() == dist[i]))) {
          System.err.println("Mismatch!  Pos=" + key.get() + ", i="+ i+ ", val="+ val.get()+ ", dist[i]="+ dist[i]);
          success=false;
        }
        totalseen+=val.get();
      }
    }
    if (success) {
      if (in.next(key,val)) {
        System.err.println("Unnecessary lines in recomputed key!");
        success=false;
      }
    }
  }
  finally {
    in.close();
  }
  int originalTotal=0;
  for (int i=0; i < dist.length; i++) {
    originalTotal+=dist[i];
  }
  System.out.println("Original sum: " + originalTotal);
  System.out.println("Recomputed sum: " + totalseen);
  Path resultFile=new Path(testdir,"results");
  BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(fs.create(resultFile)));
  try {
    bw.write("Success=" + success + "\n");
    System.out.println("Success=" + success);
  }
  finally {
    bw.close();
  }
  assertTrue("testMapRed failed",success);
  fs.delete(testdir,true);
}
