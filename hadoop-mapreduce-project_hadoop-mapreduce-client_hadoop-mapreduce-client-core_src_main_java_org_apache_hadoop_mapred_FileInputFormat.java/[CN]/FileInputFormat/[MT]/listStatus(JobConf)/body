{
  Path[] dirs=getInputPaths(job);
  if (dirs.length == 0) {
    throw new IOException("No input paths specified in job");
  }
  TokenCache.obtainTokensForNamenodes(job.getCredentials(),dirs,job);
  boolean recursive=job.getBoolean(INPUT_DIR_RECURSIVE,false);
  List<FileStatus> result=new ArrayList<FileStatus>();
  List<IOException> errors=new ArrayList<IOException>();
  List<PathFilter> filters=new ArrayList<PathFilter>();
  filters.add(hiddenFileFilter);
  PathFilter jobFilter=getInputPathFilter(job);
  if (jobFilter != null) {
    filters.add(jobFilter);
  }
  PathFilter inputFilter=new MultiPathFilter(filters);
  for (  Path p : dirs) {
    FileSystem fs=p.getFileSystem(job);
    FileStatus[] matches=fs.globStatus(p,inputFilter);
    if (matches == null) {
      errors.add(new IOException("Input path does not exist: " + p));
    }
 else     if (matches.length == 0) {
      errors.add(new IOException("Input Pattern " + p + " matches 0 files"));
    }
 else {
      for (      FileStatus globStat : matches) {
        if (globStat.isDirectory()) {
          for (          FileStatus stat : fs.listStatus(globStat.getPath(),inputFilter)) {
            if (recursive && stat.isDirectory()) {
              addInputPathRecursively(result,fs,stat.getPath(),inputFilter);
            }
 else {
              result.add(stat);
            }
          }
        }
 else {
          result.add(globStat);
        }
      }
    }
  }
  if (!errors.isEmpty()) {
    throw new InvalidInputException(errors);
  }
  LOG.info("Total input paths to process : " + result.size());
  return result.toArray(new FileStatus[result.size()]);
}
