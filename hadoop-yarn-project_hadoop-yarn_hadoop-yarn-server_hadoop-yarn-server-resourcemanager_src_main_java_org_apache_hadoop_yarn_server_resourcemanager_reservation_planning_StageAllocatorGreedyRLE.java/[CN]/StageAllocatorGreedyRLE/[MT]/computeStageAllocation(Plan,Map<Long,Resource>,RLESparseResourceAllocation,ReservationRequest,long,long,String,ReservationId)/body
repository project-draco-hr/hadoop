{
  if (stageEarliestStart + rr.getDuration() > stageDeadline) {
    return null;
  }
  Map<ReservationInterval,Resource> allocationRequests=new HashMap<ReservationInterval,Resource>();
  Resource totalCapacity=plan.getTotalCapacity();
  Resource sizeOfGang=Resources.multiply(rr.getCapability(),rr.getConcurrency());
  long dur=rr.getDuration();
  long step=plan.getStep();
  if (dur % step != 0) {
    dur+=(step - (dur % step));
  }
  int gangsToPlace=rr.getNumContainers() / rr.getConcurrency();
  RLESparseResourceAllocation netRLERes=plan.getAvailableResourceOverTime(user,oldId,stageEarliestStart,stageDeadline);
  netRLERes=RLESparseResourceAllocation.merge(plan.getResourceCalculator(),totalCapacity,netRLERes,planModifications,RLEOperator.subtract,stageEarliestStart,stageDeadline);
  while (gangsToPlace > 0 && stageEarliestStart + dur <= stageDeadline) {
    int maxGang=gangsToPlace;
    long minPoint=-1;
    NavigableMap<Long,Resource> partialMap=netRLERes.getRangeOverlapping(stageEarliestStart,stageDeadline).getCumulative();
    if (!allocateLeft) {
      partialMap=partialMap.descendingMap();
    }
    Iterator<Entry<Long,Resource>> netIt=partialMap.entrySet().iterator();
    long oldT=stageDeadline;
    while (maxGang > 0 && netIt.hasNext()) {
      long t;
      Resource curAvailRes;
      Entry<Long,Resource> e=netIt.next();
      if (allocateLeft) {
        t=Math.max(e.getKey(),stageEarliestStart);
        curAvailRes=e.getValue();
      }
 else {
        t=oldT;
        oldT=e.getKey();
        curAvailRes=partialMap.higherEntry(t).getValue();
      }
      if (curAvailRes == null) {
        continue;
      }
      if (exitCondition(t,stageEarliestStart,stageDeadline,dur)) {
        break;
      }
      int curMaxGang=(int)Math.floor(Resources.divide(plan.getResourceCalculator(),totalCapacity,curAvailRes,sizeOfGang));
      curMaxGang=Math.min(gangsToPlace,curMaxGang);
      if (curMaxGang <= maxGang) {
        maxGang=curMaxGang;
        minPoint=t;
      }
    }
    gangsToPlace=trackProgress(planModifications,rr,stageEarliestStart,stageDeadline,allocationRequests,dur,gangsToPlace,maxGang);
    if (allocateLeft) {
      stageEarliestStart=Math.min(partialMap.higherKey(minPoint),stageEarliestStart + dur);
    }
 else {
      stageDeadline=Math.max(partialMap.higherKey(minPoint),stageDeadline - dur);
    }
  }
  if (gangsToPlace == 0) {
    return allocationRequests;
  }
 else {
    for (    Map.Entry<ReservationInterval,Resource> tempAllocation : allocationRequests.entrySet()) {
      planModifications.removeInterval(tempAllocation.getKey(),tempAllocation.getValue());
    }
    return null;
  }
}
