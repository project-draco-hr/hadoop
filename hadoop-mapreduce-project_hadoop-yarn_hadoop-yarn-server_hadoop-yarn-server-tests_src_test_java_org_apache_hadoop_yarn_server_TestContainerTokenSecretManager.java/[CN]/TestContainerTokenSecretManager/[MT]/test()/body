{
  final ApplicationId appID=recordFactory.newRecordInstance(ApplicationId.class);
  appID.setClusterTimestamp(1234);
  appID.setId(5);
  final Configuration conf=new Configuration();
  conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION,"kerberos");
  conf.setLong(YarnConfiguration.RM_AM_EXPIRY_INTERVAL_MS,100000L);
  UserGroupInformation.setConfiguration(conf);
  yarnCluster=new MiniYARNCluster(TestContainerTokenSecretManager.class.getName());
  yarnCluster.init(conf);
  yarnCluster.start();
  ResourceManager resourceManager=yarnCluster.getResourceManager();
  final YarnRPC yarnRPC=YarnRPC.create(conf);
  ApplicationSubmissionContext appSubmissionContext=recordFactory.newRecordInstance(ApplicationSubmissionContext.class);
  appSubmissionContext.setApplicationId(appID);
  ContainerLaunchContext amContainer=recordFactory.newRecordInstance(ContainerLaunchContext.class);
  amContainer.setResource(Resources.createResource(1024));
  amContainer.setCommands(Arrays.asList("sleep","100"));
  appSubmissionContext.setUser("testUser");
  File file=new File(localDir.getAbsolutePath(),"testFile");
  FileWriter tmpFile=new FileWriter(file);
  tmpFile.write("testing");
  tmpFile.close();
  URL testFileURL=ConverterUtils.getYarnUrlFromPath(FileContext.getFileContext().makeQualified(new Path(localDir.getAbsolutePath(),"testFile")));
  LocalResource rsrc=recordFactory.newRecordInstance(LocalResource.class);
  rsrc.setResource(testFileURL);
  rsrc.setSize(file.length());
  rsrc.setTimestamp(file.lastModified());
  rsrc.setType(LocalResourceType.FILE);
  rsrc.setVisibility(LocalResourceVisibility.PRIVATE);
  amContainer.setLocalResources(Collections.singletonMap("testFile",rsrc));
  SubmitApplicationRequest submitRequest=recordFactory.newRecordInstance(SubmitApplicationRequest.class);
  submitRequest.setApplicationSubmissionContext(appSubmissionContext);
  appSubmissionContext.setAMContainerSpec(amContainer);
  resourceManager.getClientRMService().submitApplication(submitRequest);
  int waitCounter=0;
  RMApp app=resourceManager.getRMContext().getRMApps().get(appID);
  RMAppAttempt appAttempt=app == null ? null : app.getCurrentAppAttempt();
  RMAppAttemptState state=appAttempt == null ? null : appAttempt.getAppAttemptState();
  while ((app == null || appAttempt == null || state == null || !state.equals(RMAppAttemptState.LAUNCHED)) && waitCounter++ != 20) {
    LOG.info("Waiting for applicationAttempt to be created.. ");
    Thread.sleep(1000);
    app=resourceManager.getRMContext().getRMApps().get(appID);
    appAttempt=app == null ? null : app.getCurrentAppAttempt();
    state=appAttempt == null ? null : appAttempt.getAppAttemptState();
  }
  Assert.assertNotNull(app);
  Assert.assertNotNull(appAttempt);
  Assert.assertNotNull(state);
  Assert.assertEquals(RMAppAttemptState.LAUNCHED,state);
  UserGroupInformation currentUser=UserGroupInformation.getCurrentUser();
  String schedulerAddressString=conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);
  final InetSocketAddress schedulerAddr=NetUtils.createSocketAddr(schedulerAddressString);
  ApplicationTokenIdentifier appTokenIdentifier=new ApplicationTokenIdentifier(appID);
  ApplicationTokenSecretManager appTokenSecretManager=new ApplicationTokenSecretManager();
  appTokenSecretManager.setMasterKey(ApplicationTokenSecretManager.createSecretKey("Dummy".getBytes()));
  Token<ApplicationTokenIdentifier> appToken=new Token<ApplicationTokenIdentifier>(appTokenIdentifier,appTokenSecretManager);
  appToken.setService(new Text(schedulerAddressString));
  currentUser.addToken(appToken);
  conf.setClass(YarnConfiguration.YARN_SECURITY_INFO,SchedulerSecurityInfo.class,SecurityInfo.class);
  AMRMProtocol scheduler=currentUser.doAs(new PrivilegedAction<AMRMProtocol>(){
    @Override public AMRMProtocol run(){
      return (AMRMProtocol)yarnRPC.getProxy(AMRMProtocol.class,schedulerAddr,conf);
    }
  }
);
  RegisterApplicationMasterRequest request=recordFactory.newRecordInstance(RegisterApplicationMasterRequest.class);
  request.setApplicationAttemptId(resourceManager.getRMContext().getRMApps().get(appID).getCurrentAppAttempt().getAppAttemptId());
  scheduler.registerApplicationMaster(request);
  List<ResourceRequest> ask=new ArrayList<ResourceRequest>();
  ResourceRequest rr=recordFactory.newRecordInstance(ResourceRequest.class);
  rr.setCapability(recordFactory.newRecordInstance(Resource.class));
  rr.getCapability().setMemory(1024);
  rr.setHostName("*");
  rr.setNumContainers(1);
  rr.setPriority(recordFactory.newRecordInstance(Priority.class));
  rr.getPriority().setPriority(0);
  ask.add(rr);
  ArrayList<ContainerId> release=new ArrayList<ContainerId>();
  AllocateRequest allocateRequest=BuilderUtils.newAllocateRequest(appAttempt.getAppAttemptId(),0,0F,ask,release);
  List<Container> allocatedContainers=scheduler.allocate(allocateRequest).getAMResponse().getAllocatedContainers();
  waitCounter=0;
  while ((allocatedContainers == null || allocatedContainers.size() == 0) && waitCounter++ != 20) {
    LOG.info("Waiting for container to be allocated..");
    Thread.sleep(1000);
    allocateRequest.setResponseId(allocateRequest.getResponseId() + 1);
    allocatedContainers=scheduler.allocate(allocateRequest).getAMResponse().getAllocatedContainers();
  }
  Assert.assertNotNull("Container is not allocted!",allocatedContainers);
  Assert.assertEquals("Didn't get one container!",1,allocatedContainers.size());
  final Container allocatedContainer=allocatedContainers.get(0);
  ContainerToken containerToken=allocatedContainer.getContainerToken();
  Token<ContainerTokenIdentifier> token=new Token<ContainerTokenIdentifier>(containerToken.getIdentifier().array(),containerToken.getPassword().array(),new Text(containerToken.getKind()),new Text(containerToken.getService()));
  currentUser.addToken(token);
  conf.setClass(YarnConfiguration.YARN_SECURITY_INFO,ContainerManagerSecurityInfo.class,SecurityInfo.class);
  currentUser.doAs(new PrivilegedAction<Void>(){
    @Override public Void run(){
      ContainerManager client=(ContainerManager)yarnRPC.getProxy(ContainerManager.class,NetUtils.createSocketAddr(allocatedContainer.getNodeId().toString()),conf);
      try {
        LOG.info("Going to make a getContainerStatus() legal request");
        GetContainerStatusRequest request=recordFactory.newRecordInstance(GetContainerStatusRequest.class);
        ContainerId containerID=recordFactory.newRecordInstance(ContainerId.class);
        ApplicationAttemptId appAttemptId=recordFactory.newRecordInstance(ApplicationAttemptId.class);
        appAttemptId.setApplicationId(appID);
        appAttemptId.setAttemptId(1);
        appAttemptId.setApplicationId(appID);
        containerID.setApplicationAttemptId(appAttemptId);
        containerID.setId(1);
        request.setContainerId(containerID);
        client.getContainerStatus(request);
      }
 catch (      YarnRemoteException e) {
        LOG.info("Error",e);
      }
catch (      AvroRuntimeException e) {
        LOG.info("Got the expected exception");
      }
      return null;
    }
  }
);
  UserGroupInformation maliceUser=UserGroupInformation.createRemoteUser(currentUser.getShortUserName());
  byte[] identifierBytes=containerToken.getIdentifier().array();
  DataInputBuffer di=new DataInputBuffer();
  di.reset(identifierBytes,identifierBytes.length);
  ContainerTokenIdentifier dummyIdentifier=new ContainerTokenIdentifier();
  dummyIdentifier.readFields(di);
  Resource modifiedResource=recordFactory.newRecordInstance(Resource.class);
  modifiedResource.setMemory(2048);
  ContainerTokenIdentifier modifiedIdentifier=new ContainerTokenIdentifier(dummyIdentifier.getContainerID(),dummyIdentifier.getNmHostName(),modifiedResource);
  Token<ContainerTokenIdentifier> modifiedToken=new Token<ContainerTokenIdentifier>(modifiedIdentifier.getBytes(),containerToken.getPassword().array(),new Text(containerToken.getKind()),new Text(containerToken.getService()));
  maliceUser.addToken(modifiedToken);
  maliceUser.doAs(new PrivilegedAction<Void>(){
    @Override public Void run(){
      ContainerManager client=(ContainerManager)yarnRPC.getProxy(ContainerManager.class,NetUtils.createSocketAddr(allocatedContainer.getNodeId().toString()),conf);
      ContainerId containerID;
      LOG.info("Going to contact NM:  ilLegal request");
      GetContainerStatusRequest request=recordFactory.newRecordInstance(GetContainerStatusRequest.class);
      containerID=recordFactory.newRecordInstance(ContainerId.class);
      ApplicationAttemptId appAttemptId=recordFactory.newRecordInstance(ApplicationAttemptId.class);
      appAttemptId.setApplicationId(appID);
      appAttemptId.setAttemptId(1);
      appAttemptId.setApplicationId(appID);
      containerID.setApplicationAttemptId(appAttemptId);
      containerID.setId(1);
      request.setContainerId(containerID);
      try {
        client.getContainerStatus(request);
        fail("Connection initiation with illegally modified " + "tokens is expected to fail.");
      }
 catch (      YarnRemoteException e) {
        LOG.error("Got exception",e);
        fail("Cannot get a YARN remote exception as " + "it will indicate RPC success");
      }
catch (      Exception e) {
        Assert.assertEquals(java.lang.reflect.UndeclaredThrowableException.class.getCanonicalName(),e.getClass().getCanonicalName());
        Assert.assertEquals("DIGEST-MD5: digest response format violation. Mismatched response.",e.getCause().getCause().getMessage());
      }
      return null;
    }
  }
);
}
