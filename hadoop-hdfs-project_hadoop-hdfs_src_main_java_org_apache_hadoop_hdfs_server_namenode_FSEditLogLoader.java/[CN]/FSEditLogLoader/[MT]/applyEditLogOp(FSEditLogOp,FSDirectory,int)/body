{
switch (op.opCode) {
case OP_ADD:
{
      AddCloseOp addCloseOp=(AddCloseOp)op;
      if (FSNamesystem.LOG.isDebugEnabled()) {
        FSNamesystem.LOG.debug(op.opCode + ": " + addCloseOp.path+ " numblocks : "+ addCloseOp.blocks.length+ " clientHolder "+ addCloseOp.clientName+ " clientMachine "+ addCloseOp.clientMachine);
      }
      INodeFile oldFile=getINodeFile(fsDir,addCloseOp.path);
      INodeFile newFile=oldFile;
      if (oldFile == null) {
        final short replication=fsNamesys.getBlockManager().adjustReplication(addCloseOp.replication);
        PermissionStatus permissions=fsNamesys.getUpgradePermission();
        if (addCloseOp.permissions != null) {
          permissions=addCloseOp.permissions;
        }
        long blockSize=addCloseOp.blockSize;
        if (-8 <= logVersion && blockSize == 0) {
          if (addCloseOp.blocks.length > 1) {
            blockSize=addCloseOp.blocks[0].getNumBytes();
          }
 else {
            long first=((addCloseOp.blocks.length == 1) ? addCloseOp.blocks[0].getNumBytes() : 0);
            blockSize=Math.max(fsNamesys.getDefaultBlockSize(),first);
          }
        }
        newFile=(INodeFile)fsDir.unprotectedAddFile(addCloseOp.path,permissions,replication,addCloseOp.mtime,addCloseOp.atime,blockSize,true,addCloseOp.clientName,addCloseOp.clientMachine);
        fsNamesys.leaseManager.addLease(addCloseOp.clientName,addCloseOp.path);
      }
 else {
        if (!oldFile.isUnderConstruction()) {
          if (FSNamesystem.LOG.isDebugEnabled()) {
            FSNamesystem.LOG.debug("Reopening an already-closed file " + "for append");
          }
          fsNamesys.prepareFileForWrite(addCloseOp.path,oldFile,addCloseOp.clientName,addCloseOp.clientMachine,null,false);
          newFile=getINodeFile(fsDir,addCloseOp.path);
        }
      }
      updateBlocks(fsDir,addCloseOp,newFile);
      break;
    }
case OP_CLOSE:
{
    AddCloseOp addCloseOp=(AddCloseOp)op;
    if (FSNamesystem.LOG.isDebugEnabled()) {
      FSNamesystem.LOG.debug(op.opCode + ": " + addCloseOp.path+ " numblocks : "+ addCloseOp.blocks.length+ " clientHolder "+ addCloseOp.clientName+ " clientMachine "+ addCloseOp.clientMachine);
    }
    INodeFile oldFile=getINodeFile(fsDir,addCloseOp.path);
    if (oldFile == null) {
      throw new IOException("Operation trying to close non-existent file " + addCloseOp.path);
    }
    updateBlocks(fsDir,addCloseOp,oldFile);
    INodeFileUnderConstruction ucFile=(INodeFileUnderConstruction)oldFile;
    fsNamesys.leaseManager.removeLeaseWithPrefixPath(addCloseOp.path);
    INodeFile newFile=ucFile.convertToInodeFile();
    fsDir.replaceNode(addCloseOp.path,ucFile,newFile);
    break;
  }
case OP_SET_REPLICATION:
{
  SetReplicationOp setReplicationOp=(SetReplicationOp)op;
  short replication=fsNamesys.getBlockManager().adjustReplication(setReplicationOp.replication);
  fsDir.unprotectedSetReplication(setReplicationOp.path,replication,null);
  break;
}
case OP_CONCAT_DELETE:
{
ConcatDeleteOp concatDeleteOp=(ConcatDeleteOp)op;
fsDir.unprotectedConcat(concatDeleteOp.trg,concatDeleteOp.srcs,concatDeleteOp.timestamp);
break;
}
case OP_RENAME_OLD:
{
RenameOldOp renameOp=(RenameOldOp)op;
HdfsFileStatus dinfo=fsDir.getFileInfo(renameOp.dst,false);
fsDir.unprotectedRenameTo(renameOp.src,renameOp.dst,renameOp.timestamp);
fsNamesys.unprotectedChangeLease(renameOp.src,renameOp.dst,dinfo);
break;
}
case OP_DELETE:
{
DeleteOp deleteOp=(DeleteOp)op;
fsDir.unprotectedDelete(deleteOp.path,deleteOp.timestamp);
break;
}
case OP_MKDIR:
{
MkdirOp mkdirOp=(MkdirOp)op;
PermissionStatus permissions=fsNamesys.getUpgradePermission();
if (mkdirOp.permissions != null) {
permissions=mkdirOp.permissions;
}
fsDir.unprotectedMkdir(mkdirOp.path,permissions,mkdirOp.timestamp);
break;
}
case OP_SET_GENSTAMP:
{
SetGenstampOp setGenstampOp=(SetGenstampOp)op;
fsNamesys.setGenerationStamp(setGenstampOp.genStamp);
break;
}
case OP_SET_PERMISSIONS:
{
SetPermissionsOp setPermissionsOp=(SetPermissionsOp)op;
fsDir.unprotectedSetPermission(setPermissionsOp.src,setPermissionsOp.permissions);
break;
}
case OP_SET_OWNER:
{
SetOwnerOp setOwnerOp=(SetOwnerOp)op;
fsDir.unprotectedSetOwner(setOwnerOp.src,setOwnerOp.username,setOwnerOp.groupname);
break;
}
case OP_SET_NS_QUOTA:
{
SetNSQuotaOp setNSQuotaOp=(SetNSQuotaOp)op;
fsDir.unprotectedSetQuota(setNSQuotaOp.src,setNSQuotaOp.nsQuota,HdfsConstants.QUOTA_DONT_SET);
break;
}
case OP_CLEAR_NS_QUOTA:
{
ClearNSQuotaOp clearNSQuotaOp=(ClearNSQuotaOp)op;
fsDir.unprotectedSetQuota(clearNSQuotaOp.src,HdfsConstants.QUOTA_RESET,HdfsConstants.QUOTA_DONT_SET);
break;
}
case OP_SET_QUOTA:
SetQuotaOp setQuotaOp=(SetQuotaOp)op;
fsDir.unprotectedSetQuota(setQuotaOp.src,setQuotaOp.nsQuota,setQuotaOp.dsQuota);
break;
case OP_TIMES:
{
TimesOp timesOp=(TimesOp)op;
fsDir.unprotectedSetTimes(timesOp.path,timesOp.mtime,timesOp.atime,true);
break;
}
case OP_SYMLINK:
{
SymlinkOp symlinkOp=(SymlinkOp)op;
fsDir.unprotectedSymlink(symlinkOp.path,symlinkOp.value,symlinkOp.mtime,symlinkOp.atime,symlinkOp.permissionStatus);
break;
}
case OP_RENAME:
{
RenameOp renameOp=(RenameOp)op;
HdfsFileStatus dinfo=fsDir.getFileInfo(renameOp.dst,false);
fsDir.unprotectedRenameTo(renameOp.src,renameOp.dst,renameOp.timestamp,renameOp.options);
fsNamesys.unprotectedChangeLease(renameOp.src,renameOp.dst,dinfo);
break;
}
case OP_GET_DELEGATION_TOKEN:
{
GetDelegationTokenOp getDelegationTokenOp=(GetDelegationTokenOp)op;
fsNamesys.getDelegationTokenSecretManager().addPersistedDelegationToken(getDelegationTokenOp.token,getDelegationTokenOp.expiryTime);
break;
}
case OP_RENEW_DELEGATION_TOKEN:
{
RenewDelegationTokenOp renewDelegationTokenOp=(RenewDelegationTokenOp)op;
fsNamesys.getDelegationTokenSecretManager().updatePersistedTokenRenewal(renewDelegationTokenOp.token,renewDelegationTokenOp.expiryTime);
break;
}
case OP_CANCEL_DELEGATION_TOKEN:
{
CancelDelegationTokenOp cancelDelegationTokenOp=(CancelDelegationTokenOp)op;
fsNamesys.getDelegationTokenSecretManager().updatePersistedTokenCancellation(cancelDelegationTokenOp.token);
break;
}
case OP_UPDATE_MASTER_KEY:
{
UpdateMasterKeyOp updateMasterKeyOp=(UpdateMasterKeyOp)op;
fsNamesys.getDelegationTokenSecretManager().updatePersistedMasterKey(updateMasterKeyOp.key);
break;
}
case OP_REASSIGN_LEASE:
{
ReassignLeaseOp reassignLeaseOp=(ReassignLeaseOp)op;
Lease lease=fsNamesys.leaseManager.getLease(reassignLeaseOp.leaseHolder);
INodeFileUnderConstruction pendingFile=(INodeFileUnderConstruction)fsDir.getFileINode(reassignLeaseOp.path);
fsNamesys.reassignLeaseInternal(lease,reassignLeaseOp.path,reassignLeaseOp.newHolder,pendingFile);
break;
}
case OP_START_LOG_SEGMENT:
case OP_END_LOG_SEGMENT:
{
break;
}
case OP_DATANODE_ADD:
case OP_DATANODE_REMOVE:
break;
default :
throw new IOException("Invalid operation read " + op.opCode);
}
}
