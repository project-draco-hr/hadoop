{
  BlockInfo[] oldBlocks=file.getBlocks();
  Block[] newBlocks=op.getBlocks();
  String path=op.getPath();
  boolean isGenStampUpdate=oldBlocks.length == newBlocks.length;
  for (int i=0; i < oldBlocks.length && i < newBlocks.length; i++) {
    BlockInfo oldBlock=oldBlocks[i];
    Block newBlock=newBlocks[i];
    boolean isLastBlock=i == newBlocks.length - 1;
    if (oldBlock.getBlockId() != newBlock.getBlockId() || (oldBlock.getGenerationStamp() != newBlock.getGenerationStamp() && !(isGenStampUpdate && isLastBlock))) {
      throw new IOException("Mismatched block IDs or generation stamps, " + "attempting to replace block " + oldBlock + " with "+ newBlock+ " as block # "+ i+ "/"+ newBlocks.length+ " of "+ path);
    }
    oldBlock.setNumBytes(newBlock.getNumBytes());
    boolean changeMade=oldBlock.getGenerationStamp() != newBlock.getGenerationStamp();
    oldBlock.setGenerationStamp(newBlock.getGenerationStamp());
    if (!oldBlock.isComplete() && (!isLastBlock || op.shouldCompleteLastBlock())) {
      changeMade=true;
      fsNamesys.getBlockManager().forceCompleteBlock(oldBlock);
    }
    if (changeMade) {
      fsNamesys.getBlockManager().processQueuedMessagesForBlock(newBlock);
    }
  }
  if (newBlocks.length < oldBlocks.length) {
    if (!file.isUnderConstruction()) {
      throw new IOException("Trying to remove a block from file " + path + " which is not under construction.");
    }
    if (newBlocks.length != oldBlocks.length - 1) {
      throw new IOException("Trying to remove more than one block from file " + path);
    }
    Block oldBlock=oldBlocks[oldBlocks.length - 1];
    boolean removed=FSDirWriteFileOp.unprotectedRemoveBlock(fsDir,path,iip,file,oldBlock);
    if (!removed && !(op instanceof UpdateBlocksOp)) {
      throw new IOException("Trying to delete non-existant block " + oldBlock);
    }
  }
 else   if (newBlocks.length > oldBlocks.length) {
    final boolean isStriped=ecZone != null;
    for (int i=oldBlocks.length; i < newBlocks.length; i++) {
      Block newBlock=newBlocks[i];
      final BlockInfo newBI;
      if (!op.shouldCompleteLastBlock()) {
        if (isStriped) {
          newBI=new BlockInfoStriped(newBlock,ecZone.getErasureCodingPolicy());
        }
 else {
          newBI=new BlockInfoContiguous(newBlock,file.getPreferredBlockReplication());
        }
        newBI.convertToBlockUnderConstruction(BlockUCState.UNDER_CONSTRUCTION,null);
      }
 else {
        if (isStriped) {
          newBI=new BlockInfoStriped(newBlock,ErasureCodingPolicyManager.getSystemDefaultPolicy());
        }
 else {
          newBI=new BlockInfoContiguous(newBlock,file.getFileReplication());
        }
      }
      fsNamesys.getBlockManager().addBlockCollectionWithCheck(newBI,file);
      file.addBlock(newBI);
      fsNamesys.getBlockManager().processQueuedMessagesForBlock(newBlock);
    }
  }
}
