{
  boolean patternHasGlob=false;
  List<FileStatus> matches=new ArrayList<FileStatus>();
  int level=0;
  String baseDir=Path.CUR_DIR;
  if (pathPattern.isAbsolute()) {
    level=1;
    baseDir=Path.SEPARATOR;
  }
  String[] components=null;
  GlobFilter[] filters=null;
  String filename=pathPattern.toUri().getPath();
  if (!filename.isEmpty() && !Path.SEPARATOR.equals(filename)) {
    components=filename.split(Path.SEPARATOR);
    filters=new GlobFilter[components.length];
    for (int i=level; i < components.length; i++) {
      filters[i]=new GlobFilter(components[i]);
      patternHasGlob|=filters[i].hasPattern();
    }
    if (!patternHasGlob) {
      baseDir=unquotePathComponent(filename);
      components=null;
    }
  }
  try {
    matches.add(getFileStatus(new Path(baseDir)));
  }
 catch (  FileNotFoundException e) {
    return patternHasGlob ? matches : null;
  }
  if (components != null) {
    for (int i=level; (i < components.length) && !matches.isEmpty(); i++) {
      List<FileStatus> children=new ArrayList<FileStatus>();
      for (      FileStatus match : matches) {
        if (!match.isDirectory()) {
          continue;
        }
        try {
          if (filters[i].hasPattern()) {
            FileStatus[] statuses=listStatus(match.getPath(),filters[i]);
            children.addAll(Arrays.asList(statuses));
          }
 else {
            String component=unquotePathComponent(components[i]);
            Path child=new Path(match.getPath(),component);
            children.add(getFileStatus(child));
          }
        }
 catch (        FileNotFoundException e) {
        }
      }
      matches=children;
    }
  }
  if (!matches.isEmpty()) {
    Iterator<FileStatus> iter=matches.iterator();
    while (iter.hasNext()) {
      if (!filter.accept(iter.next().getPath())) {
        iter.remove();
      }
    }
  }
  if (matches.isEmpty()) {
    return patternHasGlob ? matches : null;
  }
  Collections.sort(matches);
  return matches;
}
