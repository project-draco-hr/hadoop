{
  if (numOfReplicas == 0 || clusterMap.getNumOfLeaves() == 0) {
    return writer;
  }
  final int numOfResults=results.size();
  final int totalReplicasExpected=numOfReplicas + numOfResults;
  if ((writer == null || !(writer instanceof DatanodeDescriptor)) && !newBlock) {
    writer=results.get(0).getDatanodeDescriptor();
  }
  final Set<Node> oldExcludedNodes=new HashSet<Node>(excludedNodes);
  final List<StorageType> requiredStorageTypes=storagePolicy.chooseStorageTypes((short)totalReplicasExpected,DatanodeStorageInfo.toStorageTypes(results),unavailableStorages,newBlock);
  final EnumMap<StorageType,Integer> storageTypes=getRequiredStorageTypes(requiredStorageTypes);
  try {
    if ((numOfReplicas=requiredStorageTypes.size()) == 0) {
      throw new NotEnoughReplicasException("All required storage types are unavailable: " + " unavailableStorages=" + unavailableStorages + ", storagePolicy="+ storagePolicy);
    }
    if (numOfResults == 0) {
      writer=chooseLocalStorage(writer,excludedNodes,blocksize,maxNodesPerRack,results,avoidStaleNodes,storageTypes,true).getDatanodeDescriptor();
      if (--numOfReplicas == 0) {
        return writer;
      }
    }
    final DatanodeDescriptor dn0=results.get(0).getDatanodeDescriptor();
    if (numOfResults <= 1) {
      chooseRemoteRack(1,dn0,excludedNodes,blocksize,maxNodesPerRack,results,avoidStaleNodes,storageTypes);
      if (--numOfReplicas == 0) {
        return writer;
      }
    }
    if (numOfResults <= 2) {
      final DatanodeDescriptor dn1=results.get(1).getDatanodeDescriptor();
      if (clusterMap.isOnSameRack(dn0,dn1)) {
        chooseRemoteRack(1,dn0,excludedNodes,blocksize,maxNodesPerRack,results,avoidStaleNodes,storageTypes);
      }
 else       if (newBlock) {
        chooseLocalRack(dn1,excludedNodes,blocksize,maxNodesPerRack,results,avoidStaleNodes,storageTypes);
      }
 else {
        chooseLocalRack(writer,excludedNodes,blocksize,maxNodesPerRack,results,avoidStaleNodes,storageTypes);
      }
      if (--numOfReplicas == 0) {
        return writer;
      }
    }
    chooseRandom(numOfReplicas,NodeBase.ROOT,excludedNodes,blocksize,maxNodesPerRack,results,avoidStaleNodes,storageTypes);
  }
 catch (  NotEnoughReplicasException e) {
    final String message="Failed to place enough replicas, still in need of " + (totalReplicasExpected - results.size()) + " to reach "+ totalReplicasExpected+ ".";
    if (LOG.isTraceEnabled()) {
      LOG.trace(message,e);
    }
 else {
      LOG.warn(message + " " + e.getMessage());
    }
    if (avoidStaleNodes) {
      for (      DatanodeStorageInfo resultStorage : results) {
        addToExcludedNodes(resultStorage.getDatanodeDescriptor(),oldExcludedNodes);
      }
      numOfReplicas=totalReplicasExpected - results.size();
      return chooseTarget(numOfReplicas,writer,oldExcludedNodes,blocksize,maxNodesPerRack,results,false,storagePolicy,unavailableStorages,newBlock);
    }
    boolean retry=false;
    for (    StorageType type : storageTypes.keySet()) {
      if (!unavailableStorages.contains(type)) {
        unavailableStorages.add(type);
        retry=true;
      }
    }
    if (retry) {
      for (      DatanodeStorageInfo resultStorage : results) {
        addToExcludedNodes(resultStorage.getDatanodeDescriptor(),oldExcludedNodes);
      }
      numOfReplicas=totalReplicasExpected - results.size();
      return chooseTarget(numOfReplicas,writer,oldExcludedNodes,blocksize,maxNodesPerRack,results,false,storagePolicy,unavailableStorages,newBlock);
    }
  }
  return writer;
}
