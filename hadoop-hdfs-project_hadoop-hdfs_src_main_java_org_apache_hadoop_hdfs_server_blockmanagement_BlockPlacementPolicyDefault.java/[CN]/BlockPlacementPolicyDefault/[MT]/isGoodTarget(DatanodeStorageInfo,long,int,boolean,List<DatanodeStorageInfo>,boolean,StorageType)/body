{
  if (storage.getStorageType() != storageType) {
    logNodeIsNotChosen(storage,"storage types do not match, where the expected storage type is " + storageType);
    return false;
  }
  if (storage.getState() == State.READ_ONLY_SHARED) {
    logNodeIsNotChosen(storage,"storage is read-only");
    return false;
  }
  DatanodeDescriptor node=storage.getDatanodeDescriptor();
  if (node.isDecommissionInProgress() || node.isDecommissioned()) {
    logNodeIsNotChosen(storage,"the node is (being) decommissioned ");
    return false;
  }
  if (avoidStaleNodes) {
    if (node.isStale(this.staleInterval)) {
      logNodeIsNotChosen(storage,"the node is stale ");
      return false;
    }
  }
  final long requiredSize=blockSize * HdfsConstants.MIN_BLOCKS_FOR_WRITE;
  final long scheduledSize=blockSize * node.getBlocksScheduled();
  if (requiredSize > node.getRemaining() - scheduledSize) {
    logNodeIsNotChosen(storage,"the node does not have enough space ");
    return false;
  }
  if (considerLoad) {
    double avgLoad=0;
    if (stats != null) {
      int size=stats.getNumDatanodesInService();
      if (size != 0) {
        avgLoad=(double)stats.getTotalLoad() / size;
      }
    }
    if (node.getXceiverCount() > (2.0 * avgLoad)) {
      logNodeIsNotChosen(storage,"the node is too busy ");
      return false;
    }
  }
  String rackname=node.getNetworkLocation();
  int counter=1;
  for (  DatanodeStorageInfo resultStorage : results) {
    if (rackname.equals(resultStorage.getDatanodeDescriptor().getNetworkLocation())) {
      counter++;
    }
  }
  if (counter > maxTargetPerRack) {
    logNodeIsNotChosen(storage,"the rack has too many chosen nodes ");
    return false;
  }
  return true;
}
