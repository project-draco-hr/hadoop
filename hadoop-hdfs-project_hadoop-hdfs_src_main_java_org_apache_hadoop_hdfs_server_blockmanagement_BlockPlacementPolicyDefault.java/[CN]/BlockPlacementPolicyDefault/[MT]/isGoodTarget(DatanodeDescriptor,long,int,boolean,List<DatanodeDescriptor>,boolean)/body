{
  if (node.isDecommissionInProgress() || node.isDecommissioned()) {
    if (LOG.isDebugEnabled()) {
      threadLocalBuilder.get().append(node.toString()).append(": ").append("Node ").append(NodeBase.getPath(node)).append(" is not chosen because the node is (being) decommissioned ");
    }
    return false;
  }
  if (avoidStaleNodes) {
    if (node.isStale(this.staleInterval)) {
      if (LOG.isDebugEnabled()) {
        threadLocalBuilder.get().append(node.toString()).append(": ").append("Node ").append(NodeBase.getPath(node)).append(" is not chosen because the node is staled ");
      }
      return false;
    }
  }
  long remaining=node.getRemaining() - (node.getBlocksScheduled() * blockSize);
  if (blockSize * HdfsConstants.MIN_BLOCKS_FOR_WRITE > remaining) {
    if (LOG.isDebugEnabled()) {
      threadLocalBuilder.get().append(node.toString()).append(": ").append("Node ").append(NodeBase.getPath(node)).append(" is not chosen because the node does not have enough space ");
    }
    return false;
  }
  if (considerLoad) {
    double avgLoad=0;
    int size=clusterMap.getNumOfLeaves();
    if (size != 0 && stats != null) {
      avgLoad=(double)stats.getTotalLoad() / size;
    }
    if (node.getXceiverCount() > (2.0 * avgLoad)) {
      if (LOG.isDebugEnabled()) {
        threadLocalBuilder.get().append(node.toString()).append(": ").append("Node ").append(NodeBase.getPath(node)).append(" is not chosen because the node is too busy ");
      }
      return false;
    }
  }
  String rackname=node.getNetworkLocation();
  int counter=1;
  for (Iterator<DatanodeDescriptor> iter=results.iterator(); iter.hasNext(); ) {
    Node result=iter.next();
    if (rackname.equals(result.getNetworkLocation())) {
      counter++;
    }
  }
  if (counter > maxTargetPerRack) {
    if (LOG.isDebugEnabled()) {
      threadLocalBuilder.get().append(node.toString()).append(": ").append("Node ").append(NodeBase.getPath(node)).append(" is not chosen because the rack has too many chosen nodes ");
    }
    return false;
  }
  return true;
}
