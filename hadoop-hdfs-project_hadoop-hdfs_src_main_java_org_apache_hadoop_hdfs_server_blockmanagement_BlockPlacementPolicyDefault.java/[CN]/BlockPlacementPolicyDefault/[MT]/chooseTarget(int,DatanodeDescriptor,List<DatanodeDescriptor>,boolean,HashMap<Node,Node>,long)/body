{
  if (numOfReplicas == 0 || clusterMap.getNumOfLeaves() == 0) {
    return new DatanodeDescriptor[0];
  }
  if (excludedNodes == null) {
    excludedNodes=new HashMap<Node,Node>();
  }
  int clusterSize=clusterMap.getNumOfLeaves();
  int totalNumOfReplicas=chosenNodes.size() + numOfReplicas;
  if (totalNumOfReplicas > clusterSize) {
    numOfReplicas-=(totalNumOfReplicas - clusterSize);
    totalNumOfReplicas=clusterSize;
  }
  int maxNodesPerRack=(totalNumOfReplicas - 1) / clusterMap.getNumOfRacks() + 2;
  List<DatanodeDescriptor> results=new ArrayList<DatanodeDescriptor>(chosenNodes);
  for (  Node node : chosenNodes) {
    excludedNodes.put(node,node);
    adjustExcludedNodes(excludedNodes,node);
  }
  if (!clusterMap.contains(writer)) {
    writer=null;
  }
  boolean avoidStaleNodes=(stats != null && stats.isAvoidingStaleDataNodesForWrite());
  DatanodeDescriptor localNode=chooseTarget(numOfReplicas,writer,excludedNodes,blocksize,maxNodesPerRack,results,avoidStaleNodes);
  if (!returnChosenNodes) {
    results.removeAll(chosenNodes);
  }
  return getPipeline((writer == null) ? localNode : writer,results.toArray(new DatanodeDescriptor[results.size()]));
}
