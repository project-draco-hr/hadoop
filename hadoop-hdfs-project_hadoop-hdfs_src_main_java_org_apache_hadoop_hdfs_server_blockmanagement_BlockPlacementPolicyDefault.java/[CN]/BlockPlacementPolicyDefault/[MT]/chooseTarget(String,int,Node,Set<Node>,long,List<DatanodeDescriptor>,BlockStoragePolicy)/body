{
  try {
    if (favoredNodes == null || favoredNodes.size() == 0) {
      return chooseTarget(src,numOfReplicas,writer,new ArrayList<DatanodeStorageInfo>(numOfReplicas),false,excludedNodes,blocksize,storagePolicy);
    }
    Set<Node> favoriteAndExcludedNodes=excludedNodes == null ? new HashSet<Node>() : new HashSet<Node>(excludedNodes);
    final List<StorageType> storageTypes=storagePolicy.chooseStorageTypes((short)numOfReplicas);
    List<DatanodeStorageInfo> results=new ArrayList<DatanodeStorageInfo>();
    boolean avoidStaleNodes=stats != null && stats.isAvoidingStaleDataNodesForWrite();
    for (int i=0; i < Math.min(favoredNodes.size(),numOfReplicas); i++) {
      DatanodeDescriptor favoredNode=favoredNodes.get(i);
      final DatanodeStorageInfo target=chooseLocalStorage(favoredNode,favoriteAndExcludedNodes,blocksize,getMaxNodesPerRack(results.size(),numOfReplicas)[1],results,avoidStaleNodes,storageTypes.get(0));
      if (target == null) {
        LOG.warn("Could not find a target for file " + src + " with favored node "+ favoredNode);
        continue;
      }
      storageTypes.remove(0);
      favoriteAndExcludedNodes.add(target.getDatanodeDescriptor());
    }
    if (results.size() < numOfReplicas) {
      numOfReplicas-=results.size();
      DatanodeStorageInfo[] remainingTargets=chooseTarget(src,numOfReplicas,writer,results,false,favoriteAndExcludedNodes,blocksize,storagePolicy);
      for (int i=0; i < remainingTargets.length; i++) {
        results.add(remainingTargets[i]);
      }
    }
    return getPipeline(writer,results.toArray(new DatanodeStorageInfo[results.size()]));
  }
 catch (  NotEnoughReplicasException nr) {
    return chooseTarget(src,numOfReplicas,writer,new ArrayList<DatanodeStorageInfo>(numOfReplicas),false,excludedNodes,blocksize,storagePolicy);
  }
}
