{
  try {
    if (favoredNodes == null || favoredNodes.size() == 0) {
      return chooseTarget(src,numOfReplicas,writer,new ArrayList<DatanodeDescriptor>(numOfReplicas),false,excludedNodes,blocksize);
    }
    Map<Node,Node> favoriteAndExcludedNodes=excludedNodes == null ? new HashMap<Node,Node>() : new HashMap<Node,Node>(excludedNodes);
    List<DatanodeDescriptor> results=new ArrayList<DatanodeDescriptor>();
    boolean avoidStaleNodes=stats != null && stats.isAvoidingStaleDataNodesForWrite();
    for (int i=0; i < Math.min(favoredNodes.size(),numOfReplicas); i++) {
      DatanodeDescriptor favoredNode=favoredNodes.get(i);
      DatanodeDescriptor target=chooseLocalNode(favoredNode,favoriteAndExcludedNodes,blocksize,getMaxNodesPerRack(results,numOfReplicas)[1],results,avoidStaleNodes);
      if (target == null) {
        LOG.warn("Could not find a target for file " + src + " with favored node "+ favoredNode);
        continue;
      }
      favoriteAndExcludedNodes.put(target,target);
    }
    if (results.size() < numOfReplicas) {
      numOfReplicas-=results.size();
      DatanodeDescriptor[] remainingTargets=chooseTarget(src,numOfReplicas,writer,results,false,favoriteAndExcludedNodes,blocksize);
      for (int i=0; i < remainingTargets.length; i++) {
        results.add(remainingTargets[i]);
      }
    }
    return getPipeline(writer,results.toArray(new DatanodeDescriptor[results.size()]));
  }
 catch (  NotEnoughReplicasException nr) {
    return chooseTarget(src,numOfReplicas,writer,new ArrayList<DatanodeDescriptor>(numOfReplicas),false,excludedNodes,blocksize);
  }
}
