{
  ErasureCodingPolicy ecPolicy=reconstructionInfo.getErasureCodingPolicy();
  dataBlkNum=ecPolicy.getNumDataUnits();
  parityBlkNum=ecPolicy.getNumParityUnits();
  cellSize=ecPolicy.getCellSize();
  blockGroup=reconstructionInfo.getExtendedBlock();
  final int cellsNum=(int)((blockGroup.getNumBytes() - 1) / cellSize + 1);
  minRequiredSources=Math.min(cellsNum,dataBlkNum);
  liveIndices=reconstructionInfo.getLiveBlockIndices();
  sources=reconstructionInfo.getSourceDnInfos();
  stripedReaders=new ArrayList<>(sources.length);
  Preconditions.checkArgument(liveIndices.length >= minRequiredSources,"No enough live striped blocks.");
  Preconditions.checkArgument(liveIndices.length == sources.length,"liveBlockIndices and source dns should match");
  if (minRequiredSources < dataBlkNum) {
    zeroStripeBuffers=new ByteBuffer[dataBlkNum - minRequiredSources];
    zeroStripeIndices=new short[dataBlkNum - minRequiredSources];
  }
  targets=reconstructionInfo.getTargetDnInfos();
  targetStorageTypes=reconstructionInfo.getTargetStorageTypes();
  targetIndices=new short[targets.length];
  targetBuffers=new ByteBuffer[targets.length];
  Preconditions.checkArgument(targetIndices.length <= parityBlkNum,"Too much missed striped blocks.");
  targetSockets=new Socket[targets.length];
  targetOutputStreams=new DataOutputStream[targets.length];
  targetInputStreams=new DataInputStream[targets.length];
  blockOffset4Targets=new long[targets.length];
  seqNo4Targets=new long[targets.length];
  for (int i=0; i < targets.length; i++) {
    blockOffset4Targets[i]=0;
    seqNo4Targets[i]=0;
  }
  hasValidTargets=getTargetIndices();
  cachingStrategy=CachingStrategy.newDefaultStrategy();
}
