{
  int nsuccess=0;
  for (int i=0; i < targets.length; i++) {
    Socket socket=null;
    DataOutputStream out=null;
    DataInputStream in=null;
    boolean success=false;
    try {
      InetSocketAddress targetAddr=getSocketAddress4Transfer(targets[i]);
      socket=datanode.newSocket();
      NetUtils.connect(socket,targetAddr,datanode.getDnConf().getSocketTimeout());
      socket.setSoTimeout(datanode.getDnConf().getSocketTimeout());
      ExtendedBlock block=getBlock(blockGroup,targetIndices[i]);
      Token<BlockTokenIdentifier> blockToken=datanode.getBlockAccessToken(block,EnumSet.of(BlockTokenIdentifier.AccessMode.WRITE));
      long writeTimeout=datanode.getDnConf().getSocketWriteTimeout();
      OutputStream unbufOut=NetUtils.getOutputStream(socket,writeTimeout);
      InputStream unbufIn=NetUtils.getInputStream(socket);
      DataEncryptionKeyFactory keyFactory=datanode.getDataEncryptionKeyFactoryForBlock(block);
      IOStreamPair saslStreams=datanode.getSaslClient().socketSend(socket,unbufOut,unbufIn,keyFactory,blockToken,targets[i]);
      unbufOut=saslStreams.out;
      unbufIn=saslStreams.in;
      out=new DataOutputStream(new BufferedOutputStream(unbufOut,DFSUtil.getSmallBufferSize(conf)));
      in=new DataInputStream(unbufIn);
      DatanodeInfo source=new DatanodeInfo(datanode.getDatanodeId());
      new Sender(out).writeBlock(block,targetStorageTypes[i],blockToken,"",new DatanodeInfo[]{targets[i]},new StorageType[]{targetStorageTypes[i]},source,BlockConstructionStage.PIPELINE_SETUP_CREATE,0,0,0,0,checksum,cachingStrategy,false,false,null);
      targetSockets[i]=socket;
      targetOutputStreams[i]=out;
      targetInputStreams[i]=in;
      nsuccess++;
      success=true;
    }
 catch (    Throwable e) {
      LOG.warn(e.getMessage());
    }
 finally {
      if (!success) {
        IOUtils.closeStream(out);
        IOUtils.closeStream(in);
        IOUtils.closeStream(socket);
      }
    }
    targetsStatus[i]=success;
  }
  return nsuccess;
}
