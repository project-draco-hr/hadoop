{
  initDecoderIfNecessary();
  ByteBuffer[] inputs=new ByteBuffer[dataBlkNum + parityBlkNum];
  for (int i=0; i < success.length; i++) {
    StripedReader reader=stripedReaders.get(success[i]);
    ByteBuffer buffer=reader.buffer;
    paddingBufferToLen(buffer,toRecoverLen);
    inputs[convertIndex4Decode(reader.index,dataBlkNum,parityBlkNum)]=(ByteBuffer)buffer.flip();
  }
  if (success.length < dataBlkNum) {
    for (int i=0; i < zeroStripeBuffers.length; i++) {
      ByteBuffer buffer=zeroStripeBuffers[i];
      paddingBufferToLen(buffer,toRecoverLen);
      int index=convertIndex4Decode(zeroStripeIndices[i],dataBlkNum,parityBlkNum);
      inputs[index]=(ByteBuffer)buffer.flip();
    }
  }
  int[] erasedIndices=getErasedIndices(targetsStatus);
  ByteBuffer[] outputs=new ByteBuffer[erasedIndices.length];
  int m=0;
  for (int i=0; i < targetBuffers.length; i++) {
    if (targetsStatus[i]) {
      outputs[m++]=targetBuffers[i];
      outputs[i].limit(toRecoverLen);
    }
  }
  decoder.decode(inputs,erasedIndices,outputs);
  for (int i=0; i < targets.length; i++) {
    if (targetsStatus[i]) {
      long blockLen=getBlockLen(blockGroup,targetIndices[i]);
      long remaining=blockLen - positionInBlock;
      if (remaining < 0) {
        targetBuffers[i].limit(0);
      }
 else       if (remaining < toRecoverLen) {
        targetBuffers[i].limit((int)remaining);
      }
    }
  }
}
