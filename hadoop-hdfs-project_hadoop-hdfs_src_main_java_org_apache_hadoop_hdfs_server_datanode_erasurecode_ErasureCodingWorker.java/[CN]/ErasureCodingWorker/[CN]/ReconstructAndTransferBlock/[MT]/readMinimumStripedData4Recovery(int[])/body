{
  int nsuccess=0;
  int[] newSuccess=new int[minRequiredSources];
  BitSet used=new BitSet(sources.length);
  for (int i=0; i < minRequiredSources; i++) {
    StripedReader reader=stripedReaders.get(success[i]);
    if (getReadLength(liveIndices[success[i]]) > 0) {
      Callable<Void> readCallable=readFromBlock(reader.blockReader,reader.buffer);
      Future<Void> f=readService.submit(readCallable);
      futures.put(f,success[i]);
    }
 else {
      reader.buffer.position(0);
      newSuccess[nsuccess++]=success[i];
    }
    used.set(success[i]);
  }
  while (!futures.isEmpty()) {
    try {
      StripingChunkReadResult result=StripedBlockUtil.getNextCompletedStripedRead(readService,futures,STRIPED_READ_TIMEOUT_MILLIS);
      int resultIndex=-1;
      if (result.state == StripingChunkReadResult.SUCCESSFUL) {
        resultIndex=result.index;
      }
 else       if (result.state == StripingChunkReadResult.FAILED) {
        StripedReader failedReader=stripedReaders.get(result.index);
        closeBlockReader(failedReader.blockReader);
        failedReader.blockReader=null;
        resultIndex=scheduleNewRead(used);
      }
 else       if (result.state == StripingChunkReadResult.TIMEOUT) {
        resultIndex=scheduleNewRead(used);
      }
      if (resultIndex >= 0) {
        newSuccess[nsuccess++]=resultIndex;
        if (nsuccess >= minRequiredSources) {
          cancelReads(futures.keySet());
          futures.clear();
          break;
        }
      }
    }
 catch (    InterruptedException e) {
      LOG.info("Read data interrupted.",e);
      break;
    }
  }
  if (nsuccess < minRequiredSources) {
    String error="Can't read data from minimum number of sources " + "required by reconstruction, block id: " + blockGroup.getBlockId();
    throw new IOException(error);
  }
  return newSuccess;
}
