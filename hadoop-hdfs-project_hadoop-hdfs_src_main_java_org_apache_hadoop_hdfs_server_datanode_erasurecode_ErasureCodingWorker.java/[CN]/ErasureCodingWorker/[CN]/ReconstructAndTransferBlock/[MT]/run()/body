{
  datanode.incrementXmitsInProgress();
  try {
    int[] success=new int[minRequiredSources];
    int nsuccess=0;
    for (int i=0; i < sources.length && nsuccess < minRequiredSources; i++) {
      StripedReader reader=addStripedReader(i,0);
      if (reader.blockReader != null) {
        success[nsuccess++]=i;
      }
    }
    if (nsuccess < minRequiredSources) {
      String error="Can't find minimum sources required by " + "recovery, block id: " + blockGroup.getBlockId();
      throw new IOException(error);
    }
    if (zeroStripeBuffers != null) {
      for (int i=0; i < zeroStripeBuffers.length; i++) {
        zeroStripeBuffers[i]=allocateBuffer(bufferSize);
      }
    }
    for (int i=0; i < targets.length; i++) {
      targetBuffers[i]=allocateBuffer(bufferSize);
    }
    checksumSize=checksum.getChecksumSize();
    int chunkSize=bytesPerChecksum + checksumSize;
    maxChunksPerPacket=Math.max((WRITE_PACKET_SIZE - PacketHeader.PKT_MAX_HEADER_LEN) / chunkSize,1);
    int maxPacketSize=chunkSize * maxChunksPerPacket + PacketHeader.PKT_MAX_HEADER_LEN;
    packetBuf=new byte[maxPacketSize];
    checksumBuf=new byte[checksumSize * (bufferSize / bytesPerChecksum)];
    boolean[] targetsStatus=new boolean[targets.length];
    if (initTargetStreams(targetsStatus) == 0) {
      String error="All targets are failed.";
      throw new IOException(error);
    }
    long firstStripedBlockLength=getBlockLen(blockGroup,0);
    while (positionInBlock < firstStripedBlockLength) {
      int toRead=Math.min(bufferSize,(int)(firstStripedBlockLength - positionInBlock));
      success=readMinimumStripedData4Recovery(success);
      long remaining=firstStripedBlockLength - positionInBlock;
      int toRecoverLen=remaining < bufferSize ? (int)remaining : bufferSize;
      recoverTargets(success,targetsStatus,toRecoverLen);
      if (transferData2Targets(targetsStatus) == 0) {
        String error="Transfer failed for all targets.";
        throw new IOException(error);
      }
      clearBuffers();
      positionInBlock+=toRead;
    }
    endTargetBlocks(targetsStatus);
  }
 catch (  Throwable e) {
    LOG.warn("Failed to recover striped block: " + blockGroup,e);
  }
 finally {
    datanode.decrementXmitsInProgress();
    for (    StripedReader stripedReader : stripedReaders) {
      closeBlockReader(stripedReader.blockReader);
    }
    for (int i=0; i < targets.length; i++) {
      IOUtils.closeStream(targetOutputStreams[i]);
      IOUtils.closeStream(targetInputStreams[i]);
      IOUtils.closeStream(targetSockets[i]);
    }
  }
}
