{
  datanode.incrementXmitsInProgress();
  try {
    int[] success=new int[minRequiredSources];
    int nsuccess=0;
    for (int i=0; i < sources.length && nsuccess < minRequiredSources; i++) {
      StripedReader reader=addStripedReader(i,0);
      if (reader.blockReader != null) {
        success[nsuccess++]=i;
      }
    }
    if (nsuccess < minRequiredSources) {
      String error="Can't find minimum sources required by " + "reconstruction, block id: " + blockGroup.getBlockId();
      throw new IOException(error);
    }
    if (zeroStripeBuffers != null) {
      for (int i=0; i < zeroStripeBuffers.length; i++) {
        zeroStripeBuffers[i]=allocateBuffer(bufferSize);
      }
    }
    for (int i=0; i < targets.length; i++) {
      targetBuffers[i]=allocateBuffer(bufferSize);
    }
    checksumSize=checksum.getChecksumSize();
    int chunkSize=bytesPerChecksum + checksumSize;
    maxChunksPerPacket=Math.max((WRITE_PACKET_SIZE - PacketHeader.PKT_MAX_HEADER_LEN) / chunkSize,1);
    int maxPacketSize=chunkSize * maxChunksPerPacket + PacketHeader.PKT_MAX_HEADER_LEN;
    packetBuf=new byte[maxPacketSize];
    checksumBuf=new byte[checksumSize * (bufferSize / bytesPerChecksum)];
    boolean[] targetsStatus=new boolean[targets.length];
    if (initTargetStreams(targetsStatus) == 0) {
      String error="All targets are failed.";
      throw new IOException(error);
    }
    long maxTargetLength=0;
    for (    short targetIndex : targetIndices) {
      maxTargetLength=Math.max(maxTargetLength,getBlockLen(blockGroup,targetIndex));
    }
    while (positionInBlock < maxTargetLength) {
      final int toReconstruct=(int)Math.min(bufferSize,maxTargetLength - positionInBlock);
      Map<ExtendedBlock,Set<DatanodeInfo>> corruptionMap=new HashMap<>();
      try {
        success=readMinimumStripedData4Reconstruction(success,toReconstruct,corruptionMap);
      }
  finally {
        reportCorruptedBlocks(corruptionMap);
      }
      reconstructTargets(success,targetsStatus,toReconstruct);
      if (transferData2Targets(targetsStatus) == 0) {
        String error="Transfer failed for all targets.";
        throw new IOException(error);
      }
      clearBuffers();
      positionInBlock+=toReconstruct;
    }
    endTargetBlocks(targetsStatus);
  }
 catch (  Throwable e) {
    LOG.warn("Failed to reconstruct striped block: " + blockGroup,e);
  }
 finally {
    datanode.decrementXmitsInProgress();
    for (    StripedReader stripedReader : stripedReaders) {
      closeBlockReader(stripedReader.blockReader);
    }
    for (int i=0; i < targets.length; i++) {
      IOUtils.closeStream(targetOutputStreams[i]);
      IOUtils.closeStream(targetInputStreams[i]);
      IOUtils.closeStream(targetSockets[i]);
    }
  }
}
