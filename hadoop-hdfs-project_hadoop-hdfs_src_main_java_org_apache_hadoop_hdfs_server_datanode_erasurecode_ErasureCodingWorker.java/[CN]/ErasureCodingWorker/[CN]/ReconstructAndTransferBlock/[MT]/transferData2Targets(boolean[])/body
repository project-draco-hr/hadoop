{
  int nsuccess=0;
  for (int i=0; i < targets.length; i++) {
    if (targetsStatus[i]) {
      boolean success=false;
      try {
        ByteBuffer buffer=targetBuffers[i];
        if (buffer.remaining() == 0) {
          continue;
        }
        checksum.calculateChunkedSums(buffer.array(),0,buffer.remaining(),checksumBuf,0);
        int ckOff=0;
        while (buffer.remaining() > 0) {
          DFSPacket packet=new DFSPacket(packetBuf,maxChunksPerPacket,blockOffset4Targets[i],seqNo4Targets[i]++,checksumSize,false);
          int maxBytesToPacket=maxChunksPerPacket * bytesPerChecksum;
          int toWrite=buffer.remaining() > maxBytesToPacket ? maxBytesToPacket : buffer.remaining();
          int ckLen=((toWrite - 1) / bytesPerChecksum + 1) * checksumSize;
          packet.writeChecksum(checksumBuf,ckOff,ckLen);
          ckOff+=ckLen;
          packet.writeData(buffer,toWrite);
          packet.writeTo(targetOutputStreams[i]);
          blockOffset4Targets[i]+=toWrite;
          nsuccess++;
          success=true;
        }
      }
 catch (      IOException e) {
        LOG.warn(e.getMessage());
      }
      targetsStatus[i]=success;
    }
  }
  return nsuccess;
}
