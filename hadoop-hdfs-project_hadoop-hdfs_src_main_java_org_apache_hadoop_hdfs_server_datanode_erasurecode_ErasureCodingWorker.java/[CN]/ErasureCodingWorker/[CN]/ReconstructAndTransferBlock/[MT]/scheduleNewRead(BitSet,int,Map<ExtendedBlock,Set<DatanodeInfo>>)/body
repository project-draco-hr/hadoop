{
  StripedReader reader=null;
  int m=stripedReaders.size();
  int toRead=0;
  while (reader == null && m < sources.length) {
    reader=addStripedReader(m,positionInBlock);
    toRead=getReadLength(liveIndices[m],reconstructLen);
    if (toRead > 0) {
      if (reader.blockReader == null) {
        reader=null;
        m++;
      }
    }
 else {
      used.set(m);
      return m;
    }
  }
  for (int i=0; reader == null && i < stripedReaders.size(); i++) {
    if (!used.get(i)) {
      StripedReader r=stripedReaders.get(i);
      toRead=getReadLength(liveIndices[i],reconstructLen);
      if (toRead > 0) {
        IOUtils.closeStream(r.blockReader);
        r.blockReader=newBlockReader(getBlock(blockGroup,liveIndices[i]),positionInBlock,sources[i]);
        if (r.blockReader != null) {
          r.buffer.position(0);
          m=i;
          reader=r;
        }
      }
 else {
        used.set(i);
        r.buffer.position(0);
        return i;
      }
    }
  }
  if (reader != null) {
    Callable<Void> readCallable=readFromBlock(reader,reader.buffer,toRead,corruptionMap);
    Future<Void> f=readService.submit(readCallable);
    futures.put(f,m);
    used.set(m);
  }
  return -1;
}
