{
  final RetryPolicy multipleLinearRandomRetry=getMultipleLinearRandomRetry(conf,retryPolicyEnabledKey,defaultRetryPolicyEnabled,retryPolicySpecKey,defaultRetryPolicySpec);
  if (LOG.isDebugEnabled()) {
    LOG.debug("multipleLinearRandomRetry = " + multipleLinearRandomRetry);
  }
  if (multipleLinearRandomRetry == null) {
    return RetryPolicies.TRY_ONCE_THEN_FAIL;
  }
 else {
    return new RetryPolicy(){
      @Override public RetryAction shouldRetry(      Exception e,      int retries,      int failovers,      boolean isMethodIdempotent) throws Exception {
        if (e instanceof ServiceException) {
          final Throwable cause=e.getCause();
          if (cause != null && cause instanceof Exception) {
            e=(Exception)cause;
          }
        }
        final RetryPolicy p;
        if (e instanceof RemoteException) {
          final RemoteException re=(RemoteException)e;
          p=remoteExceptionToRetry.getName().equals(re.getClassName()) ? multipleLinearRandomRetry : RetryPolicies.TRY_ONCE_THEN_FAIL;
        }
 else         if (e instanceof IOException || e instanceof ServiceException) {
          p=multipleLinearRandomRetry;
        }
 else {
          p=RetryPolicies.TRY_ONCE_THEN_FAIL;
        }
        if (LOG.isDebugEnabled()) {
          LOG.debug("RETRY " + retries + ") policy="+ p.getClass().getSimpleName()+ ", exception="+ e);
        }
        return p.shouldRetry(e,retries,failovers,isMethodIdempotent);
      }
      @Override public String toString(){
        return "RetryPolicy[" + multipleLinearRandomRetry + ", "+ RetryPolicies.TRY_ONCE_THEN_FAIL.getClass().getSimpleName()+ "]";
      }
    }
;
  }
}
