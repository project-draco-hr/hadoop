{
  boolean success=false;
  FileInputStream blockIn=null, metaIn=null;
  MappableBlock mappableBlock=null;
  ExtendedBlock extBlk=new ExtendedBlock(key.getBlockPoolId(),key.getBlockId(),length,genstamp);
  long newUsedBytes=usedBytesCount.reserve(length);
  boolean reservedBytes=false;
  try {
    if (newUsedBytes < 0) {
      LOG.warn("Failed to cache " + key + ": could not reserve "+ length+ " more bytes in the cache: "+ DFSConfigKeys.DFS_DATANODE_MAX_LOCKED_MEMORY_KEY+ " of "+ maxBytes+ " exceeded.");
      return;
    }
    reservedBytes=true;
    try {
      blockIn=(FileInputStream)dataset.getBlockInputStream(extBlk,0);
      metaIn=DatanodeUtil.getMetaDataInputStream(extBlk,dataset);
    }
 catch (    ClassCastException e) {
      LOG.warn("Failed to cache " + key + ": Underlying blocks are not backed by files.",e);
      return;
    }
catch (    FileNotFoundException e) {
      LOG.info("Failed to cache " + key + ": failed to find backing "+ "files.");
      return;
    }
catch (    IOException e) {
      LOG.warn("Failed to cache " + key + ": failed to open file",e);
      return;
    }
    try {
      mappableBlock=MappableBlock.load(length,blockIn,metaIn,blockFileName);
    }
 catch (    ChecksumException e) {
      LOG.warn("Failed to cache " + key + ": checksum verification failed.");
      return;
    }
catch (    IOException e) {
      LOG.warn("Failed to cache " + key,e);
      return;
    }
synchronized (FsDatasetCache.this) {
      Value value=mappableBlockMap.get(key);
      Preconditions.checkNotNull(value);
      Preconditions.checkState(value.state == State.CACHING || value.state == State.CACHING_CANCELLED);
      if (value.state == State.CACHING_CANCELLED) {
        mappableBlockMap.remove(key);
        LOG.warn("Caching of " + key + " was cancelled.");
        return;
      }
      mappableBlockMap.put(key,new Value(mappableBlock,State.CACHED));
    }
    LOG.debug("Successfully cached {}.  We are now caching {} bytes in" + " total.",key,newUsedBytes);
    dataset.datanode.getShortCircuitRegistry().processBlockMlockEvent(key);
    numBlocksCached.addAndGet(1);
    dataset.datanode.getMetrics().incrBlocksCached(1);
    success=true;
  }
  finally {
    IOUtils.closeQuietly(blockIn);
    IOUtils.closeQuietly(metaIn);
    if (!success) {
      if (reservedBytes) {
        usedBytesCount.release(length);
      }
      LOG.debug("Caching of {} was aborted.  We are now caching only {} " + "bytes in total.",key,usedBytesCount.get());
      if (mappableBlock != null) {
        mappableBlock.close();
      }
      numBlocksFailedToCache.incrementAndGet();
synchronized (FsDatasetCache.this) {
        mappableBlockMap.remove(key);
      }
    }
  }
}
