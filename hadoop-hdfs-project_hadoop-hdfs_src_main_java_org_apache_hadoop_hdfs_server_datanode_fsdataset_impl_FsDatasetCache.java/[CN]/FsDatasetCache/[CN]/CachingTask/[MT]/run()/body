{
  boolean success=false;
  FileInputStream blockIn=null, metaIn=null;
  MappableBlock mappableBlock=null;
  ExtendedBlock extBlk=new ExtendedBlock(key.bpid,key.id,length,genstamp);
  long newUsedBytes=usedBytesCount.reserve(length);
  if (newUsedBytes < 0) {
    LOG.warn("Failed to cache block id " + key.id + ", pool "+ key.bpid+ ": could not reserve "+ length+ " more bytes in the "+ "cache: "+ DFSConfigKeys.DFS_DATANODE_MAX_LOCKED_MEMORY_KEY+ " of "+ maxBytes+ " exceeded.");
    numBlocksFailedToCache.incrementAndGet();
    return;
  }
  try {
    try {
      blockIn=(FileInputStream)dataset.getBlockInputStream(extBlk,0);
      metaIn=(FileInputStream)dataset.getMetaDataInputStream(extBlk).getWrappedStream();
    }
 catch (    ClassCastException e) {
      LOG.warn("Failed to cache block with id " + key.id + ", pool "+ key.bpid+ ": Underlying blocks are not backed by files.",e);
      return;
    }
catch (    FileNotFoundException e) {
      LOG.info("Failed to cache block with id " + key.id + ", pool "+ key.bpid+ ": failed to find backing files.");
      return;
    }
catch (    IOException e) {
      LOG.warn("Failed to cache block with id " + key.id + ", pool "+ key.bpid+ ": failed to open file",e);
      return;
    }
    try {
      mappableBlock=MappableBlock.load(length,blockIn,metaIn,blockFileName);
    }
 catch (    ChecksumException e) {
      LOG.warn("Failed to cache block " + key.id + " in "+ key.bpid+ ": "+ "checksum verification failed.");
      return;
    }
catch (    IOException e) {
      LOG.warn("Failed to cache block " + key.id + " in "+ key.bpid,e);
      return;
    }
synchronized (FsDatasetCache.this) {
      Value value=mappableBlockMap.get(key);
      Preconditions.checkNotNull(value);
      Preconditions.checkState(value.state == State.CACHING || value.state == State.CACHING_CANCELLED);
      if (value.state == State.CACHING_CANCELLED) {
        mappableBlockMap.remove(key);
        LOG.warn("Caching of block " + key.id + " in "+ key.bpid+ " was cancelled.");
        return;
      }
      mappableBlockMap.put(key,new Value(mappableBlock,State.CACHED));
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("Successfully cached block " + key.id + " in "+ key.bpid+ ".  We are now caching "+ newUsedBytes+ " bytes in total.");
    }
    numBlocksCached.addAndGet(1);
    success=true;
  }
  finally {
    if (!success) {
      newUsedBytes=usedBytesCount.release(length);
      if (LOG.isDebugEnabled()) {
        LOG.debug("Caching of block " + key.id + " in "+ key.bpid+ " was aborted.  We are now caching only "+ newUsedBytes+ " + bytes in total.");
      }
      IOUtils.closeQuietly(blockIn);
      IOUtils.closeQuietly(metaIn);
      if (mappableBlock != null) {
        mappableBlock.close();
      }
      numBlocksFailedToCache.incrementAndGet();
synchronized (FsDatasetCache.this) {
        mappableBlockMap.remove(key);
      }
    }
  }
}
