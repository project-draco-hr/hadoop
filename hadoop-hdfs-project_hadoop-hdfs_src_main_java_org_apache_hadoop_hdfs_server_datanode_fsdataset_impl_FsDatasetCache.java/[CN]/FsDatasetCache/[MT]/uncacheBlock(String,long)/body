{
  Key key=new Key(blockId,bpid);
  Value prevValue=mappableBlockMap.get(key);
  if (prevValue == null) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Block with id " + blockId + ", pool "+ bpid+ " "+ "does not need to be uncached, because it is not currently "+ "in the mappableBlockMap.");
    }
    numBlocksFailedToUncache.incrementAndGet();
    return;
  }
switch (prevValue.state) {
case CACHING:
    if (LOG.isDebugEnabled()) {
      LOG.debug("Cancelling caching for block with id " + blockId + ", pool "+ bpid+ ".");
    }
  mappableBlockMap.put(key,new Value(prevValue.mappableBlock,State.CACHING_CANCELLED));
break;
case CACHED:
if (LOG.isDebugEnabled()) {
LOG.debug("Block with id " + blockId + ", pool "+ bpid+ " "+ "has been scheduled for uncaching.");
}
mappableBlockMap.put(key,new Value(prevValue.mappableBlock,State.UNCACHING));
uncachingExecutor.execute(new UncachingTask(key));
break;
default :
if (LOG.isDebugEnabled()) {
LOG.debug("Block with id " + blockId + ", pool "+ bpid+ " "+ "does not need to be uncached, because it is "+ "in state "+ prevValue.state+ ".");
}
numBlocksFailedToUncache.incrementAndGet();
break;
}
}
