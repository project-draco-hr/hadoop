{
  ExtendedBlockId key=new ExtendedBlockId(blockId,bpid);
  Value prevValue=mappableBlockMap.get(key);
  if (!dataset.datanode.getShortCircuitRegistry().processBlockMunlockRequest(key)) {
    LOG.debug("{} is anchored, and can't be uncached now.",key);
    return;
  }
  if (prevValue == null) {
    LOG.debug("Block with id {}, pool {} does not need to be uncached, " + "because it is not currently in the mappableBlockMap.",blockId,bpid);
    numBlocksFailedToUncache.incrementAndGet();
    return;
  }
switch (prevValue.state) {
case CACHING:
    LOG.debug("Cancelling caching for block with id {}, pool {}.",blockId,bpid);
  mappableBlockMap.put(key,new Value(prevValue.mappableBlock,State.CACHING_CANCELLED));
break;
case CACHED:
LOG.debug("Block with id {}, pool {} has been scheduled for uncaching" + ".",blockId,bpid);
mappableBlockMap.put(key,new Value(prevValue.mappableBlock,State.UNCACHING));
uncachingExecutor.execute(new UncachingTask(key));
break;
default :
LOG.debug("Block with id {}, pool {} does not need to be uncached, " + "because it is in state {}.",blockId,bpid,prevValue.state);
numBlocksFailedToUncache.incrementAndGet();
break;
}
}
