{
  ReservationInterval searchInterval=new ReservationInterval(tick,Long.MAX_VALUE);
  readLock.lock();
  try {
    SortedMap<ReservationInterval,Set<InMemoryReservationAllocation>> reservations=currentReservations.headMap(searchInterval,true);
    if (!reservations.isEmpty()) {
      Set<ReservationAllocation> flattenedReservations=new HashSet<ReservationAllocation>();
      for (      Set<InMemoryReservationAllocation> reservationEntries : reservations.values()) {
        for (        InMemoryReservationAllocation reservation : reservationEntries) {
          if (reservation.getEndTime() > tick) {
            flattenedReservations.add(reservation);
          }
        }
      }
      return Collections.unmodifiableSet(flattenedReservations);
    }
 else {
      return Collections.emptySet();
    }
  }
  finally {
    readLock.unlock();
  }
}
