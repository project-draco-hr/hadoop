{
  this.conf=conf;
  this.clock=clock;
  this.jobFile=remoteJobConfFile;
  ReadWriteLock readWriteLock=new ReentrantReadWriteLock();
  readLock=readWriteLock.readLock();
  writeLock=readWriteLock.writeLock();
  this.attempts=Collections.emptyMap();
  maxAttempts=getMaxAttempts();
  taskId=MRBuilderUtils.newTaskId(jobId,partition,taskType);
  this.partition=partition;
  this.taskAttemptListener=taskAttemptListener;
  this.eventHandler=eventHandler;
  this.committer=committer;
  this.credentials=credentials;
  this.jobToken=jobToken;
  this.metrics=metrics;
  this.appContext=appContext;
  if (completedTasksFromPreviousRun != null && completedTasksFromPreviousRun.containsKey(taskId)) {
    LOG.info("Task is from previous run " + taskId);
    TaskInfo taskInfo=completedTasksFromPreviousRun.get(taskId);
    Map<TaskAttemptID,TaskAttemptInfo> allAttempts=taskInfo.getAllTaskAttempts();
    taskAttemptsFromPreviousGeneration=new ArrayList<TaskAttemptInfo>();
    taskAttemptsFromPreviousGeneration.addAll(allAttempts.values());
    Collections.sort(taskAttemptsFromPreviousGeneration,RECOVERED_ATTEMPTS_COMPARATOR);
  }
  if (taskAttemptsFromPreviousGeneration.isEmpty()) {
    nextAttemptNumber=(startCount - 1) * 1000;
  }
 else {
    nextAttemptNumber=taskAttemptsFromPreviousGeneration.remove(0).getAttemptId().getId();
  }
  stateMachine=stateMachineFactory.make(this);
}
