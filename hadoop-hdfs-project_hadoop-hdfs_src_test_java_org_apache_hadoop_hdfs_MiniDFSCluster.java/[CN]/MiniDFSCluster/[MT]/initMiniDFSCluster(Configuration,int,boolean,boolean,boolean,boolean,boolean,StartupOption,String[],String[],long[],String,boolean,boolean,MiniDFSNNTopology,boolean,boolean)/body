{
  ExitUtil.disableSystemExit();
synchronized (MiniDFSCluster.class) {
    instanceId=instanceCount++;
  }
  this.conf=conf;
  base_dir=new File(determineDfsBaseDir());
  data_dir=new File(base_dir,"data");
  this.waitSafeMode=waitSafeMode;
  this.checkExitOnShutdown=checkExitOnShutdown;
  int replication=conf.getInt(DFS_REPLICATION_KEY,3);
  conf.setInt(DFS_REPLICATION_KEY,Math.min(replication,numDataNodes));
  int safemodeExtension=conf.getInt(DFS_NAMENODE_SAFEMODE_EXTENSION_TESTING_KEY,0);
  conf.setInt(DFS_NAMENODE_SAFEMODE_EXTENSION_KEY,safemodeExtension);
  conf.setInt(DFS_NAMENODE_DECOMMISSION_INTERVAL_KEY,3);
  conf.setClass(NET_TOPOLOGY_NODE_SWITCH_MAPPING_IMPL_KEY,StaticMapping.class,DNSToSwitchMapping.class);
  if (!nnTopology.allHttpPortsSpecified() && nnTopology.isHA()) {
    LOG.info("MiniDFSCluster disabling checkpointing in the Standby node " + "since no HTTP ports have been specified.");
    conf.setBoolean(DFS_HA_STANDBY_CHECKPOINTS_KEY,false);
  }
  if (!nnTopology.allIpcPortsSpecified() && nnTopology.isHA()) {
    LOG.info("MiniDFSCluster disabling log-roll triggering in the " + "Standby node since no IPC ports have been specified.");
    conf.setInt(DFS_HA_LOGROLL_PERIOD_KEY,-1);
  }
  federation=nnTopology.isFederated();
  createNameNodesAndSetConf(nnTopology,manageNameDfsDirs,manageNameDfsSharedDirs,enableManagedDfsDirsRedundancy,format,operation,clusterId,conf);
  if (format) {
    if (data_dir.exists() && !FileUtil.fullyDelete(data_dir)) {
      throw new IOException("Cannot remove data directory: " + data_dir);
    }
  }
  if (operation == StartupOption.RECOVER) {
    return;
  }
  startDataNodes(conf,numDataNodes,manageDataDfsDirs,operation,racks,hosts,simulatedCapacities,setupHostsFile,false,checkDataNodeHostConfig);
  waitClusterUp();
  ProxyUsers.refreshSuperUserGroupsConfiguration(conf);
}
