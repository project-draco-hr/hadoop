{
  Preconditions.checkArgument(nnTopology.countNameNodes() > 0,"empty NN topology: no namenodes specified!");
  if (!federation && nnTopology.countNameNodes() == 1) {
    NNConf onlyNN=nnTopology.getOnlyNameNode();
    conf.set(FS_DEFAULT_NAME_KEY,"127.0.0.1:" + onlyNN.getIpcPort());
  }
  List<String> allNsIds=Lists.newArrayList();
  for (  MiniDFSNNTopology.NSConf nameservice : nnTopology.getNameservices()) {
    if (nameservice.getId() != null) {
      allNsIds.add(nameservice.getId());
    }
  }
  if (!allNsIds.isEmpty()) {
    conf.set(DFS_NAMESERVICES,Joiner.on(",").join(allNsIds));
  }
  int nnCounter=0;
  for (  MiniDFSNNTopology.NSConf nameservice : nnTopology.getNameservices()) {
    String nsId=nameservice.getId();
    Preconditions.checkArgument(!federation || nsId != null,"if there is more than one NS, they must have names");
    List<String> nnIds=Lists.newArrayList();
    for (    NNConf nn : nameservice.getNNs()) {
      nnIds.add(nn.getNnId());
      initNameNodeAddress(conf,nameservice.getId(),nn);
    }
    if (nnIds.size() > 1) {
      conf.set(DFSUtil.addKeySuffixes(DFS_HA_NAMENODES_KEY_PREFIX,nameservice.getId()),Joiner.on(",").join(nnIds));
      if (manageNameDfsSharedDirs) {
        URI sharedEditsUri=getSharedEditsDir(nnCounter,nnCounter + nnIds.size() - 1);
        conf.set(DFS_NAMENODE_SHARED_EDITS_DIR_KEY,sharedEditsUri.toString());
        FileUtil.fullyDelete(new File(sharedEditsUri));
      }
    }
    int i=0;
    Collection<URI> prevNNDirs=null;
    int nnCounterForFormat=nnCounter;
    for (    NNConf nn : nameservice.getNNs()) {
      initNameNodeConf(conf,nsId,nn.getNnId(),manageNameDfsDirs,manageNameDfsDirs,nnCounterForFormat);
      Collection<URI> namespaceDirs=FSNamesystem.getNamespaceDirs(conf);
      if (format) {
        for (        URI nameDirUri : namespaceDirs) {
          File nameDir=new File(nameDirUri);
          if (nameDir.exists() && !FileUtil.fullyDelete(nameDir)) {
            throw new IOException("Could not fully delete " + nameDir);
          }
        }
        Collection<URI> checkpointDirs=Util.stringCollectionAsURIs(conf.getTrimmedStringCollection(DFS_NAMENODE_CHECKPOINT_DIR_KEY));
        for (        URI checkpointDirUri : checkpointDirs) {
          File checkpointDir=new File(checkpointDirUri);
          if (checkpointDir.exists() && !FileUtil.fullyDelete(checkpointDir)) {
            throw new IOException("Could not fully delete " + checkpointDir);
          }
        }
      }
      boolean formatThisOne=format;
      if (format && i++ > 0) {
        formatThisOne=false;
        assert(null != prevNNDirs);
        copyNameDirs(prevNNDirs,namespaceDirs,conf);
      }
      nnCounterForFormat++;
      if (formatThisOne) {
        if (nn.getClusterId() == null) {
          StartupOption.FORMAT.setClusterId(clusterId);
        }
 else {
          StartupOption.FORMAT.setClusterId(nn.getClusterId());
        }
        DFSTestUtil.formatNameNode(conf);
      }
      prevNNDirs=namespaceDirs;
    }
    for (    NNConf nn : nameservice.getNNs()) {
      initNameNodeConf(conf,nsId,nn.getNnId(),manageNameDfsDirs,enableManagedDfsDirsRedundancy,nnCounter);
      createNameNode(nnCounter++,conf,numDataNodes,false,operation,clusterId,nsId,nn.getNnId());
    }
  }
}
