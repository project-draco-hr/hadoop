{
  if (createShortCircuitReplicaInfoCallback != null) {
    ShortCircuitReplicaInfo info=createShortCircuitReplicaInfoCallback.createShortCircuitReplicaInfo();
    if (info != null)     return info;
  }
  if (LOG.isTraceEnabled()) {
    LOG.trace(this + ": trying to create ShortCircuitReplicaInfo.");
  }
  BlockReaderPeer curPeer;
  while (true) {
    curPeer=nextDomainPeer();
    if (curPeer == null)     break;
    if (curPeer.fromCache)     remainingCacheTries--;
    DomainPeer peer=(DomainPeer)curPeer.peer;
    Slot slot=null;
    ShortCircuitCache cache=clientContext.getShortCircuitCache();
    try {
      MutableBoolean usedPeer=new MutableBoolean(false);
      slot=cache.allocShmSlot(datanode,peer,usedPeer,new ExtendedBlockId(block.getBlockId(),block.getBlockPoolId()),clientName);
      if (usedPeer.booleanValue()) {
        if (LOG.isTraceEnabled()) {
          LOG.trace(this + ": allocShmSlot used up our previous socket " + peer.getDomainSocket()+ ".  Allocating a new one...");
        }
        curPeer=nextDomainPeer();
        if (curPeer == null)         break;
        peer=(DomainPeer)curPeer.peer;
      }
      ShortCircuitReplicaInfo info=requestFileDescriptors(peer,slot);
      clientContext.getPeerCache().put(datanode,peer);
      return info;
    }
 catch (    IOException e) {
      if (slot != null) {
        cache.freeSlot(slot);
      }
      if (curPeer.fromCache) {
        if (LOG.isDebugEnabled()) {
          LOG.debug(this + ": closing stale domain peer " + peer,e);
        }
        IOUtils.cleanup(LOG,peer);
      }
 else {
        LOG.warn(this + ": I/O error requesting file descriptors.  " + "Disabling domain socket "+ peer.getDomainSocket(),e);
        IOUtils.cleanup(LOG,peer);
        clientContext.getDomainSocketFactory().disableDomainSocketPath(pathInfo.getPath());
        return null;
      }
    }
  }
  return null;
}
