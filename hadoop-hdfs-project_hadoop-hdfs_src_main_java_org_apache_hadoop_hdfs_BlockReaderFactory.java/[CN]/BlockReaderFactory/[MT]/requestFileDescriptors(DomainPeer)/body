{
  final DataOutputStream out=new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));
  new Sender(out).requestShortCircuitFds(block,token,1);
  DataInputStream in=new DataInputStream(peer.getInputStream());
  BlockOpResponseProto resp=BlockOpResponseProto.parseFrom(PBHelper.vintPrefixed(in));
  DomainSocket sock=peer.getDomainSocket();
switch (resp.getStatus()) {
case SUCCESS:
    byte buf[]=new byte[1];
  FileInputStream fis[]=new FileInputStream[2];
sock.recvFileInputStreams(fis,buf,0,buf.length);
ShortCircuitReplica replica=null;
try {
Key key=new Key(block.getBlockId(),block.getBlockPoolId());
replica=new ShortCircuitReplica(key,fis[0],fis[1],clientContext.getShortCircuitCache(),Time.monotonicNow());
}
 catch (IOException e) {
LOG.warn(this + ": error creating ShortCircuitReplica.",e);
return null;
}
 finally {
if (replica == null) {
IOUtils.cleanup(DFSClient.LOG,fis[0],fis[1]);
}
}
return new ShortCircuitReplicaInfo(replica);
case ERROR_UNSUPPORTED:
if (!resp.hasShortCircuitAccessVersion()) {
LOG.warn("short-circuit read access is disabled for " + "DataNode " + datanode + ".  reason: "+ resp.getMessage());
clientContext.getDomainSocketFactory().disableShortCircuitForPath(pathInfo.getPath());
}
 else {
LOG.warn("short-circuit read access for the file " + fileName + " is disabled for DataNode "+ datanode+ ".  reason: "+ resp.getMessage());
}
return null;
case ERROR_ACCESS_TOKEN:
String msg="access control error while " + "attempting to set up short-circuit access to " + fileName + resp.getMessage();
if (LOG.isDebugEnabled()) {
LOG.debug(this + ":" + msg);
}
return new ShortCircuitReplicaInfo(new InvalidToken(msg));
default :
LOG.warn(this + "unknown response code " + resp.getStatus()+ " while "+ "attempting to set up short-circuit access. "+ resp.getMessage());
clientContext.getDomainSocketFactory().disableShortCircuitForPath(pathInfo.getPath());
return null;
}
}
