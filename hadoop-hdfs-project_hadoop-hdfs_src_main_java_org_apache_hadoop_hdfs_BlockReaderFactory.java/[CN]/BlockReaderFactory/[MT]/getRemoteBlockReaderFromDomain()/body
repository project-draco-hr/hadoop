{
  if (pathInfo == null) {
    pathInfo=clientContext.getDomainSocketFactory().getPathInfo(inetSocketAddress,conf);
  }
  if (!pathInfo.getPathState().getUsableForDataTransfer()) {
    PerformanceAdvisory.LOG.debug(this + ": not trying to create a " + "remote block reader because the UNIX domain socket at "+ pathInfo+ " is not usable.");
    return null;
  }
  if (LOG.isTraceEnabled()) {
    LOG.trace(this + ": trying to create a remote block reader from the " + "UNIX domain socket at "+ pathInfo.getPath());
  }
  while (true) {
    BlockReaderPeer curPeer=nextDomainPeer();
    if (curPeer == null)     break;
    if (curPeer.fromCache)     remainingCacheTries--;
    DomainPeer peer=(DomainPeer)curPeer.peer;
    BlockReader blockReader=null;
    try {
      blockReader=getRemoteBlockReader(peer);
      return blockReader;
    }
 catch (    IOException ioe) {
      IOUtils.cleanup(LOG,peer);
      if (isSecurityException(ioe)) {
        if (LOG.isTraceEnabled()) {
          LOG.trace(this + ": got security exception while constructing " + "a remote block reader from the unix domain socket at "+ pathInfo.getPath(),ioe);
        }
        throw ioe;
      }
      if (curPeer.fromCache) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("Closed potentially stale domain peer " + peer,ioe);
        }
      }
 else {
        LOG.warn("I/O error constructing remote block reader.  Disabling " + "domain socket " + peer.getDomainSocket(),ioe);
        clientContext.getDomainSocketFactory().disableDomainSocketPath(pathInfo.getPath());
        return null;
      }
    }
 finally {
      if (blockReader == null) {
        IOUtils.cleanup(LOG,peer);
      }
    }
  }
  return null;
}
