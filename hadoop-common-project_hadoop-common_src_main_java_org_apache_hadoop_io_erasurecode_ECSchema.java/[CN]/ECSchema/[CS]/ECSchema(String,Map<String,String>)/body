{
  assert(schemaName != null && !schemaName.isEmpty());
  this.schemaName=schemaName;
  if (options == null || options.isEmpty()) {
    throw new IllegalArgumentException("No schema options are provided");
  }
  String codecName=options.get(CODEC_NAME_KEY);
  if (codecName == null || codecName.isEmpty()) {
    throw new IllegalArgumentException("No codec option is provided");
  }
  int dataUnits=0, parityUnits=0;
  try {
    if (options.containsKey(NUM_DATA_UNITS_KEY)) {
      dataUnits=Integer.parseInt(options.get(NUM_DATA_UNITS_KEY));
    }
  }
 catch (  NumberFormatException e) {
    throw new IllegalArgumentException("Option value " + options.get(CHUNK_SIZE_KEY) + " for "+ CHUNK_SIZE_KEY+ " is found. It should be an integer");
  }
  try {
    if (options.containsKey(NUM_PARITY_UNITS_KEY)) {
      parityUnits=Integer.parseInt(options.get(NUM_PARITY_UNITS_KEY));
    }
  }
 catch (  NumberFormatException e) {
    throw new IllegalArgumentException("Option value " + options.get(CHUNK_SIZE_KEY) + " for "+ CHUNK_SIZE_KEY+ " is found. It should be an integer");
  }
  initWith(codecName,dataUnits,parityUnits,options);
}
