{
  checkParameters(inputs,erasedIndexes,outputs);
  ByteBuffer validInput=findFirstValidInput(inputs);
  boolean usingDirectBuffer=validInput.isDirect();
  int dataLen=validInput.remaining();
  if (dataLen == 0) {
    return;
  }
  checkParameterBuffers(inputs,true,dataLen,usingDirectBuffer,false);
  checkParameterBuffers(outputs,false,dataLen,usingDirectBuffer,true);
  int[] inputPositions=new int[inputs.length];
  for (int i=0; i < inputPositions.length; i++) {
    if (inputs[i] != null) {
      inputPositions[i]=inputs[i].position();
    }
  }
  if (usingDirectBuffer) {
    doDecode(inputs,erasedIndexes,outputs);
  }
 else {
    int[] inputOffsets=new int[inputs.length];
    int[] outputOffsets=new int[outputs.length];
    byte[][] newInputs=new byte[inputs.length][];
    byte[][] newOutputs=new byte[outputs.length][];
    ByteBuffer buffer;
    for (int i=0; i < inputs.length; ++i) {
      buffer=inputs[i];
      if (buffer != null) {
        inputOffsets[i]=buffer.arrayOffset() + buffer.position();
        newInputs[i]=buffer.array();
      }
    }
    for (int i=0; i < outputs.length; ++i) {
      buffer=outputs[i];
      outputOffsets[i]=buffer.arrayOffset() + buffer.position();
      newOutputs[i]=buffer.array();
    }
    doDecode(newInputs,inputOffsets,dataLen,erasedIndexes,newOutputs,outputOffsets);
  }
  for (int i=0; i < inputs.length; i++) {
    if (inputs[i] != null) {
      inputs[i].position(inputPositions[i] + dataLen);
    }
  }
}
