{
  checkParameters(inputs,erasedIndexes,outputs);
  ByteBuffer validInput=findFirstValidInput(inputs);
  boolean usingDirectBuffer=validInput.isDirect();
  int dataLen=validInput.remaining();
  if (dataLen == 0) {
    return;
  }
  ensureLengthAndType(inputs,true,dataLen,usingDirectBuffer);
  ensureLengthAndType(outputs,false,dataLen,usingDirectBuffer);
  if (usingDirectBuffer) {
    doDecode(inputs,erasedIndexes,outputs);
    return;
  }
  int[] inputOffsets=new int[inputs.length];
  int[] outputOffsets=new int[outputs.length];
  byte[][] newInputs=new byte[inputs.length][];
  byte[][] newOutputs=new byte[outputs.length][];
  ByteBuffer buffer;
  for (int i=0; i < inputs.length; ++i) {
    buffer=inputs[i];
    if (buffer != null) {
      inputOffsets[i]=buffer.arrayOffset() + buffer.position();
      newInputs[i]=buffer.array();
    }
  }
  for (int i=0; i < outputs.length; ++i) {
    buffer=outputs[i];
    outputOffsets[i]=buffer.arrayOffset() + buffer.position();
    newOutputs[i]=buffer.array();
  }
  doDecode(newInputs,inputOffsets,dataLen,erasedIndexes,newOutputs,outputOffsets);
  for (int i=0; i < inputs.length; ++i) {
    buffer=inputs[i];
    if (buffer != null) {
      buffer.position(buffer.position() + dataLen);
    }
  }
}
