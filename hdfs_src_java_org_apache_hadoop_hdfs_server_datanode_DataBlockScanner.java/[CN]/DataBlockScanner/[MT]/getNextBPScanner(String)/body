{
  String nextBpId=null;
  while ((nextBpId == null) && datanode.shouldRun && !blockScannerThread.isInterrupted()) {
    waitForInit(currentBpId);
synchronized (this) {
      if (getBlockPoolSetSize() > 0) {
        long lastScanTime=-1;
        Iterator<String> bpidIterator=blockPoolScannerMap.keySet().iterator();
        while (bpidIterator.hasNext()) {
          String bpid=bpidIterator.next();
          for (          FSDataset.FSVolume vol : dataset.volumes.getVolumes()) {
            try {
              File currFile=BlockPoolSliceScanner.getCurrentFile(vol,bpid);
              if (currFile.exists()) {
                long lastModified=currFile.lastModified();
                if (lastScanTime < lastModified) {
                  lastScanTime=lastModified;
                  nextBpId=bpid;
                }
              }
            }
 catch (            IOException e) {
              LOG.warn("Received exception: ",e);
            }
          }
        }
        if (nextBpId == null) {
          if ("".equals(currentBpId)) {
            nextBpId=blockPoolScannerMap.firstKey();
          }
 else {
            nextBpId=blockPoolScannerMap.higherKey(currentBpId);
            if (nextBpId == null) {
              nextBpId=blockPoolScannerMap.firstKey();
            }
          }
        }
        if (nextBpId != null) {
          return getBPScanner(nextBpId);
        }
      }
    }
    LOG.warn("No block pool is up, going to wait");
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException ex) {
      LOG.warn("Received exception: " + ex);
      blockScannerThread.interrupt();
      return null;
    }
  }
  return null;
}
