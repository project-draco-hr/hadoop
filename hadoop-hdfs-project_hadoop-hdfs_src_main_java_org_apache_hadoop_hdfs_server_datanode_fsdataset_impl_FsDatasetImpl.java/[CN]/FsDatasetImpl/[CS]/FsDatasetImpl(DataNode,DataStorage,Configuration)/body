{
  this.fsRunning=true;
  this.datanode=datanode;
  this.dataStorage=storage;
  this.conf=conf;
  final int volFailuresTolerated=conf.getInt(DFSConfigKeys.DFS_DATANODE_FAILED_VOLUMES_TOLERATED_KEY,DFSConfigKeys.DFS_DATANODE_FAILED_VOLUMES_TOLERATED_DEFAULT);
  String[] dataDirs=conf.getTrimmedStrings(DFSConfigKeys.DFS_DATANODE_DATA_DIR_KEY);
  Collection<StorageLocation> dataLocations=DataNode.getStorageLocations(conf);
  int volsConfigured=(dataDirs == null) ? 0 : dataDirs.length;
  int volsFailed=volsConfigured - storage.getNumStorageDirs();
  this.validVolsRequired=volsConfigured - volFailuresTolerated;
  if (volFailuresTolerated < 0 || volFailuresTolerated >= volsConfigured) {
    throw new DiskErrorException("Invalid volume failure " + " config value: " + volFailuresTolerated);
  }
  if (volsFailed > volFailuresTolerated) {
    throw new DiskErrorException("Too many failed volumes - " + "current valid volumes: " + storage.getNumStorageDirs() + ", volumes configured: "+ volsConfigured+ ", volumes failed: "+ volsFailed+ ", volume failures tolerated: "+ volFailuresTolerated);
  }
  storageMap=new ConcurrentHashMap<String,DatanodeStorage>();
  volumeMap=new ReplicaMap(this);
  ramDiskReplicaTracker=RamDiskReplicaTracker.getInstance(conf,this);
  @SuppressWarnings("unchecked") final VolumeChoosingPolicy<FsVolumeImpl> blockChooserImpl=ReflectionUtils.newInstance(conf.getClass(DFSConfigKeys.DFS_DATANODE_FSDATASET_VOLUME_CHOOSING_POLICY_KEY,RoundRobinVolumeChoosingPolicy.class,VolumeChoosingPolicy.class),conf);
  volumes=new FsVolumeList(volsFailed,blockChooserImpl);
  asyncDiskService=new FsDatasetAsyncDiskService(datanode);
  for (int idx=0; idx < storage.getNumStorageDirs(); idx++) {
    addVolume(dataLocations,storage.getStorageDir(idx));
  }
  cacheManager=new FsDatasetCache(this);
  lazyWriter=new Daemon(new LazyWriter(conf));
  lazyWriter.start();
  registerMBean(datanode.getDatanodeUuid());
}
