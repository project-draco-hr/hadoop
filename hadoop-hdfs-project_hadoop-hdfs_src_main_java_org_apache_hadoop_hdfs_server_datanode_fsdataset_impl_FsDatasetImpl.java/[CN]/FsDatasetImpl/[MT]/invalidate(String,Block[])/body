{
  final List<String> errors=new ArrayList<String>();
  for (int i=0; i < invalidBlks.length; i++) {
    final File f;
    final FsVolumeImpl v;
synchronized (this) {
      final ReplicaInfo info=volumeMap.get(bpid,invalidBlks[i]);
      if (info == null) {
        LOG.info("Failed to delete replica " + invalidBlks[i] + ": ReplicaInfo not found.");
        continue;
      }
      if (info.getGenerationStamp() != invalidBlks[i].getGenerationStamp()) {
        errors.add("Failed to delete replica " + invalidBlks[i] + ": GenerationStamp not matched, info="+ info);
        continue;
      }
      f=info.getBlockFile();
      v=(FsVolumeImpl)info.getVolume();
      if (f == null) {
        errors.add("Failed to delete replica " + invalidBlks[i] + ": File not found, volume="+ v);
        continue;
      }
      if (v == null) {
        errors.add("Failed to delete replica " + invalidBlks[i] + ". No volume for this replica, file="+ f);
        continue;
      }
      File parent=f.getParentFile();
      if (parent == null) {
        errors.add("Failed to delete replica " + invalidBlks[i] + ". Parent not found for file "+ f);
        continue;
      }
      volumeMap.remove(bpid,invalidBlks[i]);
    }
    if (v.isTransientStorage()) {
      RamDiskReplica replicaInfo=ramDiskReplicaTracker.getReplica(bpid,invalidBlks[i].getBlockId());
      if (replicaInfo != null) {
        if (replicaInfo.getIsPersisted() == false) {
          datanode.getMetrics().incrRamDiskBlocksDeletedBeforeLazyPersisted();
        }
        discardRamDiskReplica(replicaInfo,true);
      }
    }
    datanode.getShortCircuitRegistry().processBlockInvalidation(new ExtendedBlockId(invalidBlks[i].getBlockId(),bpid));
    cacheManager.uncacheBlock(bpid,invalidBlks[i].getBlockId());
    asyncDiskService.deleteAsync(v,f,FsDatasetUtil.getMetaFile(f,invalidBlks[i].getGenerationStamp()),new ExtendedBlock(bpid,invalidBlks[i]),dataStorage.getTrashDirectoryForBlockFile(bpid,f));
  }
  if (!errors.isEmpty()) {
    StringBuilder b=new StringBuilder("Failed to delete ").append(errors.size()).append(" (out of ").append(invalidBlks.length).append(") replica(s):");
    for (int i=0; i < errors.size(); i++) {
      b.append("\n").append(i).append(") ").append(errors.get(i));
    }
    throw new IOException(b.toString());
  }
}
