{
  long startTimeMs=Time.monotonicNow();
  long writerStopTimeoutMs=datanode.getDnConf().getXceiverStopTimeout();
  ReplicaInfo lastFoundReplicaInfo=null;
  do {
    try (AutoCloseableLock lock=datasetLock.acquire()){
      ReplicaInfo currentReplicaInfo=volumeMap.get(b.getBlockPoolId(),b.getBlockId());
      if (currentReplicaInfo == lastFoundReplicaInfo) {
        if (lastFoundReplicaInfo != null) {
          invalidate(b.getBlockPoolId(),new Block[]{lastFoundReplicaInfo});
        }
        FsVolumeReference ref=volumes.getNextVolume(storageType,b.getNumBytes());
        FsVolumeImpl v=(FsVolumeImpl)ref.getVolume();
        ReplicaInPipeline newReplicaInfo;
        try {
          newReplicaInfo=v.createTemporary(b);
        }
 catch (        IOException e) {
          IOUtils.cleanup(null,ref);
          throw e;
        }
        volumeMap.add(b.getBlockPoolId(),newReplicaInfo.getReplicaInfo());
        return new ReplicaHandler(newReplicaInfo,ref);
      }
 else {
        if (!(currentReplicaInfo.getGenerationStamp() < b.getGenerationStamp() && (currentReplicaInfo.getState() == ReplicaState.TEMPORARY || currentReplicaInfo.getState() == ReplicaState.RBW))) {
          throw new ReplicaAlreadyExistsException("Block " + b + " already exists in state "+ currentReplicaInfo.getState()+ " and thus cannot be created.");
        }
        lastFoundReplicaInfo=currentReplicaInfo;
      }
    }
     long writerStopMs=Time.monotonicNow() - startTimeMs;
    if (writerStopMs > writerStopTimeoutMs) {
      LOG.warn("Unable to stop existing writer for block " + b + " after "+ writerStopMs+ " miniseconds.");
      throw new IOException("Unable to stop existing writer for block " + b + " after "+ writerStopMs+ " miniseconds.");
    }
    ((ReplicaInPipeline)lastFoundReplicaInfo).stopWriter(writerStopTimeoutMs);
  }
 while (true);
}
