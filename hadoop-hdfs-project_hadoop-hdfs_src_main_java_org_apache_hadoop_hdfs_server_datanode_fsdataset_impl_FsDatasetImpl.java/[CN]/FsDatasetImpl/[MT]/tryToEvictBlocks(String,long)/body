{
  boolean isAvailable=false;
  LOG.info("Attempting to evict blocks from transient storage");
  TreeMultimap<Long,LazyWriteReplicaTracker.ReplicaState> lruMap=lazyWriteReplicaTracker.getLruMap();
  int blocksEvicted=0;
synchronized (this) {
    long currentTime=System.currentTimeMillis() / 1000;
    for (    Map.Entry<Long,LazyWriteReplicaTracker.ReplicaState> entry : lruMap.entries()) {
      LazyWriteReplicaTracker.ReplicaState lazyWriteReplica=entry.getValue();
      LOG.info("RAM_DISK: Evicting blockId=" + lazyWriteReplica.blockId + "; block LMT="+ entry.getKey()+ "; currentTime="+ currentTime);
      ReplicaInfo replicaInfo=getReplicaInfo(bpid,lazyWriteReplica.blockId);
      Preconditions.checkState(replicaInfo.getVolume().isTransientStorage());
      File blockFile=replicaInfo.getBlockFile();
      File metaFile=replicaInfo.getMetaFile();
      long used=blockFile.length() + metaFile.length();
      lazyWriteReplicaTracker.discardReplica(bpid,entry.getValue().blockId,false);
      BlockPoolSlice bpSlice=lazyWriteReplica.lazyPersistVolume.getBlockPoolSlice(bpid);
      File newBlockFile=bpSlice.activateSavedReplica(replicaInfo,lazyWriteReplica.savedBlockFile);
      ReplicaInfo newReplicaInfo=new FinalizedReplica(replicaInfo.getBlockId(),replicaInfo.getBytesOnDisk(),replicaInfo.getGenerationStamp(),lazyWriteReplica.lazyPersistVolume,newBlockFile.getParentFile());
      volumeMap.add(bpid,newReplicaInfo);
      blockFile.delete();
      metaFile.delete();
      ((FsVolumeImpl)replicaInfo.getVolume()).decDfsUsed(bpid,used);
      ++blocksEvicted;
      if (replicaInfo.getVolume().getAvailable() > spaceNeeded) {
        LOG.info("RAM_DISK: freed up " + spaceNeeded + " bytes for new block");
        isAvailable=true;
        break;
      }
      if (blocksEvicted == MAX_BLOCK_EVICTIONS_PER_ITERATION) {
        break;
      }
    }
  }
  return isAvailable;
}
