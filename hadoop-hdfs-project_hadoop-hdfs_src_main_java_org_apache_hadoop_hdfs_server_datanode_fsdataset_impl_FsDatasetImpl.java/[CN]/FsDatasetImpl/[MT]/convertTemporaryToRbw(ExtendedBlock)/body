{
  try (AutoCloseableLock lock=datasetLock.acquire()){
    final long blockId=b.getBlockId();
    final long expectedGs=b.getGenerationStamp();
    final long visible=b.getNumBytes();
    LOG.info("Convert " + b + " from Temporary to RBW, visible length="+ visible);
    final ReplicaInfo temp;
{
      final ReplicaInfo r=volumeMap.get(b.getBlockPoolId(),blockId);
      if (r == null) {
        throw new ReplicaNotFoundException(ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);
      }
      if (r.getState() != ReplicaState.TEMPORARY) {
        throw new ReplicaAlreadyExistsException("r.getState() != ReplicaState.TEMPORARY, r=" + r);
      }
      temp=r;
    }
    if (temp.getGenerationStamp() != expectedGs) {
      throw new ReplicaAlreadyExistsException("temp.getGenerationStamp() != expectedGs = " + expectedGs + ", temp="+ temp);
    }
    final long numBytes=temp.getNumBytes();
    if (numBytes < visible) {
      throw new IOException(numBytes + " = numBytes < visible = " + visible+ ", temp="+ temp);
    }
    final FsVolumeImpl v=(FsVolumeImpl)temp.getVolume();
    if (v == null) {
      throw new IOException("r.getVolume() = null, temp=" + temp);
    }
    final ReplicaInPipeline rbw=v.convertTemporaryToRbw(b,temp);
    if (rbw.getState() != ReplicaState.RBW) {
      throw new IOException("Expected replica state: " + ReplicaState.RBW + " obtained "+ rbw.getState()+ " for converting block "+ b.getBlockId());
    }
    volumeMap.add(b.getBlockPoolId(),rbw.getReplicaInfo());
    return rbw;
  }
 }
