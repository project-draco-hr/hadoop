{
  int iterations=0;
  final long cacheCapacity=cacheManager.getCacheCapacity();
  while (iterations++ < MAX_BLOCK_EVICTIONS_PER_ITERATION && (cacheCapacity - cacheManager.getCacheUsed()) < bytesNeeded) {
    RamDiskReplica replicaState=ramDiskReplicaTracker.getNextCandidateForEviction();
    if (replicaState == null) {
      break;
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("Evicting block " + replicaState);
    }
    ReplicaInfo replicaInfo, newReplicaInfo;
    final String bpid=replicaState.getBlockPoolId();
    try (AutoCloseableLock lock=datasetLock.acquire()){
      replicaInfo=getReplicaInfo(replicaState.getBlockPoolId(),replicaState.getBlockId());
      Preconditions.checkState(replicaInfo.getVolume().isTransientStorage());
      ramDiskReplicaTracker.discardReplica(replicaState.getBlockPoolId(),replicaState.getBlockId(),false);
      BlockPoolSlice bpSlice=replicaState.getLazyPersistVolume().getBlockPoolSlice(bpid);
      newReplicaInfo=bpSlice.activateSavedReplica(replicaInfo,replicaState);
      volumeMap.add(bpid,newReplicaInfo);
      datanode.getMetrics().incrRamDiskBlocksEvicted();
      datanode.getMetrics().addRamDiskBlocksEvictionWindowMs(Time.monotonicNow() - replicaState.getCreationTime());
      if (replicaState.getNumReads() == 0) {
        datanode.getMetrics().incrRamDiskBlocksEvictedWithoutRead();
      }
      removeOldReplica(replicaInfo,newReplicaInfo,bpid);
    }
   }
}
