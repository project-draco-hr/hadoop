{
  int iterations=0;
  while (iterations++ < MAX_BLOCK_EVICTIONS_PER_ITERATION && transientFreeSpaceBelowThreshold()) {
    RamDiskReplica replicaState=ramDiskReplicaTracker.getNextCandidateForEviction();
    if (replicaState == null) {
      break;
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("Evicting block " + replicaState);
    }
    ReplicaInfo replicaInfo, newReplicaInfo;
    File blockFile, metaFile;
    long blockFileUsed, metaFileUsed;
    final String bpid=replicaState.getBlockPoolId();
synchronized (FsDatasetImpl.this) {
      replicaInfo=getReplicaInfo(replicaState.getBlockPoolId(),replicaState.getBlockId());
      Preconditions.checkState(replicaInfo.getVolume().isTransientStorage());
      blockFile=replicaInfo.getBlockFile();
      metaFile=replicaInfo.getMetaFile();
      blockFileUsed=blockFile.length();
      metaFileUsed=metaFile.length();
      ramDiskReplicaTracker.discardReplica(replicaState.getBlockPoolId(),replicaState.getBlockId(),false);
      BlockPoolSlice bpSlice=replicaState.getLazyPersistVolume().getBlockPoolSlice(bpid);
      File newBlockFile=bpSlice.activateSavedReplica(replicaInfo,replicaState.getSavedMetaFile(),replicaState.getSavedBlockFile());
      newReplicaInfo=new FinalizedReplica(replicaInfo.getBlockId(),replicaInfo.getBytesOnDisk(),replicaInfo.getGenerationStamp(),replicaState.getLazyPersistVolume(),newBlockFile.getParentFile());
      volumeMap.add(bpid,newReplicaInfo);
      datanode.getMetrics().incrRamDiskBlocksEvicted();
      datanode.getMetrics().addRamDiskBlocksEvictionWindowMs(Time.monotonicNow() - replicaState.getCreationTime());
      if (replicaState.getNumReads() == 0) {
        datanode.getMetrics().incrRamDiskBlocksEvictedWithoutRead();
      }
    }
    removeOldReplica(replicaInfo,newReplicaInfo,blockFile,metaFile,blockFileUsed,metaFileUsed,bpid);
  }
}
