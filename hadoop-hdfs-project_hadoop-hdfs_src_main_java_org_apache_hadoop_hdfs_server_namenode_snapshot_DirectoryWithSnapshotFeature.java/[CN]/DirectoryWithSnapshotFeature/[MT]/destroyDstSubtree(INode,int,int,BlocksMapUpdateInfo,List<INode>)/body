{
  Preconditions.checkArgument(prior != Snapshot.NO_SNAPSHOT_ID);
  if (inode.isReference()) {
    if (inode instanceof INodeReference.WithName && snapshot != Snapshot.CURRENT_STATE_ID) {
      inode.cleanSubtree(snapshot,prior,collectedBlocks,removedINodes,true);
    }
 else {
      destroyDstSubtree(inode.asReference().getReferredINode(),snapshot,prior,collectedBlocks,removedINodes);
    }
  }
 else   if (inode.isFile()) {
    inode.cleanSubtree(snapshot,prior,collectedBlocks,removedINodes,true);
  }
 else   if (inode.isDirectory()) {
    Map<INode,INode> excludedNodes=null;
    INodeDirectory dir=inode.asDirectory();
    DirectoryWithSnapshotFeature sf=dir.getDirectoryWithSnapshotFeature();
    if (sf != null) {
      DirectoryDiffList diffList=sf.getDiffs();
      DirectoryDiff priorDiff=diffList.getDiffById(prior);
      if (priorDiff != null && priorDiff.getSnapshotId() == prior) {
        List<INode> dList=priorDiff.diff.getList(ListType.DELETED);
        excludedNodes=cloneDiffList(dList);
      }
      if (snapshot != Snapshot.CURRENT_STATE_ID) {
        diffList.deleteSnapshotDiff(snapshot,prior,dir,collectedBlocks,removedINodes,true);
      }
      priorDiff=diffList.getDiffById(prior);
      if (priorDiff != null && priorDiff.getSnapshotId() == prior) {
        priorDiff.diff.destroyCreatedList(dir,collectedBlocks,removedINodes);
      }
    }
    for (    INode child : inode.asDirectory().getChildrenList(prior)) {
      if (excludedNodes != null && excludedNodes.containsKey(child)) {
        continue;
      }
      destroyDstSubtree(child,snapshot,prior,collectedBlocks,removedINodes);
    }
  }
}
