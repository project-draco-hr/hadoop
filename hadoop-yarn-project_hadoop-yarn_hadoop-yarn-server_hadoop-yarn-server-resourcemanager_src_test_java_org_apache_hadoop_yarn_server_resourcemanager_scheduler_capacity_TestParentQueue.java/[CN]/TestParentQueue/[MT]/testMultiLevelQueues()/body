{
  setupMultiLevelQueues(csConf);
  Map<String,CSQueue> queues=new HashMap<String,CSQueue>();
  CSQueue root=CapacityScheduler.parseQueue(csContext,csConf,null,CapacitySchedulerConfiguration.ROOT,queues,queues,TestUtils.spyHook);
  final int memoryPerNode=10;
  final int coresPerNode=16;
  final int numNodes=3;
  FiCaSchedulerNode node_0=TestUtils.getMockNode("host_0",DEFAULT_RACK,0,memoryPerNode * GB);
  FiCaSchedulerNode node_1=TestUtils.getMockNode("host_1",DEFAULT_RACK,0,memoryPerNode * GB);
  FiCaSchedulerNode node_2=TestUtils.getMockNode("host_2",DEFAULT_RACK,0,memoryPerNode * GB);
  final Resource clusterResource=Resources.createResource(numNodes * (memoryPerNode * GB),numNodes * coresPerNode);
  when(csContext.getNumClusterNodes()).thenReturn(numNodes);
  CSQueue a=queues.get(A);
  CSQueue b=queues.get(B);
  CSQueue c=queues.get(C);
  CSQueue d=queues.get(D);
  CSQueue a1=queues.get(A1);
  CSQueue a2=queues.get(A2);
  CSQueue b1=queues.get(B1);
  CSQueue b2=queues.get(B2);
  CSQueue b3=queues.get(B3);
  stubQueueAllocation(a,clusterResource,node_0,0 * GB);
  stubQueueAllocation(b,clusterResource,node_0,0 * GB);
  stubQueueAllocation(c,clusterResource,node_0,1 * GB);
  stubQueueAllocation(d,clusterResource,node_0,0 * GB);
  root.assignContainers(clusterResource,node_0,false);
  verifyQueueMetrics(a,0 * GB,clusterResource);
  verifyQueueMetrics(b,0 * GB,clusterResource);
  verifyQueueMetrics(c,1 * GB,clusterResource);
  verifyQueueMetrics(d,0 * GB,clusterResource);
  reset(a);
  reset(b);
  reset(c);
  stubQueueAllocation(a,clusterResource,node_1,0 * GB);
  stubQueueAllocation(b2,clusterResource,node_1,4 * GB);
  stubQueueAllocation(c,clusterResource,node_1,0 * GB);
  root.assignContainers(clusterResource,node_1,false);
  verifyQueueMetrics(a,0 * GB,clusterResource);
  verifyQueueMetrics(b,4 * GB,clusterResource);
  verifyQueueMetrics(c,1 * GB,clusterResource);
  reset(a);
  reset(b);
  reset(c);
  stubQueueAllocation(a1,clusterResource,node_0,1 * GB);
  stubQueueAllocation(b3,clusterResource,node_0,2 * GB);
  stubQueueAllocation(c,clusterResource,node_0,2 * GB);
  root.assignContainers(clusterResource,node_0,false);
  InOrder allocationOrder=inOrder(a,c,b);
  allocationOrder.verify(a).assignContainers(eq(clusterResource),any(FiCaSchedulerNode.class),anyBoolean());
  allocationOrder.verify(c).assignContainers(eq(clusterResource),any(FiCaSchedulerNode.class),anyBoolean());
  allocationOrder.verify(b).assignContainers(eq(clusterResource),any(FiCaSchedulerNode.class),anyBoolean());
  verifyQueueMetrics(a,1 * GB,clusterResource);
  verifyQueueMetrics(b,6 * GB,clusterResource);
  verifyQueueMetrics(c,3 * GB,clusterResource);
  reset(a);
  reset(b);
  reset(c);
  LOG.info("here");
  ((ParentQueue)a).setMaxCapacity(.1f);
  stubQueueAllocation(a1,clusterResource,node_2,1 * GB);
  stubQueueAllocation(a2,clusterResource,node_2,2 * GB);
  stubQueueAllocation(b3,clusterResource,node_2,1 * GB);
  stubQueueAllocation(b1,clusterResource,node_2,1 * GB);
  stubQueueAllocation(c,clusterResource,node_2,1 * GB);
  root.assignContainers(clusterResource,node_2,false);
  allocationOrder=inOrder(a,a2,a1,b,c);
  allocationOrder.verify(a).assignContainers(eq(clusterResource),any(FiCaSchedulerNode.class),anyBoolean());
  allocationOrder.verify(a2).assignContainers(eq(clusterResource),any(FiCaSchedulerNode.class),anyBoolean());
  allocationOrder.verify(b).assignContainers(eq(clusterResource),any(FiCaSchedulerNode.class),anyBoolean());
  allocationOrder.verify(c).assignContainers(eq(clusterResource),any(FiCaSchedulerNode.class),anyBoolean());
  verifyQueueMetrics(a,3 * GB,clusterResource);
  verifyQueueMetrics(b,8 * GB,clusterResource);
  verifyQueueMetrics(c,4 * GB,clusterResource);
  reset(a);
  reset(b);
  reset(c);
}
