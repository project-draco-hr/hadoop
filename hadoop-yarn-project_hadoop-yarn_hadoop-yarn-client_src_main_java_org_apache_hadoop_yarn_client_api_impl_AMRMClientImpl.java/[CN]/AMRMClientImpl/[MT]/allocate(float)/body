{
  Preconditions.checkArgument(progressIndicator >= 0,"Progress indicator should not be negative");
  AllocateResponse allocateResponse=null;
  List<ResourceRequest> askList=null;
  List<ContainerId> releaseList=null;
  AllocateRequest allocateRequest=null;
  List<String> blacklistToAdd=new ArrayList<String>();
  List<String> blacklistToRemove=new ArrayList<String>();
  try {
synchronized (this) {
      askList=new ArrayList<ResourceRequest>(ask.size());
      for (      ResourceRequest r : ask) {
        askList.add(ResourceRequest.newInstance(r.getPriority(),r.getResourceName(),r.getCapability(),r.getNumContainers(),r.getRelaxLocality()));
      }
      releaseList=new ArrayList<ContainerId>(release);
      ask.clear();
      release.clear();
      blacklistToAdd.addAll(blacklistAdditions);
      blacklistToRemove.addAll(blacklistRemovals);
      ResourceBlacklistRequest blacklistRequest=(blacklistToAdd != null) || (blacklistToRemove != null) ? ResourceBlacklistRequest.newInstance(blacklistToAdd,blacklistToRemove) : null;
      allocateRequest=AllocateRequest.newInstance(lastResponseId,progressIndicator,askList,releaseList,blacklistRequest);
      blacklistAdditions.clear();
      blacklistRemovals.clear();
    }
    allocateResponse=rmClient.allocate(allocateRequest);
    if (isResyncCommand(allocateResponse)) {
      LOG.warn("ApplicationMaster is out of sync with ResourceManager," + " hence resyncing.");
synchronized (this) {
        release.addAll(this.pendingRelease);
        blacklistAdditions.addAll(this.blacklistedNodes);
        for (        Map<String,TreeMap<Resource,ResourceRequestInfo>> rr : remoteRequestsTable.values()) {
          for (          Map<Resource,ResourceRequestInfo> capabalities : rr.values()) {
            for (            ResourceRequestInfo request : capabalities.values()) {
              addResourceRequestToAsk(request.remoteRequest);
            }
          }
        }
      }
      registerApplicationMaster();
      return allocate(progressIndicator);
    }
synchronized (this) {
      clusterNodeCount=allocateResponse.getNumClusterNodes();
      lastResponseId=allocateResponse.getResponseId();
      clusterAvailableResources=allocateResponse.getAvailableResources();
      if (!allocateResponse.getNMTokens().isEmpty()) {
        populateNMTokens(allocateResponse.getNMTokens());
      }
      if (allocateResponse.getAMRMToken() != null) {
        updateAMRMToken(allocateResponse.getAMRMToken());
      }
      if (!pendingRelease.isEmpty() && !allocateResponse.getCompletedContainersStatuses().isEmpty()) {
        removePendingReleaseRequests(allocateResponse.getCompletedContainersStatuses());
      }
    }
  }
  finally {
    if (allocateResponse == null) {
synchronized (this) {
        release.addAll(releaseList);
        for (        ResourceRequest oldAsk : askList) {
          if (!ask.contains(oldAsk)) {
            ask.add(oldAsk);
          }
        }
        blacklistAdditions.addAll(blacklistToAdd);
        blacklistRemovals.addAll(blacklistToRemove);
      }
    }
  }
  return allocateResponse;
}
