{
  Preconditions.checkArgument(progressIndicator >= 0,"Progress indicator should not be negative");
  AllocateResponse allocateResponse=null;
  List<ResourceRequest> askList=null;
  List<ContainerId> releaseList=null;
  AllocateRequest allocateRequest=null;
  List<String> blacklistToAdd=new ArrayList<String>();
  List<String> blacklistToRemove=new ArrayList<String>();
  Map<ContainerId,SimpleEntry<Container,Resource>> oldChange=new HashMap<>();
  try {
synchronized (this) {
      askList=cloneAsks();
      oldChange.putAll(change);
      List<UpdateContainerRequest> updateList=createUpdateList();
      releaseList=new ArrayList<ContainerId>(release);
      ask.clear();
      release.clear();
      change.clear();
      blacklistToAdd.addAll(blacklistAdditions);
      blacklistToRemove.addAll(blacklistRemovals);
      ResourceBlacklistRequest blacklistRequest=ResourceBlacklistRequest.newInstance(blacklistToAdd,blacklistToRemove);
      allocateRequest=AllocateRequest.newInstance(lastResponseId,progressIndicator,askList,releaseList,blacklistRequest,updateList);
      blacklistAdditions.clear();
      blacklistRemovals.clear();
    }
    try {
      allocateResponse=rmClient.allocate(allocateRequest);
    }
 catch (    ApplicationMasterNotRegisteredException e) {
      LOG.warn("ApplicationMaster is out of sync with ResourceManager," + " hence resyncing.");
synchronized (this) {
        release.addAll(this.pendingRelease);
        blacklistAdditions.addAll(this.blacklistedNodes);
        for (        RemoteRequestsTable remoteRequestsTable : remoteRequests.values()) {
          @SuppressWarnings("unchecked") Iterator<ResourceRequestInfo<T>> reqIter=remoteRequestsTable.iterator();
          while (reqIter.hasNext()) {
            addResourceRequestToAsk(reqIter.next().remoteRequest);
          }
        }
        change.putAll(this.pendingChange);
      }
      registerApplicationMaster();
      allocateResponse=allocate(progressIndicator);
      return allocateResponse;
    }
synchronized (this) {
      clusterNodeCount=allocateResponse.getNumClusterNodes();
      lastResponseId=allocateResponse.getResponseId();
      clusterAvailableResources=allocateResponse.getAvailableResources();
      if (!allocateResponse.getNMTokens().isEmpty()) {
        populateNMTokens(allocateResponse.getNMTokens());
      }
      if (allocateResponse.getAMRMToken() != null) {
        updateAMRMToken(allocateResponse.getAMRMToken());
      }
      if (!pendingRelease.isEmpty() && !allocateResponse.getCompletedContainersStatuses().isEmpty()) {
        removePendingReleaseRequests(allocateResponse.getCompletedContainersStatuses());
      }
      if (!pendingChange.isEmpty()) {
        List<ContainerStatus> completed=allocateResponse.getCompletedContainersStatuses();
        List<UpdatedContainer> changed=new ArrayList<>();
        changed.addAll(allocateResponse.getUpdatedContainers());
        for (        ContainerStatus status : completed) {
          ContainerId containerId=status.getContainerId();
          pendingChange.remove(containerId);
        }
        if (!changed.isEmpty()) {
          removePendingChangeRequests(changed);
        }
      }
    }
  }
  finally {
    if (allocateResponse == null) {
synchronized (this) {
        release.addAll(releaseList);
        for (        ResourceRequest oldAsk : askList) {
          if (!ask.contains(oldAsk)) {
            ask.add(oldAsk);
          }
        }
        for (        Map.Entry<ContainerId,SimpleEntry<Container,Resource>> entry : oldChange.entrySet()) {
          ContainerId oldContainerId=entry.getKey();
          Container oldContainer=entry.getValue().getKey();
          Resource oldResource=entry.getValue().getValue();
          if (change.get(oldContainerId) == null) {
            change.put(oldContainerId,new SimpleEntry<>(oldContainer,oldResource));
          }
        }
        blacklistAdditions.addAll(blacklistToAdd);
        blacklistRemovals.addAll(blacklistToRemove);
      }
    }
  }
  return allocateResponse;
}
