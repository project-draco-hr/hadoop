{
  Configuration conf=new HdfsConfiguration();
  final int DFS_BLOCK_SIZE=1024;
  final int NUM_DATANODES=4;
  conf.setLong(DFSConfigKeys.DFS_BLOCK_SIZE_KEY,DFS_BLOCK_SIZE);
  conf.setLong(DFSConfigKeys.DFS_BLOCKREPORT_INTERVAL_MSEC_KEY,10000L);
  conf.setInt(DFSConfigKeys.DFS_DATANODE_DIRECTORYSCAN_INTERVAL_KEY,1);
  DFSTestUtil util=new DFSTestUtil("TestFsck",5,3,(5 * DFS_BLOCK_SIZE) + (DFS_BLOCK_SIZE - 1),5 * DFS_BLOCK_SIZE);
  MiniDFSCluster cluster=null;
  FileSystem fs=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_DATANODES).build();
    String topDir="/srcdat";
    fs=cluster.getFileSystem();
    cluster.waitActive();
    util.createFiles(fs,topDir);
    util.waitReplication(fs,topDir,(short)3);
    String outStr=runFsck(conf,0,true,"/");
    assertTrue(outStr.contains(NamenodeFsck.HEALTHY_STATUS));
    DFSClient dfsClient=new DFSClient(new InetSocketAddress("localhost",cluster.getNameNodePort()),conf);
    String fileNames[]=util.getFileNames(topDir);
    CorruptedTestFile ctFiles[]=new CorruptedTestFile[]{new CorruptedTestFile(fileNames[0],Sets.newHashSet(0),dfsClient,NUM_DATANODES,DFS_BLOCK_SIZE),new CorruptedTestFile(fileNames[1],Sets.newHashSet(2,3),dfsClient,NUM_DATANODES,DFS_BLOCK_SIZE),new CorruptedTestFile(fileNames[2],Sets.newHashSet(4),dfsClient,NUM_DATANODES,DFS_BLOCK_SIZE),new CorruptedTestFile(fileNames[3],Sets.newHashSet(0,1,2,3),dfsClient,NUM_DATANODES,DFS_BLOCK_SIZE),new CorruptedTestFile(fileNames[4],Sets.newHashSet(1,2,3,4),dfsClient,NUM_DATANODES,DFS_BLOCK_SIZE)};
    int totalMissingBlocks=0;
    for (    CorruptedTestFile ctFile : ctFiles) {
      totalMissingBlocks+=ctFile.getTotalMissingBlocks();
    }
    for (    CorruptedTestFile ctFile : ctFiles) {
      ctFile.removeBlocks(cluster);
    }
    while (true) {
      outStr=runFsck(conf,1,false,"/");
      String numMissing=null;
      String numCorrupt=null;
      for (      String line : outStr.split(LINE_SEPARATOR)) {
        Matcher m=numMissingBlocksPattern.matcher(line);
        if (m.matches()) {
          numMissing=m.group(1);
        }
        m=numCorruptBlocksPattern.matcher(line);
        if (m.matches()) {
          numCorrupt=m.group(1);
        }
        if (numMissing != null && numCorrupt != null) {
          break;
        }
      }
      if (numMissing == null || numCorrupt == null) {
        throw new IOException("failed to find number of missing or corrupt" + " blocks in fsck output.");
      }
      if (numMissing.equals(Integer.toString(totalMissingBlocks))) {
        assertTrue(numCorrupt.equals(Integer.toString(0)));
        assertTrue(outStr.contains(NamenodeFsck.CORRUPT_STATUS));
        break;
      }
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException ignore) {
      }
    }
    outStr=runFsck(conf,1,false,"/","-move");
    FSImage.LOG.info("WATERMELON: outStr = " + outStr);
    assertTrue(outStr.contains(NamenodeFsck.CORRUPT_STATUS));
    for (    CorruptedTestFile ctFile : ctFiles) {
      ctFile.checkSalvagedRemains();
    }
    outStr=runFsck(conf,1,true,"/","-delete");
    assertTrue(outStr.contains(NamenodeFsck.CORRUPT_STATUS));
    outStr=runFsck(conf,0,true,"/");
    assertTrue(outStr.contains(NamenodeFsck.HEALTHY_STATUS));
    util.cleanup(fs,topDir);
  }
  finally {
    if (fs != null) {
      try {
        fs.close();
      }
 catch (      Exception e) {
      }
    }
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}
