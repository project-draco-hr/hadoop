{
switch (resource.getType()) {
case ARCHIVE:
{
      String lowerDst=StringUtils.toLowerCase(dst.getName());
      if (lowerDst.endsWith(".jar")) {
        RunJar.unJar(localrsrc,dst);
      }
 else       if (lowerDst.endsWith(".zip")) {
        FileUtil.unZip(localrsrc,dst);
      }
 else       if (lowerDst.endsWith(".tar.gz") || lowerDst.endsWith(".tgz") || lowerDst.endsWith(".tar")) {
        FileUtil.unTar(localrsrc,dst);
      }
 else {
        LOG.warn("Cannot unpack " + localrsrc);
        if (!localrsrc.renameTo(dst)) {
          throw new IOException("Unable to rename file: [" + localrsrc + "] to ["+ dst+ "]");
        }
      }
    }
  break;
case PATTERN:
{
  String lowerDst=StringUtils.toLowerCase(dst.getName());
  if (lowerDst.endsWith(".jar")) {
    String p=resource.getPattern();
    RunJar.unJar(localrsrc,dst,p == null ? RunJar.MATCH_ANY : Pattern.compile(p));
    File newDst=new File(dst,dst.getName());
    if (!dst.exists() && !dst.mkdir()) {
      throw new IOException("Unable to create directory: [" + dst + "]");
    }
    if (!localrsrc.renameTo(newDst)) {
      throw new IOException("Unable to rename file: [" + localrsrc + "] to ["+ newDst+ "]");
    }
  }
 else   if (lowerDst.endsWith(".zip")) {
    LOG.warn("Treating [" + localrsrc + "] as an archive even though it "+ "was specified as PATTERN");
    FileUtil.unZip(localrsrc,dst);
  }
 else   if (lowerDst.endsWith(".tar.gz") || lowerDst.endsWith(".tgz") || lowerDst.endsWith(".tar")) {
    LOG.warn("Treating [" + localrsrc + "] as an archive even though it "+ "was specified as PATTERN");
    FileUtil.unTar(localrsrc,dst);
  }
 else {
    LOG.warn("Cannot unpack " + localrsrc);
    if (!localrsrc.renameTo(dst)) {
      throw new IOException("Unable to rename file: [" + localrsrc + "] to ["+ dst+ "]");
    }
  }
}
break;
case FILE:
default :
if (!localrsrc.renameTo(dst)) {
throw new IOException("Unable to rename file: [" + localrsrc + "] to ["+ dst+ "]");
}
break;
}
if (localrsrc.isFile()) {
try {
files.delete(new Path(localrsrc.toString()),false);
}
 catch (IOException ignore) {
}
}
return 0;
}
