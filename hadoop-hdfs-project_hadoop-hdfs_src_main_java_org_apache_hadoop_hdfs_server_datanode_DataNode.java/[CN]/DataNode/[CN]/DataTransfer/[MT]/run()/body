{
  xmitsInProgress.getAndIncrement();
  Socket sock=null;
  DataOutputStream out=null;
  DataInputStream in=null;
  BlockSender blockSender=null;
  final boolean isClient=clientname.length() > 0;
  try {
    final String dnAddr=targets[0].getXferAddr(connectToDnViaHostname);
    InetSocketAddress curTarget=NetUtils.createSocketAddr(dnAddr);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Connecting to datanode " + dnAddr);
    }
    sock=newSocket();
    NetUtils.connect(sock,curTarget,dnConf.socketTimeout);
    sock.setSoTimeout(targets.length * dnConf.socketTimeout);
    long writeTimeout=dnConf.socketWriteTimeout + HdfsServerConstants.WRITE_TIMEOUT_EXTENSION * (targets.length - 1);
    OutputStream unbufOut=NetUtils.getOutputStream(sock,writeTimeout);
    InputStream unbufIn=NetUtils.getInputStream(sock);
    if (dnConf.encryptDataTransfer) {
      IOStreamPair encryptedStreams=DataTransferEncryptor.getEncryptedStreams(unbufOut,unbufIn,blockPoolTokenSecretManager.generateDataEncryptionKey(b.getBlockPoolId()));
      unbufOut=encryptedStreams.out;
      unbufIn=encryptedStreams.in;
    }
    out=new DataOutputStream(new BufferedOutputStream(unbufOut,HdfsConstants.SMALL_BUFFER_SIZE));
    in=new DataInputStream(unbufIn);
    blockSender=new BlockSender(b,0,b.getNumBytes(),false,false,true,DataNode.this,null);
    DatanodeInfo srcNode=new DatanodeInfo(bpReg);
    Token<BlockTokenIdentifier> accessToken=BlockTokenSecretManager.DUMMY_TOKEN;
    if (isBlockTokenEnabled) {
      accessToken=blockPoolTokenSecretManager.generateToken(b,EnumSet.of(BlockTokenSecretManager.AccessMode.WRITE));
    }
    new Sender(out).writeBlock(b,accessToken,clientname,targets,srcNode,stage,0,0,0,0,blockSender.getChecksum());
    blockSender.sendBlock(out,unbufOut,null);
    LOG.info(getClass().getSimpleName() + ": Transmitted " + b+ " (numBytes="+ b.getNumBytes()+ ") to "+ curTarget);
    if (isClient) {
      DNTransferAckProto closeAck=DNTransferAckProto.parseFrom(PBHelper.vintPrefixed(in));
      if (LOG.isDebugEnabled()) {
        LOG.debug(getClass().getSimpleName() + ": close-ack=" + closeAck);
      }
      if (closeAck.getStatus() != Status.SUCCESS) {
        if (closeAck.getStatus() == Status.ERROR_ACCESS_TOKEN) {
          throw new InvalidBlockTokenException("Got access token error for connect ack, targets=" + Arrays.asList(targets));
        }
 else {
          throw new IOException("Bad connect ack, targets=" + Arrays.asList(targets));
        }
      }
    }
  }
 catch (  IOException ie) {
    LOG.warn(bpReg + ":Failed to transfer " + b+ " to "+ targets[0]+ " got ",ie);
    try {
      checkDiskError(ie);
    }
 catch (    IOException e) {
      LOG.warn("DataNode.checkDiskError failed in run() with: ",e);
    }
  }
 finally {
    xmitsInProgress.getAndDecrement();
    IOUtils.closeStream(blockSender);
    IOUtils.closeStream(out);
    IOUtils.closeStream(in);
    IOUtils.closeSocket(sock);
  }
}
