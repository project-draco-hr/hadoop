{
  xmitsInProgress.getAndIncrement();
  Socket sock=null;
  DataOutputStream out=null;
  DataInputStream in=null;
  BlockSender blockSender=null;
  final boolean isClient=clientname.length() > 0;
  try {
    final String dnAddr=targets[0].getXferAddr(connectToDnViaHostname);
    InetSocketAddress curTarget=NetUtils.createSocketAddr(dnAddr);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Connecting to datanode " + dnAddr);
    }
    sock=newSocket();
    NetUtils.connect(sock,curTarget,dnConf.socketTimeout);
    sock.setSoTimeout(targets.length * dnConf.socketTimeout);
    Token<BlockTokenIdentifier> accessToken=BlockTokenSecretManager.DUMMY_TOKEN;
    if (isBlockTokenEnabled) {
      accessToken=blockPoolTokenSecretManager.generateToken(b,EnumSet.of(BlockTokenIdentifier.AccessMode.WRITE));
    }
    long writeTimeout=dnConf.socketWriteTimeout + HdfsConstants.WRITE_TIMEOUT_EXTENSION * (targets.length - 1);
    OutputStream unbufOut=NetUtils.getOutputStream(sock,writeTimeout);
    InputStream unbufIn=NetUtils.getInputStream(sock);
    DataEncryptionKeyFactory keyFactory=getDataEncryptionKeyFactoryForBlock(b);
    IOStreamPair saslStreams=saslClient.socketSend(sock,unbufOut,unbufIn,keyFactory,accessToken,bpReg);
    unbufOut=saslStreams.out;
    unbufIn=saslStreams.in;
    out=new DataOutputStream(new BufferedOutputStream(unbufOut,DFSUtil.getSmallBufferSize(conf)));
    in=new DataInputStream(unbufIn);
    blockSender=new BlockSender(b,0,b.getNumBytes(),false,false,true,DataNode.this,null,cachingStrategy);
    DatanodeInfo srcNode=new DatanodeInfo(bpReg);
    new Sender(out).writeBlock(b,targetStorageTypes[0],accessToken,clientname,targets,targetStorageTypes,srcNode,stage,0,0,0,0,blockSender.getChecksum(),cachingStrategy,false,false,null);
    blockSender.sendBlock(out,unbufOut,null);
    LOG.info(getClass().getSimpleName() + ": Transmitted " + b+ " (numBytes="+ b.getNumBytes()+ ") to "+ curTarget);
    if (isClient) {
      DNTransferAckProto closeAck=DNTransferAckProto.parseFrom(PBHelper.vintPrefixed(in));
      if (LOG.isDebugEnabled()) {
        LOG.debug(getClass().getSimpleName() + ": close-ack=" + closeAck);
      }
      if (closeAck.getStatus() != Status.SUCCESS) {
        if (closeAck.getStatus() == Status.ERROR_ACCESS_TOKEN) {
          throw new InvalidBlockTokenException("Got access token error for connect ack, targets=" + Arrays.asList(targets));
        }
 else {
          throw new IOException("Bad connect ack, targets=" + Arrays.asList(targets));
        }
      }
    }
 else {
      metrics.incrBlocksReplicated();
    }
  }
 catch (  IOException ie) {
    LOG.warn(bpReg + ":Failed to transfer " + b+ " to "+ targets[0]+ " got ",ie);
    checkDiskErrorAsync();
  }
 finally {
    xmitsInProgress.getAndDecrement();
    IOUtils.closeStream(blockSender);
    IOUtils.closeStream(out);
    IOUtils.closeStream(in);
    IOUtils.closeSocket(sock);
  }
}
