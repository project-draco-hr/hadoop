{
  LOG.info("For namenode " + nnAddr + " using DELETEREPORT_INTERVAL of "+ dn.deleteReportInterval+ " msec "+ " BLOCKREPORT_INTERVAL of "+ dn.blockReportInterval+ "msec"+ " Initial delay: "+ dn.initialBlockReportDelay+ "msec"+ "; heartBeatInterval="+ dn.heartBeatInterval);
  while (dn.shouldRun && shouldServiceRun) {
    try {
      long startTime=now();
      if (startTime - lastHeartbeat > dn.heartBeatInterval) {
        lastHeartbeat=startTime;
        if (!dn.heartbeatsDisabledForTests) {
          DatanodeCommand[] cmds=sendHeartBeat();
          dn.metrics.addHeartbeat(now() - startTime);
          long startProcessCommands=now();
          if (!processCommand(cmds))           continue;
          long endProcessCommands=now();
          if (endProcessCommands - startProcessCommands > 2000) {
            LOG.info("Took " + (endProcessCommands - startProcessCommands) + "ms to process "+ cmds.length+ " commands from NN");
          }
        }
      }
      if (pendingReceivedRequests > 0 || (startTime - lastDeletedReport > dn.deleteReportInterval)) {
        reportReceivedDeletedBlocks();
        lastDeletedReport=startTime;
      }
      DatanodeCommand cmd=blockReport();
      processCommand(cmd);
      if (dn.blockScanner != null) {
        dn.blockScanner.addBlockPool(this.blockPoolId);
      }
      long waitTime=dn.heartBeatInterval - (System.currentTimeMillis() - lastHeartbeat);
synchronized (receivedAndDeletedBlockList) {
        if (waitTime > 0 && pendingReceivedRequests == 0) {
          try {
            receivedAndDeletedBlockList.wait(waitTime);
          }
 catch (          InterruptedException ie) {
            LOG.warn("BPOfferService for block pool=" + this.getBlockPoolId() + " received exception:"+ ie);
          }
        }
      }
    }
 catch (    RemoteException re) {
      String reClass=re.getClassName();
      if (UnregisteredNodeException.class.getName().equals(reClass) || DisallowedDatanodeException.class.getName().equals(reClass) || IncorrectVersionException.class.getName().equals(reClass)) {
        LOG.warn("blockpool " + blockPoolId + " is shutting down",re);
        shouldServiceRun=false;
        return;
      }
      LOG.warn("RemoteException in offerService",re);
      try {
        long sleepTime=Math.min(1000,dn.heartBeatInterval);
        Thread.sleep(sleepTime);
      }
 catch (      InterruptedException ie) {
        Thread.currentThread().interrupt();
      }
    }
catch (    IOException e) {
      LOG.warn("IOException in offerService",e);
    }
  }
}
