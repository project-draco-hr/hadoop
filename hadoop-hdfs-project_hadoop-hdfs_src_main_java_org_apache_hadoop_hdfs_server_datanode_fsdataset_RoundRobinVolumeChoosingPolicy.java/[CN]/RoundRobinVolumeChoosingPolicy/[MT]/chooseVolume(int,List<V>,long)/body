{
  int curVolume=curVolumes[curVolumeIndex] < volumes.size() ? curVolumes[curVolumeIndex] : 0;
  int startVolume=curVolume;
  long maxAvailable=0;
  while (true) {
    final V volume=volumes.get(curVolume);
    curVolume=(curVolume + 1) % volumes.size();
    long availableVolumeSize=volume.getAvailable();
    if (availableVolumeSize > blockSize) {
      curVolumes[curVolumeIndex]=curVolume;
      return volume;
    }
    if (availableVolumeSize > maxAvailable) {
      maxAvailable=availableVolumeSize;
    }
    if (curVolume == startVolume) {
      throw new DiskOutOfSpaceException("Out of space: " + "The volume with the most available space (=" + maxAvailable + " B) is less than the block size (="+ blockSize+ " B).");
    }
  }
}
