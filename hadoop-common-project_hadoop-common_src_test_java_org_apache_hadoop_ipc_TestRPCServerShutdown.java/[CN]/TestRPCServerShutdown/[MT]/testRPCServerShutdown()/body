{
  final int numClients=3;
  final List<Future<Void>> res=new ArrayList<Future<Void>>();
  final ExecutorService executorService=Executors.newFixedThreadPool(numClients);
  conf.setInt(CommonConfigurationKeys.IPC_CLIENT_CONNECT_MAX_RETRIES_KEY,0);
  RPC.Builder builder=newServerBuilder(conf).setQueueSizePerHandler(1).setNumHandlers(1).setVerbose(true);
  final Server server=setupTestServer(builder);
  final TestRpcService proxy=getClient(addr,conf);
  try {
    for (int i=0; i < numClients; i++) {
      res.add(executorService.submit(new Callable<Void>(){
        @Override public Void call() throws ServiceException, InterruptedException {
          proxy.sleep(null,newSleepRequest(100000));
          return null;
        }
      }
));
    }
    while (server.getCallQueueLen() != 1 || countThreads(CallQueueManager.class.getName()) != 1 || countThreads(PBServerImpl.class.getName()) != 1) {
      Thread.sleep(100);
    }
  }
  finally {
    try {
      stop(server,proxy);
      assertEquals("Not enough clients",numClients,res.size());
      for (      Future<Void> f : res) {
        try {
          f.get();
          fail("Future get should not return");
        }
 catch (        ExecutionException e) {
          ServiceException se=(ServiceException)e.getCause();
          assertTrue("Unexpected exception: " + se,se.getCause() instanceof IOException);
          LOG.info("Expected exception",e.getCause());
        }
      }
    }
  finally {
      executorService.shutdown();
    }
  }
}
