{
  Preconditions.checkArgument(prior != null);
  if (inode.isReference()) {
    if (inode instanceof INodeReference.WithName && snapshot != null) {
      inode.cleanSubtree(snapshot,prior,collectedBlocks,removedINodes,true);
    }
 else {
      destroyDstSubtree(inode.asReference().getReferredINode(),snapshot,prior,collectedBlocks,removedINodes);
    }
  }
 else   if (inode.isFile() && snapshot != null) {
    inode.cleanSubtree(snapshot,prior,collectedBlocks,removedINodes,true);
  }
 else   if (inode.isDirectory()) {
    Map<INode,INode> excludedNodes=null;
    if (inode instanceof INodeDirectoryWithSnapshot) {
      INodeDirectoryWithSnapshot sdir=(INodeDirectoryWithSnapshot)inode;
      DirectoryDiffList diffList=sdir.getDiffs();
      if (snapshot != null) {
        diffList.deleteSnapshotDiff(snapshot,prior,sdir,collectedBlocks,removedINodes,true);
      }
      DirectoryDiff priorDiff=diffList.getDiff(prior);
      if (priorDiff != null && priorDiff.getSnapshot().equals(prior)) {
        priorDiff.diff.destroyCreatedList(sdir,collectedBlocks,removedINodes);
        List<INode> dList=priorDiff.diff.getList(ListType.DELETED);
        excludedNodes=new HashMap<INode,INode>(dList.size());
        for (        INode dNode : dList) {
          excludedNodes.put(dNode,dNode);
        }
      }
    }
    for (    INode child : inode.asDirectory().getChildrenList(prior)) {
      if (excludedNodes != null && excludedNodes.containsKey(child)) {
        continue;
      }
      destroyDstSubtree(child,snapshot,prior,collectedBlocks,removedINodes);
    }
  }
}
