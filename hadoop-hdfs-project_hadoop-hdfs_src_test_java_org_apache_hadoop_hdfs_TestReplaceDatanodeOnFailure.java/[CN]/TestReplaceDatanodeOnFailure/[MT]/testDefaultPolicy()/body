{
  final Configuration conf=new HdfsConfiguration();
  final ReplaceDatanodeOnFailure p=ReplaceDatanodeOnFailure.get(conf);
  final DatanodeInfo[] infos=new DatanodeInfo[5];
  final DatanodeInfo[][] datanodes=new DatanodeInfo[infos.length + 1][];
  datanodes[0]=new DatanodeInfo[0];
  for (int i=0; i < infos.length; ) {
    infos[i]=DFSTestUtil.getLocalDatanodeInfo(50020 + i);
    i++;
    datanodes[i]=new DatanodeInfo[i];
    System.arraycopy(infos,0,datanodes[i],0,datanodes[i].length);
  }
  final boolean[] isAppend={true,true,false,false};
  final boolean[] isHflushed={true,false,true,false};
  for (short replication=1; replication <= infos.length; replication++) {
    for (int nExistings=0; nExistings < datanodes.length; nExistings++) {
      final DatanodeInfo[] existings=datanodes[nExistings];
      Assert.assertEquals(nExistings,existings.length);
      for (int i=0; i < isAppend.length; i++) {
        for (int j=0; j < isHflushed.length; j++) {
          final int half=replication / 2;
          final boolean enoughReplica=replication <= nExistings;
          final boolean noReplica=nExistings == 0;
          final boolean replicationL3=replication < 3;
          final boolean existingsLEhalf=nExistings <= half;
          final boolean isAH=isAppend[i] || isHflushed[j];
          final boolean expected;
          if (enoughReplica || noReplica || replicationL3) {
            expected=false;
          }
 else {
            expected=isAH || existingsLEhalf;
          }
          final boolean computed=p.satisfy(replication,existings,isAppend[i],isHflushed[j]);
          try {
            Assert.assertEquals(expected,computed);
          }
 catch (          AssertionError e) {
            final String s="replication=" + replication + "\nnExistings ="+ nExistings+ "\nisAppend   ="+ isAppend[i]+ "\nisHflushed ="+ isHflushed[j];
            throw new RuntimeException(s,e);
          }
        }
      }
    }
  }
}
