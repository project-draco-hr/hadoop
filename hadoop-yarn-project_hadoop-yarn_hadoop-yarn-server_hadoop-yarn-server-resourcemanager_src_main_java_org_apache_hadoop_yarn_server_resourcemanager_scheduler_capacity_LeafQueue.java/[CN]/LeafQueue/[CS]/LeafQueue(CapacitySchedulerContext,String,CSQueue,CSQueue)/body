{
  this.scheduler=cs;
  this.queueName=queueName;
  this.parent=parent;
  this.resourceCalculator=cs.getResourceCalculator();
  this.metrics=old != null ? old.getMetrics() : QueueMetrics.forQueue(getQueuePath(),parent,cs.getConfiguration().getEnableUserMetrics(),cs.getConf());
  this.activeUsersManager=new ActiveUsersManager(metrics);
  this.minimumAllocation=cs.getMinimumResourceCapability();
  this.maximumAllocation=cs.getMaximumResourceCapability();
  this.minimumAllocationFactor=Resources.ratio(resourceCalculator,Resources.subtract(maximumAllocation,minimumAllocation),maximumAllocation);
  this.containerTokenSecretManager=cs.getContainerTokenSecretManager();
  float capacity=(float)cs.getConfiguration().getCapacity(getQueuePath()) / 100;
  float absoluteCapacity=parent.getAbsoluteCapacity() * capacity;
  float maximumCapacity=(float)cs.getConfiguration().getMaximumCapacity(getQueuePath()) / 100;
  float absoluteMaxCapacity=CSQueueUtils.computeAbsoluteMaximumCapacity(maximumCapacity,parent);
  int userLimit=cs.getConfiguration().getUserLimit(getQueuePath());
  float userLimitFactor=cs.getConfiguration().getUserLimitFactor(getQueuePath());
  int maxApplications=cs.getConfiguration().getMaximumApplicationsPerQueue(getQueuePath());
  if (maxApplications < 0) {
    int maxSystemApps=cs.getConfiguration().getMaximumSystemApplications();
    maxApplications=(int)(maxSystemApps * absoluteCapacity);
  }
  maxApplicationsPerUser=(int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);
  float maxAMResourcePerQueuePercent=cs.getConfiguration().getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());
  int maxActiveApplications=CSQueueUtils.computeMaxActiveApplications(resourceCalculator,cs.getClusterResources(),this.minimumAllocation,maxAMResourcePerQueuePercent,absoluteMaxCapacity);
  this.maxActiveAppsUsingAbsCap=CSQueueUtils.computeMaxActiveApplications(resourceCalculator,cs.getClusterResources(),this.minimumAllocation,maxAMResourcePerQueuePercent,absoluteCapacity);
  int maxActiveApplicationsPerUser=CSQueueUtils.computeMaxActiveApplicationsPerUser(maxActiveAppsUsingAbsCap,userLimit,userLimitFactor);
  this.queueInfo=recordFactory.newRecordInstance(QueueInfo.class);
  this.queueInfo.setQueueName(queueName);
  this.queueInfo.setChildQueues(new ArrayList<QueueInfo>());
  QueueState state=cs.getConfiguration().getState(getQueuePath());
  Map<QueueACL,AccessControlList> acls=cs.getConfiguration().getAcls(getQueuePath());
  setupQueueConfigs(cs.getClusterResources(),capacity,absoluteCapacity,maximumCapacity,absoluteMaxCapacity,userLimit,userLimitFactor,maxApplications,maxAMResourcePerQueuePercent,maxApplicationsPerUser,maxActiveApplications,maxActiveApplicationsPerUser,state,acls,cs.getConfiguration().getNodeLocalityDelay());
  if (LOG.isDebugEnabled()) {
    LOG.debug("LeafQueue:" + " name=" + queueName + ", fullname="+ getQueuePath());
  }
  Comparator<FiCaSchedulerApp> applicationComparator=cs.getApplicationComparator();
  this.pendingApplications=new TreeSet<FiCaSchedulerApp>(applicationComparator);
  this.activeApplications=new TreeSet<FiCaSchedulerApp>(applicationComparator);
}
