{
  updateCurrentResourceLimits(currentResourceLimits,clusterResource);
  if (LOG.isDebugEnabled()) {
    LOG.debug("assignContainers: node=" + node.getNodeName() + " #applications="+ orderingPolicy.getNumSchedulableEntities());
  }
  RMContainer reservedContainer=node.getReservedContainer();
  if (reservedContainer != null) {
    FiCaSchedulerApp application=getApplication(reservedContainer.getApplicationAttemptId());
synchronized (application) {
      CSAssignment assignment=application.assignContainers(clusterResource,node,currentResourceLimits,schedulingMode,reservedContainer);
      handleExcessReservedContainer(clusterResource,assignment,node,application);
      return assignment;
    }
  }
  if (schedulingMode == SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY && !accessibleToPartition(node.getPartition())) {
    return CSAssignment.NULL_ASSIGNMENT;
  }
  if (!hasPendingResourceRequest(node.getPartition(),clusterResource,schedulingMode)) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Skip this queue=" + getQueuePath() + ", because it doesn't need more resource, schedulingMode="+ schedulingMode.name()+ " node-partition="+ node.getPartition());
    }
    return CSAssignment.NULL_ASSIGNMENT;
  }
  for (Iterator<FiCaSchedulerApp> assignmentIterator=orderingPolicy.getAssignmentIterator(); assignmentIterator.hasNext(); ) {
    FiCaSchedulerApp application=assignmentIterator.next();
    if (!super.canAssignToThisQueue(clusterResource,node.getPartition(),currentResourceLimits,application.getCurrentReservation(),schedulingMode)) {
      return CSAssignment.NULL_ASSIGNMENT;
    }
    Resource userLimit=computeUserLimitAndSetHeadroom(application,clusterResource,node.getPartition(),schedulingMode);
    if (!canAssignToUser(clusterResource,application.getUser(),userLimit,application,node.getPartition(),currentResourceLimits)) {
      application.updateAMContainerDiagnostics(AMState.ACTIVATED,"User capacity has reached its maximum limit.");
      continue;
    }
    CSAssignment assignment=application.assignContainers(clusterResource,node,currentResourceLimits,schedulingMode,null);
    if (LOG.isDebugEnabled()) {
      LOG.debug("post-assignContainers for application " + application.getApplicationId());
      application.showRequests();
    }
    Resource assigned=assignment.getResource();
    handleExcessReservedContainer(clusterResource,assignment,node,application);
    if (Resources.greaterThan(resourceCalculator,clusterResource,assigned,Resources.none())) {
      RMContainer reservedOrAllocatedRMContainer=application.getRMContainer(assignment.getAssignmentInformation().getFirstAllocatedOrReservedContainerId());
      allocateResource(clusterResource,application,assigned,node.getPartition(),reservedOrAllocatedRMContainer,assignment.isIncreasedAllocation());
      return assignment;
    }
 else     if (assignment.getSkipped()) {
      application.updateNodeInfoForAMDiagnostics(node);
    }
 else {
      return CSAssignment.NULL_ASSIGNMENT;
    }
  }
  return CSAssignment.NULL_ASSIGNMENT;
}
