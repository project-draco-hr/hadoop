{
  Set<String> labelCanAccess;
  if (null == nodeLabels || nodeLabels.isEmpty()) {
    labelCanAccess=new HashSet<String>();
    labelCanAccess.add(RMNodeLabelsManager.NO_LABEL);
  }
 else {
    labelCanAccess=new HashSet<String>(Sets.intersection(accessibleLabels,nodeLabels));
  }
  boolean canAssign=true;
  for (  String label : labelCanAccess) {
    if (!usedResourcesByNodeLabels.containsKey(label)) {
      usedResourcesByNodeLabels.put(label,Resources.createResource(0));
    }
    Resource potentialTotalCapacity=Resources.add(usedResourcesByNodeLabels.get(label),required);
    float potentialNewCapacity=Resources.divide(resourceCalculator,clusterResource,potentialTotalCapacity,labelManager.getResourceByLabel(label,clusterResource));
    if (this.reservationsContinueLooking && checkReservations && label.equals(RMNodeLabelsManager.NO_LABEL)) {
      float potentialNewWithoutReservedCapacity=Resources.divide(resourceCalculator,clusterResource,Resources.subtract(potentialTotalCapacity,application.getCurrentReservation()),labelManager.getResourceByLabel(label,clusterResource));
      if (potentialNewWithoutReservedCapacity <= absoluteMaxCapacity) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("try to use reserved: " + getQueueName() + " usedResources: "+ usedResources+ " clusterResources: "+ clusterResource+ " reservedResources: "+ application.getCurrentReservation()+ " currentCapacity "+ Resources.divide(resourceCalculator,clusterResource,usedResources,clusterResource)+ " required "+ required+ " potentialNewWithoutReservedCapacity: "+ potentialNewWithoutReservedCapacity+ " ( "+ " max-capacity: "+ absoluteMaxCapacity+ ")");
        }
        return true;
      }
    }
    if (potentialNewCapacity > getAbsoluteMaximumCapacityByNodeLabel(label) + 1e-4) {
      canAssign=false;
      break;
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(getQueueName() + "Check assign to queue, label=" + label+ " usedResources: "+ usedResourcesByNodeLabels.get(label)+ " clusterResources: "+ clusterResource+ " currentCapacity "+ Resources.divide(resourceCalculator,clusterResource,usedResourcesByNodeLabels.get(label),labelManager.getResourceByLabel(label,clusterResource))+ " potentialNewCapacity: "+ potentialNewCapacity+ " ( "+ " max-capacity: "+ absoluteMaxCapacity+ ")");
    }
  }
  return canAssign;
}
