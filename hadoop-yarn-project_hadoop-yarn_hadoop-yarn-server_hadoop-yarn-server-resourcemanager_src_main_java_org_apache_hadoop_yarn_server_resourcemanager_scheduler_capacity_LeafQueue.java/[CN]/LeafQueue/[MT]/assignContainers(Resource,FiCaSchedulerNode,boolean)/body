{
  if (LOG.isDebugEnabled()) {
    LOG.debug("assignContainers: node=" + node.getNodeName() + " #applications="+ activeApplications.size());
  }
  if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels,node.getLabels())) {
    return NULL_ASSIGNMENT;
  }
  RMContainer reservedContainer=node.getReservedContainer();
  if (reservedContainer != null) {
    FiCaSchedulerApp application=getApplication(reservedContainer.getApplicationAttemptId());
synchronized (application) {
      return assignReservedContainer(application,node,reservedContainer,clusterResource);
    }
  }
  for (  FiCaSchedulerApp application : activeApplications) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("pre-assignContainers for application " + application.getApplicationId());
      application.showRequests();
    }
synchronized (application) {
      if (SchedulerAppUtils.isBlacklisted(application,node,LOG)) {
        continue;
      }
      for (      Priority priority : application.getPriorities()) {
        ResourceRequest anyRequest=application.getResourceRequest(priority,ResourceRequest.ANY);
        if (null == anyRequest) {
          continue;
        }
        Resource required=anyRequest.getCapability();
        if (application.getTotalRequiredResources(priority) <= 0) {
          continue;
        }
        if (!this.reservationsContinueLooking) {
          if (!needContainers(application,priority,required)) {
            if (LOG.isDebugEnabled()) {
              LOG.debug("doesn't need containers based on reservation algo!");
            }
            continue;
          }
        }
        Set<String> requestedNodeLabels=getRequestLabelSetByExpression(anyRequest.getNodeLabelExpression());
        Resource userLimit=computeUserLimitAndSetHeadroom(application,clusterResource,required,requestedNodeLabels);
        if (!canAssignToThisQueue(clusterResource,required,node.getLabels(),application,true)) {
          return NULL_ASSIGNMENT;
        }
        if (!assignToUser(clusterResource,application.getUser(),userLimit,application,true,requestedNodeLabels)) {
          break;
        }
        application.addSchedulingOpportunity(priority);
        CSAssignment assignment=assignContainersOnNode(clusterResource,node,application,priority,null,needToUnreserve);
        if (assignment.getSkipped()) {
          application.subtractSchedulingOpportunity(priority);
          continue;
        }
        Resource assigned=assignment.getResource();
        if (Resources.greaterThan(resourceCalculator,clusterResource,assigned,Resources.none())) {
          allocateResource(clusterResource,application,assigned,node.getLabels());
          if (assignment.getType() != NodeType.OFF_SWITCH) {
            if (LOG.isDebugEnabled()) {
              LOG.debug("Resetting scheduling opportunities");
            }
            application.resetSchedulingOpportunities(priority);
          }
          return assignment;
        }
 else {
          break;
        }
      }
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("post-assignContainers for application " + application.getApplicationId());
    }
    application.showRequests();
  }
  return NULL_ASSIGNMENT;
}
