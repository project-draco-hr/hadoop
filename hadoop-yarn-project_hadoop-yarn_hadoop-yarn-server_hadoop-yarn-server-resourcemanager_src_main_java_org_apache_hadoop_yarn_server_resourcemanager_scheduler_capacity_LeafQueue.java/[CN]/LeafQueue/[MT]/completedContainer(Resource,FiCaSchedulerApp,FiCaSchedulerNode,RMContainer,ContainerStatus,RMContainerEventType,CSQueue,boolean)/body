{
  updateSchedulerHealthForCompletedContainer(rmContainer,containerStatus);
  if (application != null) {
    if (rmContainer.hasIncreaseReservation()) {
      unreserveIncreasedContainer(clusterResource,application,node,rmContainer);
    }
    application.removeIncreaseRequest(node.getNodeID(),rmContainer.getAllocatedSchedulerKey(),rmContainer.getContainerId());
    boolean removed=false;
    try {
      writeLock.lock();
      Container container=rmContainer.getContainer();
      if (rmContainer.getState() == RMContainerState.RESERVED) {
        removed=application.unreserve(rmContainer.getReservedSchedulerKey(),node,rmContainer);
      }
 else {
        removed=application.containerCompleted(rmContainer,containerStatus,event,node.getPartition());
        node.releaseContainer(container);
      }
      if (removed) {
        orderingPolicy.containerReleased(application,rmContainer);
        releaseResource(clusterResource,application,container.getResource(),node.getPartition(),rmContainer,false);
      }
    }
  finally {
      writeLock.unlock();
    }
    if (removed) {
      getParent().completedContainer(clusterResource,application,node,rmContainer,null,event,this,sortQueues);
    }
  }
  csContext.getPreemptionManager().removeKillableContainer(new KillableContainer(rmContainer,node.getPartition(),queueName));
}
