{
  FSNamesystem fsn=namenode.getNamesystem();
  if (fsn == null) {
    throw new IOException("Namesystem has not been intialized yet.");
  }
  final BlockManager bm=fsn.getBlockManager();
  HashSet<Node> excludes=new HashSet<Node>();
  if (excludeDatanodes != null) {
    for (    String host : StringUtils.getTrimmedStringCollection(excludeDatanodes)) {
      int idx=host.indexOf(":");
      if (idx != -1) {
        excludes.add(bm.getDatanodeManager().getDatanodeByXferAddr(host.substring(0,idx),Integer.parseInt(host.substring(idx + 1))));
      }
 else {
        excludes.add(bm.getDatanodeManager().getDatanodeByHost(host));
      }
    }
  }
  if (op == PutOpParam.Op.CREATE) {
    final DatanodeDescriptor clientNode=bm.getDatanodeManager().getDatanodeByHost(getRemoteAddress());
    if (clientNode != null) {
      final DatanodeStorageInfo[] storages=bm.chooseTarget4WebHDFS(path,clientNode,excludes,blocksize);
      if (storages.length > 0) {
        return storages[0].getDatanodeDescriptor();
      }
    }
  }
 else   if (op == GetOpParam.Op.OPEN || op == GetOpParam.Op.GETFILECHECKSUM || op == PostOpParam.Op.APPEND) {
    final NamenodeProtocols np=getRPCServer(namenode);
    final HdfsFileStatus status=np.getFileInfo(path);
    if (status == null) {
      throw new FileNotFoundException("File " + path + " not found.");
    }
    final long len=status.getLen();
    if (op == GetOpParam.Op.OPEN) {
      if (openOffset < 0L || (openOffset >= len && len > 0)) {
        throw new IOException("Offset=" + openOffset + " out of the range [0, "+ len+ "); "+ op+ ", path="+ path);
      }
    }
    if (len > 0) {
      final long offset=op == GetOpParam.Op.OPEN ? openOffset : len - 1;
      final LocatedBlocks locations=np.getBlockLocations(path,offset,1);
      final int count=locations.locatedBlockCount();
      if (count > 0) {
        return bestNode(locations.get(0).getLocations(),excludes);
      }
    }
  }
  return (DatanodeDescriptor)bm.getDatanodeManager().getNetworkTopology().chooseRandom(NodeBase.ROOT);
}
