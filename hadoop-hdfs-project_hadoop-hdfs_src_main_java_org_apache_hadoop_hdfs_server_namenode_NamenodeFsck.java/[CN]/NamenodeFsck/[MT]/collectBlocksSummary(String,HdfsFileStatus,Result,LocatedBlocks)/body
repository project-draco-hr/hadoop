{
  String path=file.getFullName(parent);
  boolean isOpen=blocks.isUnderConstruction();
  int missing=0;
  int corrupt=0;
  long missize=0;
  long corruptSize=0;
  int underReplicatedPerFile=0;
  int misReplicatedPerFile=0;
  StringBuilder report=new StringBuilder();
  int blockNumber=0;
  for (  LocatedBlock lBlk : blocks.getLocatedBlocks()) {
    ExtendedBlock block=lBlk.getBlock();
    BlockManager bm=namenode.getNamesystem().getBlockManager();
    final BlockInfo storedBlock=bm.getStoredBlock(block.getLocalBlock());
    NumberReplicas numberReplicas=bm.countNodes(storedBlock);
    int decommissionedReplicas=numberReplicas.decommissioned();
    int decommissioningReplicas=numberReplicas.decommissioning();
    res.decommissionedReplicas+=decommissionedReplicas;
    res.decommissioningReplicas+=decommissioningReplicas;
    int liveReplicas=numberReplicas.liveReplicas();
    int totalReplicasPerBlock=liveReplicas + decommissionedReplicas + decommissioningReplicas;
    res.totalReplicas+=totalReplicasPerBlock;
    short targetFileReplication;
    if (file.getReplication() == 0) {
      INode inode=namenode.getNamesystem().getFSDirectory().getINode(path);
      INodesInPath iip=INodesInPath.fromINode(inode);
      ECSchema ecSchema=namenode.getNamesystem().getFSDirectory().getECSchema(iip);
      targetFileReplication=(short)(ecSchema.getNumDataUnits() + ecSchema.getNumParityUnits());
    }
 else {
      targetFileReplication=file.getReplication();
    }
    res.numExpectedReplicas+=targetFileReplication;
    if (totalReplicasPerBlock < res.minReplication) {
      res.numUnderMinReplicatedBlocks++;
    }
    if (liveReplicas > targetFileReplication) {
      res.excessiveReplicas+=(liveReplicas - targetFileReplication);
      res.numOverReplicatedBlocks+=1;
    }
    boolean isCorrupt=lBlk.isCorrupt();
    if (isCorrupt) {
      res.addCorrupt(block.getNumBytes());
      corrupt++;
      corruptSize+=block.getNumBytes();
      out.print("\n" + path + ": CORRUPT blockpool "+ block.getBlockPoolId()+ " block "+ block.getBlockName()+ "\n");
    }
    if (totalReplicasPerBlock >= res.minReplication)     res.numMinReplicatedBlocks++;
    if (totalReplicasPerBlock < targetFileReplication && totalReplicasPerBlock > 0) {
      res.missingReplicas+=(targetFileReplication - totalReplicasPerBlock);
      res.numUnderReplicatedBlocks+=1;
      underReplicatedPerFile++;
      if (!showFiles) {
        out.print("\n" + path + ": ");
      }
      out.println(" Under replicated " + block + ". Target Replicas is "+ targetFileReplication+ " but found "+ liveReplicas+ " live replica(s), "+ decommissionedReplicas+ " decommissioned replica(s) and "+ decommissioningReplicas+ " decommissioning replica(s).");
    }
    BlockPlacementStatus blockPlacementStatus=bpPolicies.getPolicy(false).verifyBlockPlacement(path,lBlk,targetFileReplication);
    if (!blockPlacementStatus.isPlacementPolicySatisfied()) {
      res.numMisReplicatedBlocks++;
      misReplicatedPerFile++;
      if (!showFiles) {
        if (underReplicatedPerFile == 0)         out.println();
        out.print(path + ": ");
      }
      out.println(" Replica placement policy is violated for " + block + ". "+ blockPlacementStatus.getErrorDescription());
    }
    if (this.showStoragePolcies && lBlk.getStorageTypes() != null) {
      countStorageTypeSummary(file,lBlk);
    }
    String blkName=block.toString();
    report.append(blockNumber + ". " + blkName+ " len="+ block.getNumBytes());
    if (totalReplicasPerBlock == 0 && !isCorrupt) {
      report.append(" MISSING!");
      res.addMissing(block.toString(),block.getNumBytes());
      missing++;
      missize+=block.getNumBytes();
    }
 else {
      report.append(" Live_repl=" + liveReplicas);
      if (showLocations || showRacks || showReplicaDetails) {
        StringBuilder sb=new StringBuilder("[");
        DatanodeStorageInfo[] storages=bm.getStorages(storedBlock);
        for (int i=0; i < storages.length; i++) {
          DatanodeStorageInfo storage=storages[i];
          DatanodeDescriptor dnDesc=storage.getDatanodeDescriptor();
          if (showRacks) {
            sb.append(NodeBase.getPath(dnDesc));
          }
 else {
            sb.append(new DatanodeInfoWithStorage(dnDesc,storage.getStorageID(),storage.getStorageType()));
          }
          if (showReplicaDetails) {
            LightWeightLinkedSet<BlockInfo> blocksExcess=bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());
            Collection<DatanodeDescriptor> corruptReplicas=bm.getCorruptReplicas(block.getLocalBlock());
            sb.append("(");
            if (dnDesc.isDecommissioned()) {
              sb.append("DECOMMISSIONED)");
            }
 else             if (dnDesc.isDecommissionInProgress()) {
              sb.append("DECOMMISSIONING)");
            }
 else             if (corruptReplicas != null && corruptReplicas.contains(dnDesc)) {
              sb.append("CORRUPT)");
            }
 else             if (blocksExcess != null && blocksExcess.contains(block.getLocalBlock())) {
              sb.append("EXCESS)");
            }
 else             if (dnDesc.isStale(this.staleInterval)) {
              sb.append("STALE_NODE)");
            }
 else             if (storage.areBlockContentsStale()) {
              sb.append("STALE_BLOCK_CONTENT)");
            }
 else {
              sb.append("LIVE)");
            }
          }
          if (i < storages.length - 1) {
            sb.append(", ");
          }
        }
        sb.append(']');
        report.append(" " + sb.toString());
      }
    }
    report.append('\n');
    blockNumber++;
  }
  if ((missing > 0) || (corrupt > 0)) {
    if (!showFiles) {
      if (missing > 0) {
        out.print("\n" + path + ": MISSING "+ missing+ " blocks of total size "+ missize+ " B.");
      }
      if (corrupt > 0) {
        out.print("\n" + path + ": CORRUPT "+ corrupt+ " blocks of total size "+ corruptSize+ " B.");
      }
    }
    res.corruptFiles++;
    if (isOpen) {
      LOG.info("Fsck: ignoring open file " + path);
    }
 else {
      if (doMove)       copyBlocksToLostFound(parent,file,blocks);
      if (doDelete)       deleteCorruptedFile(path);
    }
  }
  if (showFiles) {
    if (missing > 0 || corrupt > 0) {
      if (missing > 0) {
        out.print(" MISSING " + missing + " blocks of total size "+ missize+ " B\n");
      }
      if (corrupt > 0) {
        out.print(" CORRUPT " + corrupt + " blocks of total size "+ corruptSize+ " B\n");
      }
    }
 else     if (underReplicatedPerFile == 0 && misReplicatedPerFile == 0) {
      out.print(" OK\n");
    }
    if (showBlocks) {
      out.print(report.toString() + "\n");
    }
  }
}
