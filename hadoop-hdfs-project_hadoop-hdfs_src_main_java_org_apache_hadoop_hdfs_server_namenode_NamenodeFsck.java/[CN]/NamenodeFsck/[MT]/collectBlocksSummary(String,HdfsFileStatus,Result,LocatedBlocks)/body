{
  String path=file.getFullName(parent);
  boolean isOpen=blocks.isUnderConstruction();
  int missing=0;
  int corrupt=0;
  long missize=0;
  long corruptSize=0;
  int underReplicatedPerFile=0;
  int misReplicatedPerFile=0;
  StringBuilder report=new StringBuilder();
  int blockNumber=0;
  for (  LocatedBlock lBlk : blocks.getLocatedBlocks()) {
    ExtendedBlock block=lBlk.getBlock();
    BlockManager bm=namenode.getNamesystem().getBlockManager();
    NumberReplicas numberReplicas=bm.countNodes(block.getLocalBlock());
    int decommissionedReplicas=numberReplicas.decommissioned();
    ;
    int decommissioningReplicas=numberReplicas.decommissioning();
    res.decommissionedReplicas+=decommissionedReplicas;
    res.decommissioningReplicas+=decommissioningReplicas;
    int liveReplicas=numberReplicas.liveReplicas();
    int totalReplicasPerBlock=liveReplicas + decommissionedReplicas + decommissioningReplicas;
    res.totalReplicas+=totalReplicasPerBlock;
    short targetFileReplication=file.getReplication();
    res.numExpectedReplicas+=targetFileReplication;
    if (totalReplicasPerBlock < minReplication) {
      res.numUnderMinReplicatedBlocks++;
    }
    if (liveReplicas > targetFileReplication) {
      res.excessiveReplicas+=(liveReplicas - targetFileReplication);
      res.numOverReplicatedBlocks+=1;
    }
    boolean isCorrupt=lBlk.isCorrupt();
    if (isCorrupt) {
      res.addCorrupt(block.getNumBytes());
      corrupt++;
      corruptSize+=block.getNumBytes();
      out.print("\n" + path + ": CORRUPT blockpool "+ block.getBlockPoolId()+ " block "+ block.getBlockName()+ "\n");
    }
    if (totalReplicasPerBlock >= minReplication)     res.numMinReplicatedBlocks++;
    if (totalReplicasPerBlock < targetFileReplication && totalReplicasPerBlock > 0) {
      res.missingReplicas+=(targetFileReplication - totalReplicasPerBlock);
      res.numUnderReplicatedBlocks+=1;
      underReplicatedPerFile++;
      if (!showFiles) {
        out.print("\n" + path + ": ");
      }
      out.println(" Under replicated " + block + ". Target Replicas is "+ targetFileReplication+ " but found "+ liveReplicas+ " live replica(s), "+ decommissionedReplicas+ " decommissioned replica(s) and "+ decommissioningReplicas+ " decommissioning replica(s).");
    }
    BlockPlacementStatus blockPlacementStatus=bpPolicy.verifyBlockPlacement(path,lBlk,targetFileReplication);
    if (!blockPlacementStatus.isPlacementPolicySatisfied()) {
      res.numMisReplicatedBlocks++;
      misReplicatedPerFile++;
      if (!showFiles) {
        if (underReplicatedPerFile == 0)         out.println();
        out.print(path + ": ");
      }
      out.println(" Replica placement policy is violated for " + block + ". "+ blockPlacementStatus.getErrorDescription());
    }
    if (this.showStoragePolcies && lBlk.getStorageTypes() != null) {
      countStorageTypeSummary(file,lBlk);
    }
    String blkName=block.toString();
    report.append(blockNumber + ". " + blkName+ " len="+ block.getNumBytes());
    if (totalReplicasPerBlock == 0 && !isCorrupt) {
      report.append(" MISSING!");
      res.addMissing(block.toString(),block.getNumBytes());
      missing++;
      missize+=block.getNumBytes();
    }
 else {
      report.append(" Live_repl=" + liveReplicas);
      if (showLocations || showRacks || showReplicaDetails) {
        StringBuilder sb=new StringBuilder("[");
        Iterable<DatanodeStorageInfo> storages=bm.getStorages(block.getLocalBlock());
        for (Iterator<DatanodeStorageInfo> iterator=storages.iterator(); iterator.hasNext(); ) {
          DatanodeStorageInfo storage=iterator.next();
          DatanodeDescriptor dnDesc=storage.getDatanodeDescriptor();
          if (showRacks) {
            sb.append(NodeBase.getPath(dnDesc));
          }
 else {
            sb.append(new DatanodeInfoWithStorage(dnDesc,storage.getStorageID(),storage.getStorageType()));
          }
          if (showReplicaDetails) {
            LightWeightLinkedSet<Block> blocksExcess=bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());
            Collection<DatanodeDescriptor> corruptReplicas=bm.getCorruptReplicas(block.getLocalBlock());
            sb.append("(");
            if (dnDesc.isDecommissioned()) {
              sb.append("DECOMMISSIONED)");
            }
 else             if (dnDesc.isDecommissionInProgress()) {
              sb.append("DECOMMISSIONING)");
            }
 else             if (corruptReplicas != null && corruptReplicas.contains(dnDesc)) {
              sb.append("CORRUPT)");
            }
 else             if (blocksExcess != null && blocksExcess.contains(block.getLocalBlock())) {
              sb.append("EXCESS)");
            }
 else             if (dnDesc.isStale(this.staleInterval)) {
              sb.append("STALE_NODE)");
            }
 else             if (storage.areBlockContentsStale()) {
              sb.append("STALE_BLOCK_CONTENT)");
            }
 else {
              sb.append("LIVE)");
            }
          }
          if (iterator.hasNext()) {
            sb.append(", ");
          }
        }
        sb.append(']');
        report.append(" " + sb.toString());
      }
    }
    report.append('\n');
    blockNumber++;
  }
  if ((missing > 0) || (corrupt > 0)) {
    if (!showFiles) {
      if (missing > 0) {
        out.print("\n" + path + ": MISSING "+ missing+ " blocks of total size "+ missize+ " B.");
      }
      if (corrupt > 0) {
        out.print("\n" + path + ": CORRUPT "+ corrupt+ " blocks of total size "+ corruptSize+ " B.");
      }
    }
    res.corruptFiles++;
    if (isOpen) {
      LOG.info("Fsck: ignoring open file " + path);
    }
 else {
      if (doMove)       copyBlocksToLostFound(parent,file,blocks);
      if (doDelete)       deleteCorruptedFile(path);
    }
  }
  if (showFiles) {
    if (missing > 0 || corrupt > 0) {
      if (missing > 0) {
        out.print(" MISSING " + missing + " blocks of total size "+ missize+ " B\n");
      }
      if (corrupt > 0) {
        out.print(" CORRUPT " + corrupt + " blocks of total size "+ corruptSize+ " B\n");
      }
    }
 else     if (underReplicatedPerFile == 0 && misReplicatedPerFile == 0) {
      out.print(" OK\n");
    }
    if (showBlocks) {
      out.print(report.toString() + "\n");
    }
  }
}
