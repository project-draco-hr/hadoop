{
  final long startTime=Time.monotonicNow();
  try {
    if (blockIds != null) {
      String[] blocks=blockIds.split(" ");
      StringBuilder sb=new StringBuilder();
      sb.append("FSCK started by " + UserGroupInformation.getCurrentUser() + " from "+ remoteAddress+ " at "+ new Date());
      out.println(sb.toString());
      sb.append(" for blockIds: \n");
      for (      String blk : blocks) {
        if (blk == null || !blk.contains(Block.BLOCK_FILE_PREFIX)) {
          out.println("Incorrect blockId format: " + blk);
          continue;
        }
        out.print("\n");
        blockIdCK(blk);
        sb.append(blk + "\n");
      }
      LOG.info(sb.toString());
      namenode.getNamesystem().logFsckEvent("/",remoteAddress);
      out.flush();
      return;
    }
    String msg="FSCK started by " + UserGroupInformation.getCurrentUser() + " from "+ remoteAddress+ " for path "+ path+ " at "+ new Date();
    LOG.info(msg);
    out.println(msg);
    namenode.getNamesystem().logFsckEvent(path,remoteAddress);
    if (snapshottableDirs != null) {
      SnapshottableDirectoryStatus[] snapshotDirs=namenode.getRpcServer().getSnapshottableDirListing();
      if (snapshotDirs != null) {
        for (        SnapshottableDirectoryStatus dir : snapshotDirs) {
          snapshottableDirs.add(dir.getFullPath().toString());
        }
      }
    }
    final HdfsFileStatus file=namenode.getRpcServer().getFileInfo(path);
    if (file != null) {
      if (showCorruptFileBlocks) {
        listCorruptFileBlocks();
        return;
      }
      if (this.showStoragePolcies) {
        storageTypeSummary=new StoragePolicySummary(namenode.getNamesystem().getBlockManager().getStoragePolicies());
      }
      Result replRes=new ReplicationResult(conf);
      Result ecRes=new ErasureCodingResult(conf);
      check(path,file,replRes,ecRes);
      out.print("\nStatus: ");
      out.println(replRes.isHealthy() && ecRes.isHealthy() ? "HEALTHY" : "CORRUPT");
      out.println(" Number of data-nodes:\t" + totalDatanodes);
      out.println(" Number of racks:\t\t" + networktopology.getNumOfRacks());
      out.println(" Total dirs:\t\t\t" + totalDirs);
      out.println(" Total symlinks:\t\t" + totalSymlinks);
      out.println("\nReplicated Blocks:");
      out.println(replRes);
      out.println("\nErasure Coded Block Groups:");
      out.println(ecRes);
      if (this.showStoragePolcies) {
        out.print(storageTypeSummary.toString());
      }
      out.println("FSCK ended at " + new Date() + " in "+ (Time.monotonicNow() - startTime + " milliseconds"));
      if (internalError) {
        throw new IOException("fsck encountered internal errors!");
      }
      if (replRes.isHealthy() && ecRes.isHealthy()) {
        out.print("\n\nThe filesystem under path '" + path + "' "+ HEALTHY_STATUS);
      }
 else {
        out.print("\n\nThe filesystem under path '" + path + "' "+ CORRUPT_STATUS);
      }
    }
 else {
      out.print("\n\nPath '" + path + "' "+ NONEXISTENT_STATUS);
    }
  }
 catch (  Exception e) {
    String errMsg="Fsck on path '" + path + "' "+ FAILURE_STATUS;
    LOG.warn(errMsg,e);
    out.println("FSCK ended at " + new Date() + " in "+ (Time.monotonicNow() - startTime + " milliseconds"));
    out.println(e.getMessage());
    out.print("\n\n" + errMsg);
  }
 finally {
    out.close();
  }
}
