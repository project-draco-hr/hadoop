{
  this.conf=conf;
  this.namenode=namenode;
  this.networktopology=networktopology;
  this.out=out;
  this.totalDatanodes=totalDatanodes;
  this.minReplication=minReplication;
  this.remoteAddress=remoteAddress;
  this.bpPolicy=BlockPlacementPolicy.getInstance(conf,null,networktopology,namenode.getNamesystem().getBlockManager().getDatanodeManager().getHost2DatanodeMap());
  this.saslClient=new SaslDataTransferClient(DataTransferSaslUtil.getSaslPropertiesResolver(conf),TrustedChannelResolver.getInstance(conf),conf.getBoolean(IPC_CLIENT_FALLBACK_TO_SIMPLE_AUTH_ALLOWED_KEY,IPC_CLIENT_FALLBACK_TO_SIMPLE_AUTH_ALLOWED_DEFAULT));
  for (Iterator<String> it=pmap.keySet().iterator(); it.hasNext(); ) {
    String key=it.next();
    if (key.equals("path")) {
      this.path=pmap.get("path")[0];
    }
 else     if (key.equals("move")) {
      this.doMove=true;
    }
 else     if (key.equals("delete")) {
      this.doDelete=true;
    }
 else     if (key.equals("files")) {
      this.showFiles=true;
    }
 else     if (key.equals("blocks")) {
      this.showBlocks=true;
    }
 else     if (key.equals("locations")) {
      this.showLocations=true;
    }
 else     if (key.equals("racks")) {
      this.showRacks=true;
    }
 else     if (key.equals("showprogress")) {
      this.showprogress=true;
    }
 else     if (key.equals("openforwrite")) {
      this.showOpenFiles=true;
    }
 else     if (key.equals("listcorruptfileblocks")) {
      this.showCorruptFileBlocks=true;
    }
 else     if (key.equals("startblockafter")) {
      this.currentCookie[0]=pmap.get("startblockafter")[0];
    }
 else     if (key.equals("includeSnapshots")) {
      this.snapshottableDirs=new ArrayList<String>();
    }
  }
}
