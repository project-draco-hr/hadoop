{
  TQComparator tqComparator=new TQComparator(rc,tot_guarant);
  PriorityQueue<TempQueuePerPartition> orderedByNeed=new PriorityQueue<>(10,tqComparator);
  for (Iterator<TempQueuePerPartition> i=qAlloc.iterator(); i.hasNext(); ) {
    TempQueuePerPartition q=i.next();
    Resource used=q.getUsed();
    if (Resources.greaterThan(rc,tot_guarant,used,q.getGuaranteed())) {
      q.idealAssigned=Resources.add(q.getGuaranteed(),q.untouchableExtra);
    }
 else {
      q.idealAssigned=Resources.clone(used);
    }
    Resources.subtractFrom(unassigned,q.idealAssigned);
    Resource curPlusPend=Resources.add(q.getUsed(),q.pending);
    if (Resources.lessThan(rc,tot_guarant,q.idealAssigned,curPlusPend)) {
      orderedByNeed.add(q);
    }
  }
  while (!orderedByNeed.isEmpty() && Resources.greaterThan(rc,tot_guarant,unassigned,Resources.none())) {
    Resource wQassigned=Resource.newInstance(0,0);
    resetCapacity(rc,unassigned,orderedByNeed,ignoreGuarantee);
    Collection<TempQueuePerPartition> underserved=getMostUnderservedQueues(orderedByNeed,tqComparator);
    for (Iterator<TempQueuePerPartition> i=underserved.iterator(); i.hasNext(); ) {
      TempQueuePerPartition sub=i.next();
      Resource wQavail=Resources.multiplyAndNormalizeUp(rc,unassigned,sub.normalizedGuarantee,Resource.newInstance(1,1));
      Resource wQidle=sub.offer(wQavail,rc,tot_guarant,isReservedPreemptionCandidatesSelector);
      Resource wQdone=Resources.subtract(wQavail,wQidle);
      if (Resources.greaterThan(rc,tot_guarant,wQdone,Resources.none())) {
        orderedByNeed.add(sub);
      }
      Resources.addTo(wQassigned,wQdone);
    }
    Resources.subtractFrom(unassigned,wQassigned);
  }
}
