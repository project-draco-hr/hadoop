{
  JobQueueInfo[] queues=TestQueueManagerRefresh.getSimpleQueueHierarchy();
  queues[0].getProperties().setProperty(CapacitySchedulerConf.CAPACITY_PROPERTY,String.valueOf(100));
  queues[1].getProperties().setProperty(CapacitySchedulerConf.CAPACITY_PROPERTY,String.valueOf(50));
  queues[2].getProperties().setProperty(CapacitySchedulerConf.CAPACITY_PROPERTY,String.valueOf(50));
  QueueManagerTestUtils.writeQueueConfigurationFile(queueConfigFile.getAbsolutePath(),new JobQueueInfo[]{queues[0]});
  setUp(1,4,4);
  taskTrackerManager.setQueueManager(new QueueManager());
  scheduler.start();
  try {
    taskTrackerManager.submitJobAndInit(JobStatus.PREP,20,0,queues[0].getQueueName(),"user");
    fail("Jobs are being able to be submitted to the container queue");
  }
 catch (  Exception e) {
    assertTrue(scheduler.getJobs(queues[0].getQueueName()).isEmpty());
  }
  FakeJobInProgress job=taskTrackerManager.submitJobAndInit(JobStatus.PREP,1,0,queues[1].getQueueName(),"user");
  assertEquals(1,scheduler.getJobs(queues[1].getQueueName()).size());
  assertTrue(scheduler.getJobs(queues[1].getQueueName()).contains(job));
  checkAssignment(taskTrackerManager,scheduler,"tt1","attempt_test_0002_m_000001_0 on tt1");
  HashMap<String,ArrayList<FakeJobInProgress>> subJobsList=taskTrackerManager.submitJobs(1,4,queues[2].getQueueName());
  JobQueuesManager mgr=scheduler.jobQueuesManager;
  raiseStatusChangeEvents(mgr,queues[2].getQueueName());
  Collection<JobInProgress> jobs=scheduler.getJobs(queues[2].getQueueName());
  assertTrue("Number of jobs returned by scheduler is wrong",jobs.size() == 4);
  assertTrue("Submitted jobs and Returned jobs are not same",subJobsList.get("u1").containsAll(jobs));
}
