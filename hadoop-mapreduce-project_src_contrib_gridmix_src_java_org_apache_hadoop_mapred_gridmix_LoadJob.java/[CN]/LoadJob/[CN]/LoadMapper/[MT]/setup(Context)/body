{
  final Configuration conf=ctxt.getConfiguration();
  final LoadSplit split=(LoadSplit)ctxt.getInputSplit();
  final int maps=split.getMapCount();
  final long[] reduceBytes=split.getOutputBytes();
  final long[] reduceRecords=split.getOutputRecords();
  final boolean emulateMapOutputCompression=CompressionEmulationUtil.isCompressionEmulationEnabled(conf) && conf.getBoolean(MRJobConfig.MAP_OUTPUT_COMPRESS,false);
  float compressionRatio=1.0f;
  if (emulateMapOutputCompression) {
    compressionRatio=CompressionEmulationUtil.getMapOutputCompressionEmulationRatio(conf);
    LOG.info("GridMix is configured to use a compression ratio of " + compressionRatio + " for the map output data.");
    key.setCompressibility(true,compressionRatio);
    val.setCompressibility(true,compressionRatio);
  }
  long totalRecords=0L;
  final int nReduces=ctxt.getNumReduceTasks();
  if (nReduces > 0) {
    int idx=0;
    int id=split.getId();
    for (int i=0; i < nReduces; ++i) {
      final GridmixKey.Spec spec=new GridmixKey.Spec();
      if (i == id) {
        spec.bytes_out=split.getReduceBytes(idx);
        spec.rec_out=split.getReduceRecords(idx);
        spec.setResourceUsageSpecification(split.getReduceResourceUsageMetrics(idx));
        ++idx;
        id+=maps;
      }
      long mapOutputBytes=reduceBytes[i];
      if (emulateMapOutputCompression) {
        mapOutputBytes/=compressionRatio;
      }
      reduces.add(new IntermediateRecordFactory(new AvgRecordFactory(mapOutputBytes,reduceRecords[i],conf,5 * 1024),i,reduceRecords[i],spec,conf));
      totalRecords+=reduceRecords[i];
    }
  }
 else {
    long mapOutputBytes=reduceBytes[0];
    if (emulateMapOutputCompression) {
      mapOutputBytes/=compressionRatio;
    }
    reduces.add(new AvgRecordFactory(mapOutputBytes,reduceRecords[0],conf,5 * 1024));
    totalRecords=reduceRecords[0];
  }
  final long splitRecords=split.getInputRecords();
  int missingRecSize=conf.getInt(AvgRecordFactory.GRIDMIX_MISSING_REC_SIZE,64 * 1024);
  final long inputRecords=(splitRecords <= 0 && split.getLength() >= 0) ? Math.max(1,split.getLength() / missingRecSize) : splitRecords;
  ratio=totalRecords / (1.0 * inputRecords);
  acc=0.0;
  matcher=new ResourceUsageMatcherRunner(ctxt,split.getMapResourceUsageMetrics());
  matcher.setDaemon(true);
  reporter=new StatusReporter(ctxt,matcher);
  reporter.setDaemon(true);
  reporter.start();
}
