{
  Configuration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    cluster.waitActive();
    NamenodeProtocols proto=cluster.getNameNodeRpc();
    proto.addCachePool(new CachePoolInfo("pool1"));
    proto.addCachePool(new CachePoolInfo("pool2"));
    proto.addCachePool(new CachePoolInfo("pool3"));
    proto.addCachePool(new CachePoolInfo("pool4").setMode(0));
    List<Fallible<PathCacheEntry>> addResults1=proto.addPathCacheDirectives(Arrays.asList(new PathCacheDirective[]{new PathCacheDirective("/alpha","pool1"),new PathCacheDirective("/beta","pool2"),new PathCacheDirective("","pool3"),new PathCacheDirective("/zeta","nonexistent_pool"),new PathCacheDirective("/zeta","pool4")}));
    long ids1[]=new long[2];
    ids1[0]=addResults1.get(0).get().getEntryId();
    ids1[1]=addResults1.get(1).get().getEntryId();
    try {
      addResults1.get(2).get();
      Assert.fail("expected an error when adding an empty path");
    }
 catch (    IOException ioe) {
      Assert.assertTrue(ioe.getCause() instanceof EmptyPathError);
    }
    try {
      addResults1.get(3).get();
      Assert.fail("expected an error when adding to a nonexistent pool.");
    }
 catch (    IOException ioe) {
      Assert.assertTrue(ioe.getCause() instanceof InvalidPoolNameError);
    }
    try {
      addResults1.get(4).get();
      Assert.fail("expected an error when adding to a pool with " + "mode 0 (no permissions for anyone).");
    }
 catch (    IOException ioe) {
      Assert.assertTrue(ioe.getCause() instanceof PoolWritePermissionDeniedError);
    }
    List<Fallible<PathCacheEntry>> addResults2=proto.addPathCacheDirectives(Arrays.asList(new PathCacheDirective[]{new PathCacheDirective("/alpha","pool1"),new PathCacheDirective("/theta",""),new PathCacheDirective("bogus","pool1"),new PathCacheDirective("/gamma","pool1")}));
    long id=addResults2.get(0).get().getEntryId();
    Assert.assertEquals("expected to get back the same ID as last time " + "when re-adding an existing path cache directive.",ids1[0],id);
    try {
      addResults2.get(1).get();
      Assert.fail("expected an error when adding a path cache " + "directive with an empty pool name.");
    }
 catch (    IOException ioe) {
      Assert.assertTrue(ioe.getCause() instanceof InvalidPoolNameError);
    }
    try {
      addResults2.get(2).get();
      Assert.fail("expected an error when adding a path cache " + "directive with a non-absolute path name.");
    }
 catch (    IOException ioe) {
      Assert.assertTrue(ioe.getCause() instanceof InvalidPathNameError);
    }
    long ids2[]=new long[1];
    ids2[0]=addResults2.get(3).get().getEntryId();
    RemoteIterator<PathCacheEntry> iter=proto.listPathCacheEntries(0,"",100);
    validateListAll(iter,ids1[0],ids1[1],ids2[0]);
    iter=proto.listPathCacheEntries(0,"",1);
    validateListAll(iter,ids1[0],ids1[1],ids2[0]);
    iter=proto.listPathCacheEntries(0,"pool3",1);
    Assert.assertFalse(iter.hasNext());
    iter=proto.listPathCacheEntries(0,"pool2",4444);
    Assert.assertEquals(addResults1.get(1).get(),iter.next());
    Assert.assertFalse(iter.hasNext());
    List<Fallible<Long>> removeResults1=proto.removePathCacheEntries(Arrays.asList(new Long[]{ids1[1],-42L,999999L}));
    Assert.assertEquals(Long.valueOf(ids1[1]),removeResults1.get(0).get());
    try {
      removeResults1.get(1).get();
      Assert.fail("expected an error when removing a negative ID");
    }
 catch (    IOException ioe) {
      Assert.assertTrue(ioe.getCause() instanceof InvalidIdException);
    }
    try {
      removeResults1.get(2).get();
      Assert.fail("expected an error when removing a nonexistent ID");
    }
 catch (    IOException ioe) {
      Assert.assertTrue(ioe.getCause() instanceof NoSuchIdException);
    }
    iter=proto.listPathCacheEntries(0,"pool2",4444);
    Assert.assertFalse(iter.hasNext());
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}
