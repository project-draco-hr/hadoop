{
  String planQueueName=plan.getQueueName();
  if (LOG.isDebugEnabled()) {
    LOG.debug("Running plan follower edit policy for plan: " + planQueueName);
  }
  long step=plan.getStep();
  long now=clock.getTime();
  if (now % step != 0) {
    now+=step - (now % step);
  }
  Queue planQueue=getPlanQueue(planQueueName);
  if (planQueue == null)   return;
  Resource clusterResources=scheduler.getClusterResource();
  Resource planResources=getPlanResources(plan,planQueue,clusterResources);
  Set<ReservationAllocation> currentReservations=plan.getReservationsAtTime(now);
  Set<String> curReservationNames=new HashSet<String>();
  Resource reservedResources=Resource.newInstance(0,0);
  int numRes=getReservedResources(now,currentReservations,curReservationNames,reservedResources);
  String defReservationId=getReservationIdFromQueueName(planQueueName) + ReservationConstants.DEFAULT_QUEUE_SUFFIX;
  String defReservationQueue=getReservationQueueName(planQueueName,defReservationId);
  createDefaultReservationQueue(planQueueName,planQueue,defReservationId);
  curReservationNames.add(defReservationId);
  if (arePlanResourcesLessThanReservations(clusterResources,planResources,reservedResources)) {
    try {
      plan.getReplanner().plan(plan,null);
    }
 catch (    PlanningException e) {
      LOG.warn("Exception while trying to replan: {}",planQueueName,e);
    }
  }
  List<? extends Queue> resQueues=getChildReservationQueues(planQueue);
  Set<String> expired=new HashSet<String>();
  for (  Queue resQueue : resQueues) {
    String resQueueName=resQueue.getQueueName();
    String reservationId=getReservationIdFromQueueName(resQueueName);
    if (curReservationNames.contains(reservationId)) {
      curReservationNames.remove(reservationId);
    }
 else {
      expired.add(reservationId);
    }
  }
  cleanupExpiredQueues(planQueueName,plan.getMoveOnExpiry(),expired,defReservationQueue);
  float totalAssignedCapacity=0f;
  if (currentReservations != null) {
    try {
      setQueueEntitlement(planQueueName,defReservationQueue,0f,1.0f);
    }
 catch (    YarnException e) {
      LOG.warn("Exception while trying to release default queue capacity for plan: {}",planQueueName,e);
    }
    List<ReservationAllocation> sortedAllocations=sortByDelta(new ArrayList<ReservationAllocation>(currentReservations),now,plan);
    for (    ReservationAllocation res : sortedAllocations) {
      String currResId=res.getReservationId().toString();
      if (curReservationNames.contains(currResId)) {
        addReservationQueue(planQueueName,planQueue,currResId);
      }
      Resource capToAssign=res.getResourcesAtTime(now);
      float targetCapacity=0f;
      if (planResources.getMemory() > 0 && planResources.getVirtualCores() > 0) {
        targetCapacity=calculateReservationToPlanRatio(clusterResources,planResources,capToAssign);
      }
      if (LOG.isDebugEnabled()) {
        LOG.debug("Assigning capacity of {} to queue {} with target capacity {}",capToAssign,currResId,targetCapacity);
      }
      float maxCapacity=1.0f;
      if (res.containsGangs()) {
        maxCapacity=targetCapacity;
      }
      try {
        setQueueEntitlement(planQueueName,currResId,targetCapacity,maxCapacity);
      }
 catch (      YarnException e) {
        LOG.warn("Exception while trying to size reservation for plan: {}",currResId,planQueueName,e);
      }
      totalAssignedCapacity+=targetCapacity;
    }
  }
  float defQCap=1.0f - totalAssignedCapacity;
  if (LOG.isDebugEnabled()) {
    LOG.debug("PlanFollowerEditPolicyTask: total Plan Capacity: {} " + "currReservation: {} default-queue capacity: {}",planResources,numRes,defQCap);
  }
  try {
    setQueueEntitlement(planQueueName,defReservationQueue,defQCap,1.0f);
  }
 catch (  YarnException e) {
    LOG.warn("Exception while trying to reclaim default queue capacity for plan: {}",planQueueName,e);
  }
  try {
    plan.archiveCompletedReservations(now);
  }
 catch (  PlanningException e) {
    LOG.error("Exception in archiving completed reservations: ",e);
  }
  LOG.info("Finished iteration of plan follower edit policy for plan: " + planQueueName);
}
