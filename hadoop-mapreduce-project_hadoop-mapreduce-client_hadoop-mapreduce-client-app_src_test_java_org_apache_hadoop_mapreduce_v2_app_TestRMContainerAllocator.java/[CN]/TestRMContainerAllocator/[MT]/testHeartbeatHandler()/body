{
  LOG.info("Running testHeartbeatHandler");
  Configuration conf=new Configuration();
  conf.setInt(MRJobConfig.MR_AM_TO_RM_HEARTBEAT_INTERVAL_MS,1);
  ControlledClock clock=new ControlledClock(new SystemClock());
  AppContext appContext=mock(AppContext.class);
  when(appContext.getClock()).thenReturn(clock);
  when(appContext.getApplicationID()).thenReturn(ApplicationId.newInstance(1,1));
  RMContainerAllocator allocator=new RMContainerAllocator(mock(ClientService.class),appContext){
    @Override protected void register(){
    }
    @Override protected ApplicationMasterProtocol createSchedulerProxy(){
      return mock(ApplicationMasterProtocol.class);
    }
    @Override protected synchronized void heartbeat() throws Exception {
    }
  }
;
  allocator.init(conf);
  allocator.start();
  clock.setTime(5);
  int timeToWaitMs=5000;
  while (allocator.getLastHeartbeatTime() != 5 && timeToWaitMs > 0) {
    Thread.sleep(10);
    timeToWaitMs-=10;
  }
  Assert.assertEquals(5,allocator.getLastHeartbeatTime());
  clock.setTime(7);
  timeToWaitMs=5000;
  while (allocator.getLastHeartbeatTime() != 7 && timeToWaitMs > 0) {
    Thread.sleep(10);
    timeToWaitMs-=10;
  }
  Assert.assertEquals(7,allocator.getLastHeartbeatTime());
  final AtomicBoolean callbackCalled=new AtomicBoolean(false);
  allocator.runOnNextHeartbeat(new Runnable(){
    @Override public void run(){
      callbackCalled.set(true);
    }
  }
);
  clock.setTime(8);
  timeToWaitMs=5000;
  while (allocator.getLastHeartbeatTime() != 8 && timeToWaitMs > 0) {
    Thread.sleep(10);
    timeToWaitMs-=10;
  }
  Assert.assertEquals(8,allocator.getLastHeartbeatTime());
  Assert.assertTrue(callbackCalled.get());
}
