{
  final FsPermission storeDirPerms=new FsPermission((short)0700);
  Path stateStoreRoot=null;
  FileSystem stateStoreFs=null;
  boolean recoveryEnabled=conf.getBoolean(YarnConfiguration.NM_RECOVERY_ENABLED,YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);
  if (recoveryEnabled) {
    stateStoreRoot=new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),STATE_STORE_ROOT_NAME);
    stateStoreFs=FileSystem.getLocal(conf);
  }
  Collection<String> auxNames=conf.getStringCollection(YarnConfiguration.NM_AUX_SERVICES);
  for (  final String sName : auxNames) {
    try {
      Preconditions.checkArgument(validateAuxServiceName(sName),"The ServiceName: " + sName + " set in "+ YarnConfiguration.NM_AUX_SERVICES+ " is invalid."+ "The valid service name should only contain a-zA-Z0-9_ "+ "and can not start with numbers");
      Class<? extends AuxiliaryService> sClass=conf.getClass(String.format(YarnConfiguration.NM_AUX_SERVICE_FMT,sName),null,AuxiliaryService.class);
      if (null == sClass) {
        throw new RuntimeException("No class defined for " + sName);
      }
      AuxiliaryService s=ReflectionUtils.newInstance(sClass,conf);
      if (!sName.equals(s.getName())) {
        LOG.warn("The Auxilurary Service named '" + sName + "' in the "+ "configuration is for class "+ sClass+ " which has "+ "a name of '"+ s.getName()+ "'. Because these are "+ "not the same tools trying to send ServiceData and read "+ "Service Meta Data may have issues unless the refer to "+ "the name in the config.");
      }
      addService(sName,s);
      if (recoveryEnabled) {
        Path storePath=new Path(stateStoreRoot,sName);
        stateStoreFs.mkdirs(storePath,storeDirPerms);
        s.setRecoveryPath(storePath);
      }
      s.init(conf);
    }
 catch (    RuntimeException e) {
      LOG.fatal("Failed to initialize " + sName,e);
      throw e;
    }
  }
  super.serviceInit(conf);
}
