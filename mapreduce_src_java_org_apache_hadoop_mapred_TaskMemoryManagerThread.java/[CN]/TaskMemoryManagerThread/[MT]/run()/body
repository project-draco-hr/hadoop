{
  LOG.info("Starting thread: " + this.getClass());
  while (true) {
    if (LOG.isDebugEnabled()) {
      StringBuffer tmp=new StringBuffer("[ ");
      for (      ProcessTreeInfo p : processTreeInfoMap.values()) {
        tmp.append(p.getPID());
        tmp.append(" ");
      }
      LOG.debug("Current ProcessTree list : " + tmp.substring(0,tmp.length()) + "]");
    }
synchronized (tasksToBeAdded) {
      processTreeInfoMap.putAll(tasksToBeAdded);
      tasksToBeAdded.clear();
    }
synchronized (tasksToBeRemoved) {
      for (      TaskAttemptID tid : tasksToBeRemoved) {
        processTreeInfoMap.remove(tid);
      }
      tasksToBeRemoved.clear();
    }
    long memoryStillInUsage=0;
    long rssMemoryStillInUsage=0;
    for (Iterator<Map.Entry<TaskAttemptID,ProcessTreeInfo>> it=processTreeInfoMap.entrySet().iterator(); it.hasNext(); ) {
      Map.Entry<TaskAttemptID,ProcessTreeInfo> entry=it.next();
      TaskAttemptID tid=entry.getKey();
      ProcessTreeInfo ptInfo=entry.getValue();
      try {
        String pId=ptInfo.getPID();
        if (pId == null) {
          pId=taskTracker.getPid(ptInfo.getTID());
          if (pId != null) {
            long sleeptimeBeforeSigkill=taskTracker.getJobConf().getLong(TTConfig.TT_SLEEP_TIME_BEFORE_SIG_KILL,ProcessTree.DEFAULT_SLEEPTIME_BEFORE_SIGKILL);
            ProcfsBasedProcessTree pt=new ProcfsBasedProcessTree(pId,ProcessTree.isSetsidAvailable,sleeptimeBeforeSigkill);
            LOG.debug("Tracking ProcessTree " + pId + " for the first time");
            ptInfo.setPid(pId);
            ptInfo.setProcessTree(pt);
          }
        }
        if (pId == null) {
          continue;
        }
        if (taskTracker.runningTasks.get(tid).wasKilled()) {
          continue;
        }
        LOG.debug("Constructing ProcessTree for : PID = " + pId + " TID = "+ tid);
        ProcfsBasedProcessTree pTree=ptInfo.getProcessTree();
        pTree=pTree.getProcessTree();
        ptInfo.setProcessTree(pTree);
        long currentMemUsage=pTree.getCumulativeVmem();
        long currentRssMemUsage=pTree.getCumulativeRssmem();
        long curMemUsageOfAgedProcesses=pTree.getCumulativeVmem(1);
        long curRssMemUsageOfAgedProcesses=pTree.getCumulativeRssmem(1);
        long limit=ptInfo.getMemLimit();
        long limitPhysical=ptInfo.getMemLimitPhysical();
        LOG.info(String.format(MEMORY_USAGE_STRING,pId,tid.toString(),currentMemUsage,limit,currentRssMemUsage,limitPhysical));
        boolean isMemoryOverLimit=false;
        String msg="";
        if (doCheckVirtualMemory() && isProcessTreeOverLimit(tid.toString(),currentMemUsage,curMemUsageOfAgedProcesses,limit)) {
          msg="TaskTree [pid=" + pId + ",tipID="+ tid+ "] is running beyond memory-limits. Current usage : "+ currentMemUsage+ "bytes. Limit : "+ limit+ "bytes. Killing task. \nDump of the process-tree for "+ tid+ " : \n"+ pTree.getProcessTreeDump();
          isMemoryOverLimit=true;
        }
 else         if (doCheckPhysicalMemory() && isProcessTreeOverLimit(tid.toString(),currentRssMemUsage,curRssMemUsageOfAgedProcesses,limitPhysical)) {
          msg="TaskTree [pid=" + pId + ",tipID="+ tid+ "] is running beyond physical memory-limits."+ " Current usage : "+ currentRssMemUsage+ "bytes. Limit : "+ limitPhysical+ "bytes. Killing task. \nDump of the process-tree for "+ tid+ " : \n"+ pTree.getProcessTreeDump();
          isMemoryOverLimit=true;
        }
        if (isMemoryOverLimit) {
          LOG.warn(msg);
          taskTracker.cleanUpOverMemoryTask(tid,true,msg);
          pTree.destroy(true);
          it.remove();
          LOG.info("Removed ProcessTree with root " + pId);
        }
 else {
          memoryStillInUsage+=currentMemUsage;
          rssMemoryStillInUsage+=currentRssMemUsage;
        }
      }
 catch (      Exception e) {
        LOG.warn("Uncaught exception in TaskMemoryManager " + "while managing memory of " + tid + " : "+ StringUtils.stringifyException(e));
      }
    }
    if (doCheckVirtualMemory() && memoryStillInUsage > maxMemoryAllowedForAllTasks) {
      LOG.warn("The total memory in usage " + memoryStillInUsage + " is still overflowing TTs limits "+ maxMemoryAllowedForAllTasks+ ". Trying to kill a few tasks with the least progress.");
      killTasksWithLeastProgress(memoryStillInUsage);
    }
    if (doCheckPhysicalMemory() && rssMemoryStillInUsage > maxRssMemoryAllowedForAllTasks) {
      LOG.warn("The total physical memory in usage " + rssMemoryStillInUsage + " is still overflowing TTs limits "+ maxRssMemoryAllowedForAllTasks+ ". Trying to kill a few tasks with the highest memory.");
      killTasksWithMaxRssMemory(rssMemoryStillInUsage);
    }
    try {
      LOG.debug(this.getClass() + " : Sleeping for " + monitoringInterval+ " ms");
      Thread.sleep(monitoringInterval);
    }
 catch (    InterruptedException ie) {
      LOG.warn(this.getClass() + " interrupted. Finishing the thread and returning.");
      return;
    }
  }
}
