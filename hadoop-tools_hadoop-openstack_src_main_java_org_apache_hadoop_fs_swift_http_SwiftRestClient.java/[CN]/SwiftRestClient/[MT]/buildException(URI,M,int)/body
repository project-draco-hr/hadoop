{
  IOException fault;
  String errorMessage=String.format("Method %s on %s failed, status code: %d," + " status line: %s",method.getName(),uri,statusCode,method.getStatusLine());
  if (LOG.isDebugEnabled()) {
    LOG.debug(errorMessage);
  }
switch (statusCode) {
case SC_NOT_FOUND:
    fault=new FileNotFoundException("Operation " + method.getName() + " on "+ uri);
  break;
case SC_BAD_REQUEST:
fault=new SwiftBadRequestException("Bad request against " + uri,method.getName(),uri,method);
break;
case SC_REQUESTED_RANGE_NOT_SATISFIABLE:
StringBuilder errorText=new StringBuilder(method.getStatusText());
Header requestContentLen=method.getRequestHeader(HEADER_CONTENT_LENGTH);
if (requestContentLen != null) {
errorText.append(" requested ").append(requestContentLen.getValue());
}
Header availableContentRange=method.getResponseHeader(HEADER_CONTENT_RANGE);
if (availableContentRange != null) {
errorText.append(" available ").append(availableContentRange.getValue());
}
fault=new EOFException(errorText.toString());
break;
case SC_UNAUTHORIZED:
fault=new SwiftAuthenticationFailedException("Operation not authorized- current access token =" + getToken(),method.getName(),uri,method);
break;
case SwiftProtocolConstants.SC_TOO_MANY_REQUESTS_429:
case SwiftProtocolConstants.SC_THROTTLED_498:
fault=new SwiftThrottledRequestException("Client is being throttled: too many requests",method.getName(),uri,method);
break;
default :
fault=new SwiftInvalidResponseException(errorMessage,method.getName(),uri,method);
}
return fault;
}
