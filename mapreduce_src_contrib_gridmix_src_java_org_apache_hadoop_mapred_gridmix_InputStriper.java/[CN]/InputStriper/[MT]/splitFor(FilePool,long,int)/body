{
  final ArrayList<Path> paths=new ArrayList<Path>();
  final ArrayList<Long> start=new ArrayList<Long>();
  final ArrayList<Long> length=new ArrayList<Long>();
  final HashMap<String,Double> sb=new HashMap<String,Double>();
  do {
    paths.add(current.getPath());
    start.add(currentStart);
    final long fromFile=Math.min(bytes,current.getLen() - currentStart);
    length.add(fromFile);
    for (    BlockLocation loc : inputDir.locationsFor(current,currentStart,fromFile)) {
      final double tedium=loc.getLength() / (1.0 * bytes);
      for (      String l : loc.getHosts()) {
        Double j=sb.get(l);
        if (null == j) {
          sb.put(l,tedium);
        }
 else {
          sb.put(l,j.doubleValue() + tedium);
        }
      }
    }
    currentStart+=fromFile;
    bytes-=fromFile;
    CompressionCodecFactory compressionCodecs=new CompressionCodecFactory(conf);
    CompressionCodec codec=compressionCodecs.getCodec(current.getPath());
    if (current.getLen() - currentStart == 0 || codec != null) {
      current=files.get(++idx % files.size());
      currentStart=0;
    }
  }
 while (bytes > 0);
  final ArrayList<Entry<String,Double>> sort=new ArrayList<Entry<String,Double>>(sb.entrySet());
  Collections.sort(sort,hostRank);
  final String[] hosts=new String[Math.min(nLocs,sort.size())];
  for (int i=0; i < nLocs && i < sort.size(); ++i) {
    hosts[i]=sort.get(i).getKey();
  }
  return new CombineFileSplit(paths.toArray(new Path[0]),toLongArray(start),toLongArray(length),hosts);
}
