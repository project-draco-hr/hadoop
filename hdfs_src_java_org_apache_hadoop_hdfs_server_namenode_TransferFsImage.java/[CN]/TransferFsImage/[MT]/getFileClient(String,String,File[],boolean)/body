{
  byte[] buf=new byte[BUFFER_SIZE];
  String proto=UserGroupInformation.isSecurityEnabled() ? "https://" : "http://";
  StringBuilder str=new StringBuilder(proto + fsName + "/getimage?");
  str.append(id);
  URL url=new URL(str.toString());
  SecurityUtil.fetchServiceTicket(url);
  URLConnection connection=url.openConnection();
  long advertisedSize;
  String contentLength=connection.getHeaderField(CONTENT_LENGTH);
  if (contentLength != null) {
    advertisedSize=Long.parseLong(contentLength);
  }
 else {
    throw new IOException(CONTENT_LENGTH + " header is not provided " + "by the namenode when trying to fetch "+ str);
  }
  long received=0;
  InputStream stream=connection.getInputStream();
  MessageDigest digester=null;
  if (getChecksum) {
    digester=MD5Hash.getDigester();
    stream=new DigestInputStream(stream,digester);
  }
  FileOutputStream[] output=null;
  boolean finishedReceiving=false;
  try {
    if (localPath != null) {
      output=new FileOutputStream[localPath.length];
      for (int i=0; i < output.length; i++) {
        output[i]=new FileOutputStream(localPath[i]);
      }
    }
    int num=1;
    while (num > 0) {
      num=stream.read(buf);
      if (num > 0 && localPath != null) {
        received+=num;
        for (int i=0; i < output.length; i++) {
          output[i].write(buf,0,num);
        }
      }
    }
    finishedReceiving=true;
  }
  finally {
    stream.close();
    if (output != null) {
      for (int i=0; i < output.length; i++) {
        if (output[i] != null) {
          output[i].getChannel().force(true);
          output[i].close();
        }
      }
    }
    if (finishedReceiving && received != advertisedSize) {
      throw new IOException("File " + str + " received length "+ received+ " is not of the advertised size "+ advertisedSize);
    }
  }
  return digester == null ? null : new MD5Hash(digester.digest());
}
