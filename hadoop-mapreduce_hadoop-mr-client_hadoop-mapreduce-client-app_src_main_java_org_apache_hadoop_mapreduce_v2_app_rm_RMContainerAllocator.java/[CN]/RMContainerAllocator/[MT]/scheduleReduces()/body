{
  if (pendingReduces.size() == 0) {
    return;
  }
  LOG.info("Recalculating schedule...");
  if (scheduledRequests.maps.size() == 0 && pendingReduces.size() > 0) {
    LOG.info("All maps assigned. Ramping up all remaining reduces:" + pendingReduces.size());
    for (    ContainerRequest req : pendingReduces) {
      scheduledRequests.addReduce(req);
    }
    pendingReduces.clear();
    return;
  }
  int totalMaps=assignedRequests.maps.size() + completedMaps + scheduledRequests.maps.size();
  if (!reduceStarted) {
    int completedMapsForReduceSlowstart=(int)Math.ceil(reduceSlowStart * totalMaps);
    if (completedMaps < completedMapsForReduceSlowstart) {
      LOG.info("Reduce slow start threshold not met. " + "completedMapsForReduceSlowstart " + completedMapsForReduceSlowstart);
      return;
    }
 else {
      LOG.info("Reduce slow start threshold reached. Scheduling reduces.");
      reduceStarted=true;
    }
  }
  float completedMapPercent=0f;
  if (totalMaps != 0) {
    completedMapPercent=(float)completedMaps / totalMaps;
  }
 else {
    completedMapPercent=1;
  }
  int netScheduledMapMem=scheduledRequests.maps.size() * mapResourceReqt + assignedRequests.maps.size() * mapResourceReqt;
  int netScheduledReduceMem=scheduledRequests.reduces.size() * reduceResourceReqt + assignedRequests.reduces.size() * reduceResourceReqt;
  int finalMapMemLimit=0;
  int finalReduceMemLimit=0;
  int totalMemLimit=getMemLimit();
  int idealReduceMemLimit=Math.min((int)(completedMapPercent * totalMemLimit),(int)(maxReduceRampupLimit * totalMemLimit));
  int idealMapMemLimit=totalMemLimit - idealReduceMemLimit;
  if (idealMapMemLimit > netScheduledMapMem) {
    int unusedMapMemLimit=idealMapMemLimit - netScheduledMapMem;
    finalReduceMemLimit=idealReduceMemLimit + unusedMapMemLimit;
    finalMapMemLimit=totalMemLimit - finalReduceMemLimit;
  }
 else {
    finalMapMemLimit=idealMapMemLimit;
    finalReduceMemLimit=idealReduceMemLimit;
  }
  LOG.info("completedMapPercent " + completedMapPercent + " totalMemLimit:"+ totalMemLimit+ " finalMapMemLimit:"+ finalMapMemLimit+ " finalReduceMemLimit:"+ finalReduceMemLimit+ " netScheduledMapMem:"+ netScheduledMapMem+ " netScheduledReduceMem:"+ netScheduledReduceMem);
  int rampUp=(finalReduceMemLimit - netScheduledReduceMem) / reduceResourceReqt;
  if (rampUp > 0) {
    rampUp=Math.min(rampUp,pendingReduces.size());
    LOG.info("Ramping up " + rampUp);
    for (int i=0; i < rampUp; i++) {
      ContainerRequest request=pendingReduces.removeFirst();
      scheduledRequests.addReduce(request);
    }
  }
 else   if (rampUp < 0) {
    int rampDown=-1 * rampUp;
    rampDown=Math.min(rampDown,scheduledRequests.reduces.size());
    LOG.info("Ramping down " + rampDown);
    for (int i=0; i < rampDown; i++) {
      ContainerRequest request=scheduledRequests.removeReduce();
      pendingReduces.add(request);
    }
  }
}
