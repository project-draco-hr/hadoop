{
  if (socket != null || shouldCloseConnection.get()) {
    return;
  }
  short ioFailures=0;
  short timeoutFailures=0;
  try {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Connecting to " + server);
    }
    while (true) {
      try {
        this.socket=socketFactory.createSocket();
        this.socket.setTcpNoDelay(tcpNoDelay);
        NetUtils.connect(this.socket,remoteId.getAddress(),20000);
        this.socket.setSoTimeout(pingInterval);
        break;
      }
 catch (      SocketTimeoutException toe) {
        handleConnectionFailure(timeoutFailures++,45,toe);
      }
catch (      IOException ie) {
        handleConnectionFailure(ioFailures++,maxRetries,ie);
      }
    }
    InputStream inStream=NetUtils.getInputStream(socket);
    OutputStream outStream=NetUtils.getOutputStream(socket);
    writeRpcHeader(outStream);
    if (useSasl) {
      final InputStream in2=inStream;
      final OutputStream out2=outStream;
      UserGroupInformation ticket=remoteId.getTicket();
      if (authMethod == AuthMethod.KERBEROS) {
        if (ticket.getRealUser() != null) {
          ticket=ticket.getRealUser();
        }
      }
      if (ticket.doAs(new PrivilegedExceptionAction<Boolean>(){
        @Override public Boolean run() throws IOException {
          return setupSaslConnection(in2,out2);
        }
      }
)) {
        inStream=saslRpcClient.getInputStream(inStream);
        outStream=saslRpcClient.getOutputStream(outStream);
      }
 else {
        authMethod=AuthMethod.SIMPLE;
        header=new ConnectionHeader(header.getProtocol(),header.getUgi(),authMethod);
        useSasl=false;
      }
    }
    if (doPing) {
      this.in=new DataInputStream(new BufferedInputStream(new PingInputStream(inStream)));
    }
 else {
      this.in=new DataInputStream(new BufferedInputStream(inStream));
    }
    this.out=new DataOutputStream(new BufferedOutputStream(outStream));
    writeHeader();
    touch();
    start();
  }
 catch (  IOException e) {
    markClosed(e);
    close();
  }
}
