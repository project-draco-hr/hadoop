{
  file.setAccessTime(atime);
  file.setModificationTimeForce(mtime);
  BlockInfo[] oldBlocks=file.getBlocks();
  boolean isGenStampUpdate=oldBlocks.length == blocks.length;
  BlockInfo oldBlock=null;
  for (int i=0; i < oldBlocks.length && i < blocks.length; i++) {
    oldBlock=oldBlocks[i];
    Block newBlock=blocks[i];
    boolean isLastBlock=i == oldBlocks.length - 1;
    if (oldBlock.getBlockId() != newBlock.getBlockId() || (oldBlock.getGenerationStamp() != newBlock.getGenerationStamp() && !(isGenStampUpdate && isLastBlock))) {
      throw new IOException("Mismatched block IDs or generation stamps, " + "attempting to replace block " + oldBlock + " with "+ newBlock+ " as block # "+ i+ "/"+ blocks.length+ " of "+ path);
    }
    oldBlock.setNumBytes(newBlock.getNumBytes());
    oldBlock.setGenerationStamp(newBlock.getGenerationStamp());
  }
  if (blocks.length < oldBlocks.length) {
    if (!file.isUnderConstruction()) {
      throw new IOException("Trying to remove a block from file " + path + " which is not under construction.");
    }
    if (blocks.length != oldBlocks.length - 1) {
      throw new IOException("Trying to remove more than one block from file " + path);
    }
    unprotectedRemoveBlock(path,(INodeFileUnderConstruction)file,oldBlocks[oldBlocks.length - 1]);
  }
 else   if (blocks.length > oldBlocks.length) {
    getBlockManager().completeBlock(file,oldBlocks.length - 1,true);
    for (int i=oldBlocks.length; i < blocks.length; i++) {
      BlockInfo newBI=blocks[i];
      getBlockManager().addINode(newBI,file);
      file.addBlock(newBI);
    }
  }
}
