{
  if (NameNode.stateChangeLog.isDebugEnabled()) {
    NameNode.stateChangeLog.debug("DIR* FSDirectory.delete: " + src);
  }
  waitForReady();
  long now=now();
  int filesRemoved;
  writeLock();
  try {
    final INodesInPath inodesInPath=rootDir.getMutableINodesInPath(normalizePath(src),false);
    final INode[] inodes=inodesInPath.getINodes();
    if (checkPathINodes(inodes,src) == 0) {
      filesRemoved=0;
    }
 else {
      INode targetNode=inodes[inodes.length - 1];
      List<INodeDirectorySnapshottable> snapshottableDirs=new ArrayList<INodeDirectorySnapshottable>();
      INode snapshotNode=hasSnapshot(targetNode,snapshottableDirs);
      if (snapshotNode != null) {
        throw new IOException("The direcotry " + targetNode.getFullPathName() + " cannot be deleted since "+ snapshotNode.getFullPathName()+ " is snapshottable and already has snapshots");
      }
      filesRemoved=unprotectedDelete(inodesInPath,collectedBlocks,now);
      if (snapshottableDirs.size() > 0) {
        namesystem.removeSnapshottableDirs(snapshottableDirs);
      }
    }
  }
  finally {
    writeUnlock();
  }
  fsImage.getEditLog().logDelete(src,now);
  if (filesRemoved <= 0) {
    return false;
  }
  incrDeletedFileCount(filesRemoved);
  getFSNamesystem().removePathAndBlocks(src,null);
  return true;
}
