{
  String srcs=normalizePath(src);
  readLock();
  try {
    if (srcs.endsWith(HdfsConstants.SEPARATOR_DOT_SNAPSHOT_DIR)) {
      return getSnapshotsListing(srcs,startAfter);
    }
    final INodesInPath inodesInPath=getLastINodeInPath(srcs,true);
    final int snapshot=inodesInPath.getPathSnapshotId();
    final INode targetNode=inodesInPath.getINode(0);
    if (targetNode == null)     return null;
    if (!targetNode.isDirectory()) {
      return new DirectoryListing(new HdfsFileStatus[]{createFileStatus(HdfsFileStatus.EMPTY_NAME,targetNode,needLocation,snapshot)},0);
    }
    final INodeDirectory dirInode=targetNode.asDirectory();
    final ReadOnlyList<INode> contents=dirInode.getChildrenList(snapshot);
    int startChild=INodeDirectory.nextChild(contents,startAfter);
    int totalNumChildren=contents.size();
    int numOfListing=Math.min(totalNumChildren - startChild,this.lsLimit);
    int locationBudget=this.lsLimit;
    int listingCnt=0;
    HdfsFileStatus listing[]=new HdfsFileStatus[numOfListing];
    for (int i=0; i < numOfListing && locationBudget > 0; i++) {
      INode cur=contents.get(startChild + i);
      listing[i]=createFileStatus(cur.getLocalNameBytes(),cur,needLocation,snapshot);
      listingCnt++;
      if (needLocation) {
        LocatedBlocks blks=((HdfsLocatedFileStatus)listing[i]).getBlockLocations();
        locationBudget-=(blks == null) ? 0 : blks.locatedBlockCount() * listing[i].getReplication();
      }
    }
    if (listingCnt < numOfListing) {
      listing=Arrays.copyOf(listing,listingCnt);
    }
    return new DirectoryListing(listing,totalNumChildren - startChild - listingCnt);
  }
  finally {
    readUnlock();
  }
}
