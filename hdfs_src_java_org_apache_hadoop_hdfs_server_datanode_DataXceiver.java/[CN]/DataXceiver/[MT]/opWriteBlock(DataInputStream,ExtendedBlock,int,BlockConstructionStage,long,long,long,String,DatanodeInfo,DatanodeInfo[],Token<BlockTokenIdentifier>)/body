{
  updateCurrentThreadName("Receiving block " + block + " client="+ clientname);
  final boolean isDatanode=clientname.length() == 0;
  final boolean isClient=!isDatanode;
  final boolean isTransfer=stage == BlockConstructionStage.TRANSFER_RBW || stage == BlockConstructionStage.TRANSFER_FINALIZED;
  if (isTransfer && targets.length > 0) {
    throw new IOException(stage + " does not support multiple targets " + Arrays.asList(targets));
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("opWriteBlock: stage=" + stage + ", clientname="+ clientname+ "\n  block  ="+ block+ ", newGs="+ newGs+ ", bytesRcvd=["+ minBytesRcvd+ ", "+ maxBytesRcvd+ "]"+ "\n  targets="+ Arrays.asList(targets)+ "; pipelineSize="+ pipelineSize+ ", srcDataNode="+ srcDataNode);
    LOG.debug("isDatanode=" + isDatanode + ", isClient="+ isClient+ ", isTransfer="+ isTransfer);
    LOG.debug("writeBlock receive buf size " + s.getReceiveBufferSize() + " tcp no delay "+ s.getTcpNoDelay());
  }
  final ExtendedBlock originalBlock=new ExtendedBlock(block);
  block.setNumBytes(dataXceiverServer.estimateBlockSize);
  LOG.info("Receiving block " + block + " src: "+ remoteAddress+ " dest: "+ localAddress);
  final DataOutputStream replyOut=new DataOutputStream(new BufferedOutputStream(NetUtils.getOutputStream(s,datanode.socketWriteTimeout),SMALL_BUFFER_SIZE));
  checkAccess(replyOut,isClient,block,blockToken,Op.WRITE_BLOCK,BlockTokenSecretManager.AccessMode.WRITE);
  DataOutputStream mirrorOut=null;
  DataInputStream mirrorIn=null;
  Socket mirrorSock=null;
  BlockReceiver blockReceiver=null;
  String mirrorNode=null;
  String firstBadLink="";
  Status mirrorInStatus=SUCCESS;
  try {
    if (isDatanode || stage != BlockConstructionStage.PIPELINE_CLOSE_RECOVERY) {
      blockReceiver=new BlockReceiver(block,in,s.getRemoteSocketAddress().toString(),s.getLocalSocketAddress().toString(),stage,newGs,minBytesRcvd,maxBytesRcvd,clientname,srcDataNode,datanode);
    }
 else {
      datanode.data.recoverClose(block,newGs,minBytesRcvd);
    }
    if (targets.length > 0) {
      InetSocketAddress mirrorTarget=null;
      mirrorNode=targets[0].getName();
      mirrorTarget=NetUtils.createSocketAddr(mirrorNode);
      mirrorSock=datanode.newSocket();
      try {
        int timeoutValue=datanode.socketTimeout + (HdfsConstants.READ_TIMEOUT_EXTENSION * targets.length);
        int writeTimeout=datanode.socketWriteTimeout + (HdfsConstants.WRITE_TIMEOUT_EXTENSION * targets.length);
        NetUtils.connect(mirrorSock,mirrorTarget,timeoutValue);
        mirrorSock.setSoTimeout(timeoutValue);
        mirrorSock.setSendBufferSize(DEFAULT_DATA_SOCKET_SIZE);
        mirrorOut=new DataOutputStream(new BufferedOutputStream(NetUtils.getOutputStream(mirrorSock,writeTimeout),SMALL_BUFFER_SIZE));
        mirrorIn=new DataInputStream(NetUtils.getInputStream(mirrorSock));
        Sender.opWriteBlock(mirrorOut,originalBlock,pipelineSize,stage,newGs,minBytesRcvd,maxBytesRcvd,clientname,srcDataNode,targets,blockToken);
        if (blockReceiver != null) {
          blockReceiver.writeChecksumHeader(mirrorOut);
        }
        mirrorOut.flush();
        if (isClient) {
          BlockOpResponseProto connectAck=BlockOpResponseProto.parseFrom(HdfsProtoUtil.vintPrefixed(mirrorIn));
          mirrorInStatus=connectAck.getStatus();
          firstBadLink=connectAck.getFirstBadLink();
          if (LOG.isDebugEnabled() || mirrorInStatus != SUCCESS) {
            LOG.info("Datanode " + targets.length + " got response for connect ack "+ " from downstream datanode with firstbadlink as "+ firstBadLink);
          }
        }
      }
 catch (      IOException e) {
        if (isClient) {
          BlockOpResponseProto.newBuilder().setStatus(ERROR).setFirstBadLink(mirrorNode).build().writeDelimitedTo(replyOut);
          replyOut.flush();
        }
        IOUtils.closeStream(mirrorOut);
        mirrorOut=null;
        IOUtils.closeStream(mirrorIn);
        mirrorIn=null;
        IOUtils.closeSocket(mirrorSock);
        mirrorSock=null;
        if (isClient) {
          throw e;
        }
 else {
          LOG.info(datanode + ":Exception transfering block " + block+ " to mirror "+ mirrorNode+ ". continuing without the mirror.\n"+ StringUtils.stringifyException(e));
        }
      }
    }
    if (isClient && !isTransfer) {
      if (LOG.isDebugEnabled() || mirrorInStatus != SUCCESS) {
        LOG.info("Datanode " + targets.length + " forwarding connect ack to upstream firstbadlink is "+ firstBadLink);
      }
      BlockOpResponseProto.newBuilder().setStatus(mirrorInStatus).setFirstBadLink(firstBadLink).build().writeDelimitedTo(replyOut);
      replyOut.flush();
    }
    if (blockReceiver != null) {
      String mirrorAddr=(mirrorSock == null) ? null : mirrorNode;
      blockReceiver.receiveBlock(mirrorOut,mirrorIn,replyOut,mirrorAddr,null,targets);
      if (isTransfer) {
        if (LOG.isTraceEnabled()) {
          LOG.trace("TRANSFER: send close-ack");
        }
        writeResponse(SUCCESS,replyOut);
      }
    }
    if (isClient && stage == BlockConstructionStage.PIPELINE_CLOSE_RECOVERY) {
      block.setGenerationStamp(newGs);
      block.setNumBytes(minBytesRcvd);
    }
    if (isDatanode || stage == BlockConstructionStage.PIPELINE_CLOSE_RECOVERY) {
      datanode.closeBlock(block,DataNode.EMPTY_DEL_HINT);
      LOG.info("Received block " + block + " src: "+ remoteAddress+ " dest: "+ localAddress+ " of size "+ block.getNumBytes());
    }
  }
 catch (  IOException ioe) {
    LOG.info("writeBlock " + block + " received exception "+ ioe);
    throw ioe;
  }
 finally {
    IOUtils.closeStream(mirrorOut);
    IOUtils.closeStream(mirrorIn);
    IOUtils.closeStream(replyOut);
    IOUtils.closeSocket(mirrorSock);
    IOUtils.closeStream(blockReceiver);
  }
  datanode.metrics.addWriteBlockOp(elapsed());
  datanode.metrics.incrWritesFromClient(isLocal);
}
