{
  CapacitySchedulerConfiguration csConf=new CapacitySchedulerConfiguration();
  YarnConfiguration conf=new YarnConfiguration();
  setupQueueConfiguration(csConf);
  CapacitySchedulerContext csContext=mock(CapacitySchedulerContext.class);
  when(csContext.getConfiguration()).thenReturn(csConf);
  when(csContext.getConf()).thenReturn(conf);
  when(csContext.getMinimumResourceCapability()).thenReturn(Resources.createResource(GB));
  when(csContext.getMaximumResourceCapability()).thenReturn(Resources.createResource(16 * GB));
  when(csContext.getClusterResources()).thenReturn(Resources.createResource(10 * 16 * GB));
  Map<String,CSQueue> queues=new HashMap<String,CSQueue>();
  CSQueue root=CapacityScheduler.parseQueue(csContext,csConf,null,"root",queues,queues,CapacityScheduler.queueComparator,CapacityScheduler.applicationComparator,TestUtils.spyHook);
  queue=spy(new LeafQueue(csContext,A,root,CapacityScheduler.applicationComparator,null));
  doReturn(true).when(queue).hasAccess(any(QueueACL.class),any(UserGroupInformation.class));
  doReturn(100).when(queue).getMaxApplications();
  doReturn(25).when(queue).getMaxApplicationsPerUser();
  doReturn(10).when(queue).getMaximumActiveApplications();
  doReturn(2).when(queue).getMaximumActiveApplicationsPerUser();
}
