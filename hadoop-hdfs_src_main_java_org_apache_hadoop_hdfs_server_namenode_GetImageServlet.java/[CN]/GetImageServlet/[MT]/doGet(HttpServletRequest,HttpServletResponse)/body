{
  try {
    ServletContext context=getServletContext();
    final FSImage nnImage=NameNodeHttpServer.getFsImageFromContext(context);
    final GetImageParams parsedParams=new GetImageParams(request,response);
    final Configuration conf=(Configuration)getServletContext().getAttribute(JspHelper.CURRENT_CONF);
    if (UserGroupInformation.isSecurityEnabled() && !isValidRequestor(request.getRemoteUser(),conf)) {
      response.sendError(HttpServletResponse.SC_FORBIDDEN,"Only Namenode and Secondary Namenode may access this servlet");
      LOG.warn("Received non-NN/SNN request for image or edits from " + request.getRemoteHost());
      return;
    }
    String myStorageInfoString=nnImage.getStorage().toColonSeparatedString();
    String theirStorageInfoString=parsedParams.getStorageInfoString();
    if (theirStorageInfoString != null && !myStorageInfoString.equals(theirStorageInfoString)) {
      response.sendError(HttpServletResponse.SC_FORBIDDEN,"This namenode has storage info " + myStorageInfoString + " but the secondary expected "+ theirStorageInfoString);
      LOG.warn("Received an invalid request file transfer request " + "from a secondary with storage info " + theirStorageInfoString);
      return;
    }
    UserGroupInformation.getCurrentUser().doAs(new PrivilegedExceptionAction<Void>(){
      @Override public Void run() throws Exception {
        if (parsedParams.isGetImage()) {
          long txid=parsedParams.getTxId();
          File imageFile=nnImage.getStorage().getFsImageName(txid);
          if (imageFile == null) {
            throw new IOException("Could not find image with txid " + txid);
          }
          setVerificationHeaders(response,imageFile);
          TransferFsImage.getFileServer(response.getOutputStream(),imageFile,getThrottler(conf));
        }
 else         if (parsedParams.isGetEdit()) {
          long startTxId=parsedParams.getStartTxId();
          long endTxId=parsedParams.getEndTxId();
          File editFile=nnImage.getStorage().findFinalizedEditsFile(startTxId,endTxId);
          setVerificationHeaders(response,editFile);
          TransferFsImage.getFileServer(response.getOutputStream(),editFile,getThrottler(conf));
        }
 else         if (parsedParams.isPutImage()) {
          final long txid=parsedParams.getTxId();
          if (!currentlyDownloadingCheckpoints.add(txid)) {
            throw new IOException("Another checkpointer is already in the process of uploading a" + " checkpoint made at transaction ID " + txid);
          }
          try {
            if (nnImage.getStorage().findImageFile(txid) != null) {
              throw new IOException("Another checkpointer already uploaded an checkpoint " + "for txid " + txid);
            }
            MD5Hash downloadImageDigest=reloginIfNecessary().doAs(new PrivilegedExceptionAction<MD5Hash>(){
              @Override public MD5Hash run() throws Exception {
                return TransferFsImage.downloadImageToStorage(parsedParams.getInfoServer(),txid,nnImage.getStorage(),true);
              }
            }
);
            nnImage.saveDigestAndRenameCheckpointImage(txid,downloadImageDigest);
            nnImage.purgeOldStorage();
          }
  finally {
            currentlyDownloadingCheckpoints.remove(txid);
          }
        }
        return null;
      }
      private UserGroupInformation reloginIfNecessary() throws IOException {
        return UserGroupInformation.loginUserFromKeytabAndReturnUGI(SecurityUtil.getServerPrincipal(conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY),NameNode.getAddress(conf).getHostName()),conf.get(DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));
      }
    }
);
  }
 catch (  Exception ie) {
    String errMsg="GetImage failed. " + StringUtils.stringifyException(ie);
    response.sendError(HttpServletResponse.SC_GONE,errMsg);
    throw new IOException(errMsg);
  }
 finally {
    response.getOutputStream().close();
  }
}
