{
  this.nameNodeUri=nameNodeUri;
  this.namenode=NameNodeProxies.createProxy(conf,nameNodeUri,NamenodeProtocol.class).getProxy();
  this.client=NameNodeProxies.createProxy(conf,nameNodeUri,ClientProtocol.class).getProxy();
  this.fs=FileSystem.get(nameNodeUri,conf);
  final NamespaceInfo namespaceinfo=namenode.versionRequest();
  this.blockpoolID=namespaceinfo.getBlockPoolID();
  final ExportedBlockKeys keys=namenode.getBlockKeys();
  this.isBlockTokenEnabled=keys.isBlockTokenEnabled();
  if (isBlockTokenEnabled) {
    long blockKeyUpdateInterval=keys.getKeyUpdateInterval();
    long blockTokenLifetime=keys.getTokenLifetime();
    LOG.info("Block token params received from NN: keyUpdateInterval=" + blockKeyUpdateInterval / (60 * 1000) + " min(s), tokenLifetime=" + blockTokenLifetime / (60 * 1000) + " min(s)");
    this.blockTokenSecretManager=new BlockTokenSecretManager(blockKeyUpdateInterval,blockTokenLifetime);
    this.blockTokenSecretManager.addKeys(keys);
    this.keyUpdaterInterval=blockKeyUpdateInterval / 4;
    LOG.info("Balancer will update its block keys every " + keyUpdaterInterval / (60 * 1000) + " minute(s)");
    this.keyupdaterthread=new Daemon(new BlockKeyUpdater());
    this.shouldRun=true;
    this.keyupdaterthread.start();
  }
  out=checkAndMarkRunningBalancer();
  if (out == null) {
    throw new IOException("Another balancer is running");
  }
}
