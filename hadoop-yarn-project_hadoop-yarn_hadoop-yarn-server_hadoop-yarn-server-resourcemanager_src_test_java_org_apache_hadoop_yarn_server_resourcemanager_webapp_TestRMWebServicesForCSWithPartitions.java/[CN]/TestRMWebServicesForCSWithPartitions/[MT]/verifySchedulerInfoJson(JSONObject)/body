{
  assertEquals("incorrect number of elements",1,json.length());
  JSONObject info=json.getJSONObject("scheduler");
  assertEquals("incorrect number of elements",1,info.length());
  info=info.getJSONObject("schedulerInfo");
  assertEquals("incorrect number of elements",8,info.length());
  JSONObject capacitiesJsonObject=info.getJSONObject(CAPACITIES);
  JSONArray partitionsCapsArray=capacitiesJsonObject.getJSONArray(QUEUE_CAPACITIES_BY_PARTITION);
  assertEquals("incorrect number of elements",CLUSTER_LABELS.size(),partitionsCapsArray.length());
  for (int i=0; i < partitionsCapsArray.length(); i++) {
    JSONObject partitionInfo=partitionsCapsArray.getJSONObject(i);
    String partitionName=partitionInfo.getString("partitionName");
    assertTrue("Unknown partition received",CLUSTER_LABELS.contains(partitionName));
    verifyPartitionCapacityInfoJson(partitionInfo,100,0,100,100,0,100);
  }
  JSONObject jsonQueuesObject=info.getJSONObject("queues");
  JSONArray queuesArray=jsonQueuesObject.getJSONArray("queue");
  for (int i=0; i < queuesArray.length(); i++) {
    JSONObject queueJson=queuesArray.getJSONObject(i);
    String queue=queueJson.getString("queueName");
    assertEquals("Partition resourceInfo is wrong",1,queueJson.getJSONObject("resources").getJSONArray(RESOURCE_USAGES_BY_PARTITION).length());
    JSONObject resourcesJsonObject=queueJson.getJSONObject("resources");
    JSONArray partitionsResourcesArray=resourcesJsonObject.getJSONArray("resourceUsagesByPartition");
    assertEquals("incorrect number of elements",1,partitionsResourcesArray.length());
    capacitiesJsonObject=queueJson.getJSONObject(CAPACITIES);
    partitionsCapsArray=capacitiesJsonObject.getJSONArray(QUEUE_CAPACITIES_BY_PARTITION);
    JSONObject partitionInfo=null;
    String partitionName=null;
switch (queue) {
case QUEUE_A:
      assertEquals("incorrect number of partitions",1,partitionsCapsArray.length());
    partitionInfo=partitionsCapsArray.getJSONObject(0);
  partitionName=partitionInfo.getString("partitionName");
verifyPartitionCapacityInfoJson(partitionInfo,30,0,50,30,0,50);
assertEquals("incorrect number of elements",6,partitionsResourcesArray.getJSONObject(0).length());
break;
case QUEUE_B:
assertEquals("Invalid default Label expression",LABEL_LX,queueJson.getString("defaultNodeLabelExpression"));
assertEquals("incorrect number of elements",6,partitionsResourcesArray.getJSONObject(0).length());
verifyAccesibleNodeLabels(queueJson,ImmutableSet.of(LABEL_LX));
assertEquals("incorrect number of partitions",2,partitionsCapsArray.length());
for (int j=0; j < partitionsCapsArray.length(); j++) {
partitionInfo=partitionsCapsArray.getJSONObject(j);
partitionName=partitionInfo.getString("partitionName");
switch (partitionName) {
case LABEL_LX:
verifyPartitionCapacityInfoJson(partitionInfo,30,0,100,30,0,100);
break;
case DEFAULT_PARTITION:
verifyPartitionCapacityInfoJson(partitionInfo,30,0,50,30,0,50);
break;
default :
Assert.fail("Unexpected partition" + partitionName);
}
}
break;
case QUEUE_C:
verifyAccesibleNodeLabels(queueJson,ImmutableSet.of(LABEL_LX,LABEL_LY));
assertEquals("incorrect number of elements",4,partitionsResourcesArray.getJSONObject(0).length());
verifyQcPartitionsCapacityInfoJson(partitionsCapsArray,70,100,70,100,100,100,100,100,40,50,40,50);
verifySubQueuesOfQc(queueJson);
break;
default :
Assert.fail("Unexpected queue" + queue);
}
}
}
