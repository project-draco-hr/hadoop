{
  if (verificationLog != null) {
    long now=Time.now();
    RollingLogs.LineIterator logIterator=null;
    try {
      logIterator=verificationLog.logs.iterator(false);
      while (logIterator.hasNext()) {
        if (!datanode.shouldRun || datanode.blockScanner.blockScannerThread.isInterrupted()) {
          return false;
        }
        LogEntry entry=LogEntry.parseEntry(logIterator.next());
        if (entry != null) {
          updateBlockInfo(entry);
          if (now - entry.verificationTime < scanPeriod) {
            BlockScanInfo info=blockMap.get(new Block(entry.blockId,0,entry.genStamp));
            if (info != null) {
              if (processedBlocks.get(entry.blockId) == null) {
                updateBytesLeft(-info.getNumBytes());
                processedBlocks.put(entry.blockId,1);
              }
              if (logIterator.isPrevious()) {
                verificationLog.append(entry.verificationTime,entry.genStamp,entry.blockId);
              }
            }
          }
        }
      }
    }
 catch (    IOException e) {
      LOG.warn("Failed to read previous verification times.",e);
    }
 finally {
      IOUtils.closeStream(logIterator);
    }
  }
synchronized (this) {
    final int numBlocks=Math.max(blockMap.size(),1);
    long verifyInterval=Math.min(scanPeriod / (2L * numBlocks),10 * 60 * 1000L);
    long lastScanTime=Time.now() - scanPeriod;
    if (!blockInfoSet.isEmpty()) {
      BlockScanInfo info;
      while ((info=blockInfoSet.first()).lastScanTime < 0) {
        delBlockInfo(info);
        info.lastScanTime=lastScanTime;
        lastScanTime+=verifyInterval;
        addBlockInfo(info);
      }
    }
  }
  return true;
}
