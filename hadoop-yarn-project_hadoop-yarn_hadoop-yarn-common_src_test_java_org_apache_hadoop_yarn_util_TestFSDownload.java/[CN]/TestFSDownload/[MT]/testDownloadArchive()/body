{
  Configuration conf=new Configuration();
  conf.set(CommonConfigurationKeys.FS_PERMISSIONS_UMASK_KEY,"077");
  FileContext files=FileContext.getLocalFSFileContext(conf);
  final Path basedir=files.makeQualified(new Path("target",TestFSDownload.class.getSimpleName()));
  files.mkdir(basedir,null,true);
  conf.setStrings(TestFSDownload.class.getName(),basedir.toString());
  Random rand=new Random();
  long sharedSeed=rand.nextLong();
  rand.setSeed(sharedSeed);
  System.out.println("SEED: " + sharedSeed);
  Map<LocalResource,Future<Path>> pending=new HashMap<LocalResource,Future<Path>>();
  ExecutorService exec=Executors.newSingleThreadExecutor();
  LocalDirAllocator dirs=new LocalDirAllocator(TestFSDownload.class.getName());
  int size=rand.nextInt(512) + 512;
  LocalResourceVisibility vis=LocalResourceVisibility.PRIVATE;
  Path p=new Path(basedir,"" + 1);
  LocalResource rsrc=createTarFile(files,p,size,rand,vis);
  Path destPath=dirs.getLocalPathForWrite(basedir.toString(),size,conf);
  destPath=new Path(destPath,Long.toString(uniqueNumberGenerator.incrementAndGet()));
  FSDownload fsd=new FSDownload(files,UserGroupInformation.getCurrentUser(),conf,destPath,rsrc);
  pending.put(rsrc,exec.submit(fsd));
  exec.shutdown();
  while (!exec.awaitTermination(1000,TimeUnit.MILLISECONDS))   ;
  Assert.assertTrue(pending.get(rsrc).isDone());
  try {
    FileStatus[] filesstatus=files.getDefaultFileSystem().listStatus(basedir);
    for (    FileStatus filestatus : filesstatus) {
      if (filestatus.isDirectory()) {
        FileStatus[] childFiles=files.getDefaultFileSystem().listStatus(filestatus.getPath());
        for (        FileStatus childfile : childFiles) {
          if (childfile.getPath().getName().equalsIgnoreCase("1.tar.tmp")) {
            Assert.fail("Tmp File should not have been there " + childfile.getPath());
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw new IOException("Failed exec",e);
  }
}
