{
  LOG.info("Starting ApplicationMaster");
  resourceManager=connectToRM();
  RegisterApplicationMasterResponse response=registerToRM();
  int minMem=response.getMinimumResourceCapability().getMemory();
  int maxMem=response.getMaximumResourceCapability().getMemory();
  LOG.info("Min mem capabililty of resources in this cluster " + minMem);
  LOG.info("Max mem capabililty of resources in this cluster " + maxMem);
  if (containerMemory < minMem) {
    LOG.info("Container memory specified below min threshold of cluster. Using min value." + ", specified=" + containerMemory + ", min="+ minMem);
    containerMemory=minMem;
  }
 else   if (containerMemory > maxMem) {
    LOG.info("Container memory specified above max threshold of cluster. Using max value." + ", specified=" + containerMemory + ", max="+ maxMem);
    containerMemory=maxMem;
  }
  int loopCounter=-1;
  while (numCompletedContainers.get() < numTotalContainers && !appDone) {
    loopCounter++;
    LOG.info("Current application state: loop=" + loopCounter + ", appDone="+ appDone+ ", total="+ numTotalContainers+ ", requested="+ numRequestedContainers+ ", completed="+ numCompletedContainers+ ", failed="+ numFailedContainers+ ", currentAllocated="+ numAllocatedContainers);
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      LOG.info("Sleep interrupted " + e.getMessage());
    }
    int askCount=numTotalContainers - numRequestedContainers.get();
    numRequestedContainers.addAndGet(askCount);
    List<ResourceRequest> resourceReq=new ArrayList<ResourceRequest>();
    if (askCount > 0) {
      ResourceRequest containerAsk=setupContainerAskForRM(askCount);
      resourceReq.add(containerAsk);
    }
    LOG.info("Asking RM for containers" + ", askCount=" + askCount);
    AMResponse amResp=sendContainerAskToRM(resourceReq);
    List<Container> allocatedContainers=amResp.getAllocatedContainers();
    LOG.info("Got response from RM for container ask, allocatedCnt=" + allocatedContainers.size());
    numAllocatedContainers.addAndGet(allocatedContainers.size());
    for (    Container allocatedContainer : allocatedContainers) {
      LOG.info("Launching shell command on a new container." + ", containerId=" + allocatedContainer.getId() + ", containerNode="+ allocatedContainer.getNodeId().getHost()+ ":"+ allocatedContainer.getNodeId().getPort()+ ", containerNodeURI="+ allocatedContainer.getNodeHttpAddress()+ ", containerState"+ allocatedContainer.getState()+ ", containerResourceMemory"+ allocatedContainer.getResource().getMemory());
      LaunchContainerRunnable runnableLaunchContainer=new LaunchContainerRunnable(allocatedContainer);
      Thread launchThread=new Thread(runnableLaunchContainer);
      launchThreads.add(launchThread);
      launchThread.start();
    }
    Resource availableResources=amResp.getAvailableResources();
    LOG.info("Current available resources in the cluster " + availableResources);
    List<ContainerStatus> completedContainers=amResp.getCompletedContainersStatuses();
    LOG.info("Got response from RM for container ask, completedCnt=" + completedContainers.size());
    for (    ContainerStatus containerStatus : completedContainers) {
      LOG.info("Got container status for containerID= " + containerStatus.getContainerId() + ", state="+ containerStatus.getState()+ ", exitStatus="+ containerStatus.getExitStatus()+ ", diagnostics="+ containerStatus.getDiagnostics());
      assert(containerStatus.getState() == ContainerState.COMPLETE);
      int exitStatus=containerStatus.getExitStatus();
      if (0 != exitStatus) {
        if (-100 != exitStatus) {
          numCompletedContainers.incrementAndGet();
          numFailedContainers.incrementAndGet();
        }
 else {
          numAllocatedContainers.decrementAndGet();
          numRequestedContainers.decrementAndGet();
        }
      }
 else {
        numCompletedContainers.incrementAndGet();
        LOG.info("Container completed successfully." + ", containerId=" + containerStatus.getContainerId());
      }
    }
    if (numCompletedContainers.get() == numTotalContainers) {
      appDone=true;
    }
    LOG.info("Current application state: loop=" + loopCounter + ", appDone="+ appDone+ ", total="+ numTotalContainers+ ", requested="+ numRequestedContainers+ ", completed="+ numCompletedContainers+ ", failed="+ numFailedContainers+ ", currentAllocated="+ numAllocatedContainers);
  }
  for (  Thread launchThread : launchThreads) {
    try {
      launchThread.join(10000);
    }
 catch (    InterruptedException e) {
      LOG.info("Exception thrown in thread join: " + e.getMessage());
      e.printStackTrace();
    }
  }
  LOG.info("Application completed. Signalling finish to RM");
  FinishApplicationMasterRequest finishReq=Records.newRecord(FinishApplicationMasterRequest.class);
  finishReq.setAppAttemptId(appAttemptID);
  boolean isSuccess=true;
  if (numFailedContainers.get() == 0) {
    finishReq.setFinishApplicationStatus(FinalApplicationStatus.SUCCEEDED);
  }
 else {
    finishReq.setFinishApplicationStatus(FinalApplicationStatus.FAILED);
    String diagnostics="Diagnostics." + ", total=" + numTotalContainers + ", completed="+ numCompletedContainers.get()+ ", allocated="+ numAllocatedContainers.get()+ ", failed="+ numFailedContainers.get();
    finishReq.setDiagnostics(diagnostics);
    isSuccess=false;
  }
  resourceManager.finishApplicationMaster(finishReq);
  return isSuccess;
}
