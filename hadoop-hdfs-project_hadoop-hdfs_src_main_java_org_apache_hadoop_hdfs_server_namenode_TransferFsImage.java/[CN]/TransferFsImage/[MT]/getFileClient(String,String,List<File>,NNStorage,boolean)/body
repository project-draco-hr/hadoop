{
  byte[] buf=new byte[HdfsConstants.IO_FILE_BUFFER_SIZE];
  String proto=UserGroupInformation.isSecurityEnabled() ? "https://" : "http://";
  StringBuilder str=new StringBuilder(proto + nnHostPort + "/getimage?");
  str.append(queryString);
  URL url=new URL(str.toString());
  SecurityUtil.fetchServiceTicket(url);
  HttpURLConnection connection=(HttpURLConnection)url.openConnection();
  if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {
    throw new HttpGetFailedException("Image transfer servlet at " + url + " failed with status code "+ connection.getResponseCode()+ "\nResponse message:\n"+ connection.getResponseMessage(),connection);
  }
  long advertisedSize;
  String contentLength=connection.getHeaderField(CONTENT_LENGTH);
  if (contentLength != null) {
    advertisedSize=Long.parseLong(contentLength);
  }
 else {
    throw new IOException(CONTENT_LENGTH + " header is not provided " + "by the namenode when trying to fetch "+ str);
  }
  MD5Hash advertisedDigest=parseMD5Header(connection);
  long received=0;
  InputStream stream=connection.getInputStream();
  MessageDigest digester=null;
  if (getChecksum) {
    digester=MD5Hash.getDigester();
    stream=new DigestInputStream(stream,digester);
  }
  boolean finishedReceiving=false;
  List<FileOutputStream> outputStreams=Lists.newArrayList();
  try {
    if (localPaths != null) {
      for (      File f : localPaths) {
        try {
          if (f.exists()) {
            LOG.warn("Overwriting existing file " + f + " with file downloaded from "+ str);
          }
          outputStreams.add(new FileOutputStream(f));
        }
 catch (        IOException ioe) {
          LOG.warn("Unable to download file " + f,ioe);
          dstStorage.reportErrorOnFile(f);
        }
      }
      if (outputStreams.isEmpty()) {
        throw new IOException("Unable to download to any storage directory");
      }
    }
    int num=1;
    while (num > 0) {
      num=stream.read(buf);
      if (num > 0) {
        received+=num;
        for (        FileOutputStream fos : outputStreams) {
          fos.write(buf,0,num);
        }
      }
    }
    finishedReceiving=true;
  }
  finally {
    stream.close();
    for (    FileOutputStream fos : outputStreams) {
      fos.getChannel().force(true);
      fos.close();
    }
    if (finishedReceiving && received != advertisedSize) {
      throw new IOException("File " + str + " received length "+ received+ " is not of the advertised size "+ advertisedSize);
    }
  }
  if (digester != null) {
    MD5Hash computedDigest=new MD5Hash(digester.digest());
    if (advertisedDigest != null && !computedDigest.equals(advertisedDigest)) {
      throw new IOException("File " + str + " computed digest "+ computedDigest+ " does not match advertised digest "+ advertisedDigest);
    }
    return computedDigest;
  }
 else {
    return null;
  }
}
