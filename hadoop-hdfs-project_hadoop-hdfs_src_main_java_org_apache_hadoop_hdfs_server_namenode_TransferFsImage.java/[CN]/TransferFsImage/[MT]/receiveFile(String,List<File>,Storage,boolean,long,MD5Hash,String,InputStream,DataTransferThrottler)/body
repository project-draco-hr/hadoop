{
  long startTime=Time.monotonicNow();
  Map<FileOutputStream,File> streamPathMap=new HashMap<>();
  StringBuilder xferStats=new StringBuilder();
  double xferCombined=0;
  if (localPaths != null) {
    List<File> newLocalPaths=new ArrayList<File>();
    for (    File localPath : localPaths) {
      if (localPath.isDirectory()) {
        if (fsImageName == null) {
          throw new IOException("No filename header provided by server");
        }
        newLocalPaths.add(new File(localPath,fsImageName));
      }
 else {
        newLocalPaths.add(localPath);
      }
    }
    localPaths=newLocalPaths;
  }
  long received=0;
  MessageDigest digester=null;
  if (getChecksum) {
    digester=MD5Hash.getDigester();
    stream=new DigestInputStream(stream,digester);
  }
  boolean finishedReceiving=false;
  List<FileOutputStream> outputStreams=Lists.newArrayList();
  try {
    if (localPaths != null) {
      for (      File f : localPaths) {
        try {
          if (f.exists()) {
            LOG.warn("Overwriting existing file " + f + " with file downloaded from "+ url);
          }
          FileOutputStream fos=new FileOutputStream(f);
          outputStreams.add(fos);
          streamPathMap.put(fos,f);
        }
 catch (        IOException ioe) {
          LOG.warn("Unable to download file " + f,ioe);
          if (dstStorage != null && (dstStorage instanceof StorageErrorReporter)) {
            ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);
          }
        }
      }
      if (outputStreams.isEmpty()) {
        throw new IOException("Unable to download to any storage directory");
      }
    }
    int num=1;
    byte[] buf=new byte[IO_FILE_BUFFER_SIZE];
    while (num > 0) {
      num=stream.read(buf);
      if (num > 0) {
        received+=num;
        for (        FileOutputStream fos : outputStreams) {
          fos.write(buf,0,num);
        }
        if (throttler != null) {
          throttler.throttle(num);
        }
      }
    }
    finishedReceiving=true;
    double xferSec=Math.max(((float)(Time.monotonicNow() - startTime)) / 1000.0,0.001);
    long xferKb=received / 1024;
    xferCombined+=xferSec;
    xferStats.append(String.format(" The fsimage download took %.2fs at %.2f KB/s.",xferSec,xferKb / xferSec));
  }
  finally {
    stream.close();
    for (    FileOutputStream fos : outputStreams) {
      long flushStartTime=Time.monotonicNow();
      fos.getChannel().force(true);
      fos.close();
      double writeSec=Math.max(((float)(flushStartTime - Time.monotonicNow())) / 1000.0,0.001);
      xferCombined+=writeSec;
      xferStats.append(String.format(" Synchronous (fsync) write to disk of " + streamPathMap.get(fos).getAbsolutePath() + " took %.2fs.",writeSec));
    }
    if (!finishedReceiving) {
      deleteTmpFiles(localPaths);
    }
    if (finishedReceiving && received != advertisedSize) {
      deleteTmpFiles(localPaths);
      throw new IOException("File " + url + " received length "+ received+ " is not of the advertised size "+ advertisedSize);
    }
  }
  xferStats.insert(0,String.format("Combined time for fsimage download and fsync " + "to all disks took %.2fs.",xferCombined));
  LOG.info(xferStats.toString());
  if (digester != null) {
    MD5Hash computedDigest=new MD5Hash(digester.digest());
    if (advertisedDigest != null && !computedDigest.equals(advertisedDigest)) {
      deleteTmpFiles(localPaths);
      throw new IOException("File " + url + " computed digest "+ computedDigest+ " does not match advertised digest "+ advertisedDigest);
    }
    return computedDigest;
  }
 else {
    return null;
  }
}
