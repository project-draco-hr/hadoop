{
  int numNewMaps=0;
  TaskCompletionEvent events[]=null;
  do {
    MapTaskCompletionEventsUpdate update=umbilical.getMapCompletionEvents((org.apache.hadoop.mapred.JobID)reduce.getJobID(),fromEventIdx,maxEventsToFetch,(org.apache.hadoop.mapred.TaskAttemptID)reduce);
    events=update.getMapTaskCompletionEvents();
    LOG.debug("Got " + events.length + " map completion events from "+ fromEventIdx);
    if (update.shouldReset()) {
      fromEventIdx=0;
      scheduler.resetKnownMaps();
    }
    fromEventIdx+=events.length;
    for (    TaskCompletionEvent event : events) {
switch (event.getTaskStatus()) {
case SUCCEEDED:
        URI u=getBaseURI(event.getTaskTrackerHttp());
      scheduler.addKnownMapOutput(u.getHost() + ":" + u.getPort(),u.toString(),event.getTaskAttemptId());
    numNewMaps++;
  int duration=event.getTaskRunTime();
if (duration > maxMapRuntime) {
  maxMapRuntime=duration;
  scheduler.informMaxMapRunTime(maxMapRuntime);
}
break;
case FAILED:
case KILLED:
case OBSOLETE:
scheduler.obsoleteMapOutput(event.getTaskAttemptId());
LOG.info("Ignoring obsolete output of " + event.getTaskStatus() + " map-task: '"+ event.getTaskAttemptId()+ "'");
break;
case TIPFAILED:
scheduler.tipFailed(event.getTaskAttemptId().getTaskID());
LOG.info("Ignoring output of failed map TIP: '" + event.getTaskAttemptId() + "'");
break;
}
}
}
 while (events.length == maxEventsToFetch);
return numNewMaps;
}
