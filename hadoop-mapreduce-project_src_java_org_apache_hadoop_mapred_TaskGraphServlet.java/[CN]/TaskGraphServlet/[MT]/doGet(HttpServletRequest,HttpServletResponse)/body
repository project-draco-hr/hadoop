{
  response.setContentType("image/svg+xml");
  final JobTracker tracker=(JobTracker)getServletContext().getAttribute("job.tracker");
  String jobIdStr=request.getParameter("jobid");
  if (jobIdStr == null)   return;
  final JobID jobId=JobID.forName(jobIdStr);
  JobWithViewAccessCheck myJob=JSPUtil.checkAccessAndGetJob(tracker,jobId,request,response);
  if (!myJob.isViewJobAllowed()) {
    return;
  }
  final boolean isMap="map".equalsIgnoreCase(request.getParameter("type"));
  final TaskReport[] reports=isMap ? tracker.getMapTaskReports(jobId) : tracker.getReduceTaskReports(jobId);
  if (reports == null || reports.length == 0) {
    return;
  }
  final int numTasks=reports.length;
  int tasksPerBar=(int)Math.ceil(numTasks / 600d);
  int numBars=(int)Math.ceil((double)numTasks / tasksPerBar);
  int w=Math.max(600,numBars);
  int barWidth=Math.min(10,w / numBars);
  int barsPerNotch=(int)Math.ceil(10d / barWidth);
  w=w + numBars / barsPerNotch;
  int totalWidth=w + 2 * xmargin;
  final PrintWriter out=response.getWriter();
  out.print("<?xml version=\"1.0\" standalone=\"no\"?>\n" + "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \n" + "\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n"+ "<?xml-stylesheet type=\"text/css\" href=\"/static/hadoop.css\"?>\n\n"+ "<svg width=\"");
  out.print(totalWidth);
  out.print("\" height=\"");
  out.print(height + 2 * ymargin);
  out.print("\" version=\"1.1\"\n" + "xmlns=\"http://www.w3.org/2000/svg\">\n\n");
  printLine(out,xmargin - 1,xmargin - 1,height + ymargin + 1,ymargin - 1,"black");
  printLine(out,xmargin - 1,w + xmargin + 1,height + ymargin + 1,height + ymargin + 1,"black");
  printLine(out,w + xmargin + 1,w + xmargin + 1,height + ymargin + 1,ymargin - 1,"#CCCCCC");
  printLine(out,xmargin - 1,w + xmargin + 1,ymargin - 1,ymargin - 1,"#CCCCCC");
  String[] colors=new String[]{"#00DD00","#E50000","#AAAAFF"};
  int xNotchInterval=(int)(Math.ceil(numTasks / 10d));
  int xOffset=-1;
  int xNotchCount=0;
  for (int i=0, barCnt=0; ; i+=tasksPerBar, barCnt++) {
    if (barCnt % barsPerNotch == 0) {
      xOffset++;
    }
    int x=barCnt * barWidth + xmargin + xOffset;
    if (i >= xNotchInterval * xNotchCount) {
      printLine(out,x,x,height + ymargin + 3,height + ymargin - 2,"black");
      printText(out,x,height + ymargin + 15,String.valueOf(xNotchInterval * xNotchCount++),"middle");
    }
    if (i >= reports.length)     break;
    if (isMap) {
      float progress=getMapAvarageProgress(tasksPerBar,i,reports);
      int barHeight=(int)Math.ceil(height * progress);
      int y=height - barHeight + ymargin;
      printRect(out,barWidth,barHeight,x,y,colors[2]);
    }
 else {
      float[] progresses=getReduceAvarageProgresses(tasksPerBar,i,reports);
      int prevHeight=0;
      for (int j=0; j < 3; j++) {
        int barHeight=(int)((height / 3) * progresses[j]);
        if (barHeight > height / 3 - 3)         barHeight=height / 3 + 1;
        int y=height - barHeight + ymargin - prevHeight;
        prevHeight+=barHeight;
        printRect(out,barWidth,barHeight,x,y,colors[j]);
      }
    }
  }
  for (int i=0; i <= 10; i++) {
    printLine(out,xmargin - 3,xmargin + 2,ymargin + (i * height) / 10,ymargin + (i * height) / 10,"black");
    printText(out,xmargin - 10,ymargin + 4 + (i * height) / 10,String.valueOf(100 - i * 10),"end");
  }
  if (!isMap) {
    printRect(out,14,14,xmargin + w + 4,ymargin + 20,colors[0]);
    printText(out,xmargin + w + 24,ymargin + 30,"copy","start");
    printRect(out,14,14,xmargin + w + 4,ymargin + 50,colors[1]);
    printText(out,xmargin + w + 24,ymargin + 60,"sort","start");
    printRect(out,14,14,xmargin + w + 4,ymargin + 80,colors[2]);
    printText(out,xmargin + w + 24,ymargin + 90,"reduce","start");
  }
  out.print("</svg>");
}
