{
  Configuration conf=context.getConfiguration();
  int numSplits=conf.getInt("mapreduce.job.maps",1);
  LOG.debug("creating splits up to " + numSplits);
  List<InputSplit> splits=new ArrayList<InputSplit>();
  int i=0;
  long start=0;
  long end=0;
  boolean limitOffset=true;
  VerticaConfiguration config=new VerticaConfiguration(conf);
  String inputQuery=config.getInputQuery();
  if (inputQuery == null)   throw new IOException("Vertica input requires query defined by " + VerticaConfiguration.QUERY_PROP);
  String paramsQuery=config.getParamsQuery();
  Collection<List<Object>> params=config.getInputParameters();
  String countQuery="SELECT COUNT(*) FROM (\n" + inputQuery + "\n) count";
  if (paramsQuery != null) {
    LOG.debug("creating splits using paramsQuery :" + paramsQuery);
    Connection conn=null;
    Statement stmt=null;
    try {
      conn=config.getConnection(false);
      stmt=conn.createStatement();
      ResultSet rs=stmt.executeQuery(paramsQuery);
      ResultSetMetaData rsmd=rs.getMetaData();
      while (rs.next()) {
        limitOffset=false;
        List<Object> segmentParams=new ArrayList<Object>();
        for (int j=1; j <= rsmd.getColumnCount(); j++) {
          segmentParams.add(rs.getObject(j));
        }
        splits.add(new VerticaInputSplit(inputQuery,segmentParams,start,end));
      }
    }
 catch (    Exception e) {
      throw new IOException(e);
    }
 finally {
      try {
        if (stmt != null)         stmt.close();
      }
 catch (      SQLException e) {
        throw new IOException(e);
      }
    }
  }
 else   if (params != null && params.size() > 0) {
    LOG.debug("creating splits using " + params.size() + " params");
    limitOffset=false;
    for (    List<Object> segmentParams : params) {
      splits.add(new VerticaInputSplit(inputQuery,segmentParams,start,end));
    }
  }
  if (limitOffset) {
    LOG.debug("creating splits using limit and offset");
    Connection conn=null;
    Statement stmt=null;
    long count=0;
    try {
      conn=config.getConnection(false);
      stmt=conn.createStatement();
      ResultSet rs=stmt.executeQuery(countQuery);
      rs.next();
      count=rs.getLong(1);
    }
 catch (    Exception e) {
      throw new IOException(e);
    }
 finally {
      try {
        if (stmt != null)         stmt.close();
      }
 catch (      SQLException e) {
        throw new IOException(e);
      }
    }
    long splitSize=count / numSplits;
    end=splitSize;
    LOG.debug("creating " + numSplits + " splits for "+ count+ " records");
    for (i=0; i < numSplits; i++) {
      splits.add(new VerticaInputSplit(inputQuery,null,start,end));
      start+=splitSize;
      end+=splitSize;
    }
  }
  LOG.debug("returning " + splits.size() + " final splits");
  return splits;
}
