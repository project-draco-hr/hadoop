{
  Peer peer=null;
  while (datanode.shouldRun && !datanode.shutdownForUpgrade) {
    try {
      peer=peerServer.accept();
      int curXceiverCount=datanode.getXceiverCount();
      if (curXceiverCount > maxXceiverCount) {
        throw new IOException("Xceiver count " + curXceiverCount + " exceeds the limit of concurrent xcievers: "+ maxXceiverCount);
      }
      new Daemon(datanode.threadGroup,DataXceiver.create(peer,datanode,this)).start();
    }
 catch (    SocketTimeoutException ignored) {
    }
catch (    AsynchronousCloseException ace) {
      if (datanode.shouldRun && !datanode.shutdownForUpgrade) {
        LOG.warn(datanode.getDisplayName() + ":DataXceiverServer: ",ace);
      }
    }
catch (    IOException ie) {
      IOUtils.cleanup(null,peer);
      LOG.warn(datanode.getDisplayName() + ":DataXceiverServer: ",ie);
    }
catch (    OutOfMemoryError ie) {
      IOUtils.cleanup(null,peer);
      LOG.warn("DataNode is out of memory. Will retry in 30 seconds.",ie);
      try {
        Thread.sleep(30 * 1000);
      }
 catch (      InterruptedException e) {
      }
    }
catch (    Throwable te) {
      LOG.error(datanode.getDisplayName() + ":DataXceiverServer: Exiting due to: ",te);
      datanode.shouldRun=false;
    }
  }
  try {
    peerServer.close();
    closed=true;
  }
 catch (  IOException ie) {
    LOG.warn(datanode.getDisplayName() + " :DataXceiverServer: close exception",ie);
  }
  if (datanode.shutdownForUpgrade) {
    restartNotifyPeers();
    LOG.info("Shutting down DataXceiverServer before restart");
    for (int i=0; getNumPeers() > 0 && i < 10; i++) {
      try {
        Thread.sleep(200);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  closeAllPeers();
}
