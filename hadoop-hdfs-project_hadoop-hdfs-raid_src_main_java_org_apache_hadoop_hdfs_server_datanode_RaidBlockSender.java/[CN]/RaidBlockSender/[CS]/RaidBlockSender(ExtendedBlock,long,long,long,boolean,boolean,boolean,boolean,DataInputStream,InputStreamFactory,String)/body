{
  try {
    this.block=block;
    this.chunkOffsetOK=chunkOffsetOK;
    this.corruptChecksumOk=corruptChecksumOk;
    this.verifyChecksum=verifyChecksum;
    this.replicaVisibleLength=blockLength;
    this.transferToAllowed=transferToAllowed;
    this.clientTraceFmt=clientTraceFmt;
    if (!corruptChecksumOk || metadataIn != null) {
      this.checksumIn=metadataIn;
      BlockMetadataHeader header=BlockMetadataHeader.readHeader(checksumIn);
      short version=header.getVersion();
      if (version != BlockMetadataHeader.VERSION) {
        LOG.warn("Wrong version (" + version + ") for metadata file for "+ block+ " ignoring ...");
      }
      checksum=header.getChecksum();
    }
 else {
      LOG.warn("Could not find metadata file for " + block);
      checksum=DataChecksum.newDataChecksum(DataChecksum.CHECKSUM_NULL,16 * 1024);
    }
    int size=checksum.getBytesPerChecksum();
    if (size > 10 * 1024 * 1024 && size > replicaVisibleLength) {
      checksum=DataChecksum.newDataChecksum(checksum.getChecksumType(),Math.max((int)replicaVisibleLength,10 * 1024 * 1024));
      size=checksum.getBytesPerChecksum();
    }
    chunkSize=size;
    checksumSize=checksum.getChecksumSize();
    if (length < 0) {
      length=replicaVisibleLength;
    }
    endOffset=blockLength;
    if (startOffset < 0 || startOffset > endOffset || (length + startOffset) > endOffset) {
      String msg=" Offset " + startOffset + " and length "+ length+ " don't match block "+ block+ " ( blockLen "+ endOffset+ " )";
      LOG.warn("sendBlock() : " + msg);
      throw new IOException(msg);
    }
    offset=(startOffset - (startOffset % chunkSize));
    if (length >= 0) {
      long tmpLen=startOffset + length;
      if (tmpLen % chunkSize != 0) {
        tmpLen+=(chunkSize - tmpLen % chunkSize);
      }
      if (tmpLen < endOffset) {
        endOffset=tmpLen;
      }
    }
    if (offset > 0) {
      long checksumSkip=(offset / chunkSize) * checksumSize;
      if (checksumSkip > 0) {
        IOUtils.skipFully(checksumIn,checksumSkip);
      }
    }
    seqno=0;
    blockIn=streamFactory.createStream(offset);
  }
 catch (  IOException ioe) {
    IOUtils.closeStream(this);
    IOUtils.closeStream(blockIn);
    throw ioe;
  }
}
