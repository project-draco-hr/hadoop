{
  try {
    this.block=block;
    this.in=in;
    this.inAddr=inAddr;
    this.myAddr=myAddr;
    this.srcDataNode=srcDataNode;
    this.datanode=datanode;
    this.clientname=clientname;
    this.isDatanode=clientname.length() == 0;
    this.isClient=!this.isDatanode;
    this.stage=stage;
    this.isTransfer=stage == BlockConstructionStage.TRANSFER_RBW || stage == BlockConstructionStage.TRANSFER_FINALIZED;
    if (LOG.isDebugEnabled()) {
      LOG.debug(getClass().getSimpleName() + ": " + block+ "\n  isClient  ="+ isClient+ ", clientname="+ clientname+ "\n  isDatanode="+ isDatanode+ ", srcDataNode="+ srcDataNode+ "\n  inAddr="+ inAddr+ ", myAddr="+ myAddr);
    }
    if (isDatanode) {
      replicaInfo=datanode.data.createTemporary(block);
    }
 else {
switch (stage) {
case PIPELINE_SETUP_CREATE:
        replicaInfo=datanode.data.createRbw(block);
      break;
case PIPELINE_SETUP_STREAMING_RECOVERY:
    replicaInfo=datanode.data.recoverRbw(block,newGs,minBytesRcvd,maxBytesRcvd);
  block.setGenerationStamp(newGs);
break;
case PIPELINE_SETUP_APPEND:
replicaInfo=datanode.data.append(block,newGs,minBytesRcvd);
if (datanode.blockScanner != null) {
datanode.blockScanner.deleteBlock(block.getBlockPoolId(),block.getLocalBlock());
}
block.setGenerationStamp(newGs);
break;
case PIPELINE_SETUP_APPEND_RECOVERY:
replicaInfo=datanode.data.recoverAppend(block,newGs,minBytesRcvd);
if (datanode.blockScanner != null) {
datanode.blockScanner.deleteBlock(block.getBlockPoolId(),block.getLocalBlock());
}
block.setGenerationStamp(newGs);
break;
case TRANSFER_RBW:
case TRANSFER_FINALIZED:
replicaInfo=datanode.data.createTemporary(block);
break;
default :
throw new IOException("Unsupported stage " + stage + " while receiving block "+ block+ " from "+ inAddr);
}
}
this.checksum=DataChecksum.newDataChecksum(in);
this.bytesPerChecksum=checksum.getBytesPerChecksum();
this.checksumSize=checksum.getChecksumSize();
this.dropCacheBehindWrites=datanode.shouldDropCacheBehindWrites();
this.syncBehindWrites=datanode.shouldSyncBehindWrites();
final boolean isCreate=isDatanode || isTransfer || stage == BlockConstructionStage.PIPELINE_SETUP_CREATE;
streams=replicaInfo.createStreams(isCreate,this.bytesPerChecksum,this.checksumSize);
if (streams != null) {
this.out=streams.dataOut;
if (out instanceof FileOutputStream) {
this.outFd=((FileOutputStream)out).getFD();
}
 else {
LOG.warn("Could not get file descriptor for outputstream of class " + out.getClass());
}
this.cout=streams.checksumOut;
this.checksumOut=new DataOutputStream(new BufferedOutputStream(streams.checksumOut,HdfsConstants.SMALL_BUFFER_SIZE));
if (isCreate) {
BlockMetadataHeader.writeHeader(checksumOut,checksum);
}
}
}
 catch (ReplicaAlreadyExistsException bae) {
throw bae;
}
catch (ReplicaNotFoundException bne) {
throw bne;
}
catch (IOException ioe) {
IOUtils.closeStream(this);
cleanupBlock();
IOException cause=FSDataset.getCauseIfDiskError(ioe);
DataNode.LOG.warn("IOException in BlockReceiver constructor. Cause is ",cause);
if (cause != null) {
ioe=cause;
datanode.checkDiskError(ioe);
}
throw ioe;
}
}
