{
  Status[] replies=null;
  if (ack == null) {
    replies=new Status[1];
    replies[0]=myStatus;
  }
 else   if (mirrorError) {
    replies=MIRROR_ERROR_STATUS;
  }
 else {
    short ackLen=type == PacketResponderType.LAST_IN_PIPELINE ? 0 : ack.getNumOfReplies();
    replies=new Status[1 + ackLen];
    replies[0]=myStatus;
    for (int i=0; i < ackLen; i++) {
      replies[i + 1]=ack.getReply(i);
    }
    if (ackLen > 0 && replies[1] == Status.ERROR_CHECKSUM) {
      throw new IOException("Shutting down writer and responder " + "since the down streams reported the data sent by this " + "thread is corrupt");
    }
  }
  PipelineAck replyAck=new PipelineAck(seqno,replies,totalAckTimeNanos);
  if (replyAck.isSuccess() && offsetInBlock > replicaInfo.getBytesAcked()) {
    replicaInfo.setBytesAcked(offsetInBlock);
  }
  long begin=Time.monotonicNow();
  replyAck.write(upstreamOut);
  upstreamOut.flush();
  long duration=Time.monotonicNow() - begin;
  if (duration > datanodeSlowLogThresholdMs) {
    LOG.warn("Slow PacketResponder send ack to upstream took " + duration + "ms (threshold="+ datanodeSlowLogThresholdMs+ "ms), "+ myString+ ", replyAck="+ replyAck);
  }
 else   if (LOG.isDebugEnabled()) {
    LOG.debug(myString + ", replyAck=" + replyAck);
  }
  if (myStatus == Status.ERROR_CHECKSUM) {
    throw new IOException("Shutting down writer and responder " + "due to a checksum error in received data. The error " + "response has been sent upstream.");
  }
}
