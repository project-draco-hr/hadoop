{
  final int[] replies;
  if (ack == null) {
    replies=new int[]{myHeader};
  }
 else   if (mirrorError) {
    int h=PipelineAck.combineHeader(datanode.getECN(),Status.SUCCESS);
    int h1=PipelineAck.combineHeader(datanode.getECN(),Status.ERROR);
    replies=new int[]{h,h1};
  }
 else {
    short ackLen=type == PacketResponderType.LAST_IN_PIPELINE ? 0 : ack.getNumOfReplies();
    replies=new int[ackLen + 1];
    replies[0]=myHeader;
    for (int i=0; i < ackLen; ++i) {
      replies[i + 1]=ack.getHeaderFlag(i);
    }
    if (ackLen > 0 && PipelineAck.getStatusFromHeader(replies[1]) == Status.ERROR_CHECKSUM) {
      throw new IOException("Shutting down writer and responder " + "since the down streams reported the data sent by this " + "thread is corrupt");
    }
  }
  PipelineAck replyAck=new PipelineAck(seqno,replies,totalAckTimeNanos);
  if (replyAck.isSuccess() && offsetInBlock > replicaInfo.getBytesAcked()) {
    replicaInfo.setBytesAcked(offsetInBlock);
  }
  long begin=Time.monotonicNow();
  replyAck.write(upstreamOut);
  upstreamOut.flush();
  long duration=Time.monotonicNow() - begin;
  if (duration > datanodeSlowLogThresholdMs) {
    LOG.warn("Slow PacketResponder send ack to upstream took " + duration + "ms (threshold="+ datanodeSlowLogThresholdMs+ "ms), "+ myString+ ", replyAck="+ replyAck);
  }
 else   if (LOG.isDebugEnabled()) {
    LOG.debug(myString + ", replyAck=" + replyAck);
  }
  Status myStatus=PipelineAck.getStatusFromHeader(myHeader);
  if (myStatus == Status.ERROR_CHECKSUM) {
    throw new IOException("Shutting down writer and responder " + "due to a checksum error in received data. The error " + "response has been sent upstream.");
  }
}
