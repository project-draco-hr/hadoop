{
  boolean lastPacketInBlock=false;
  final long startTime=ClientTraceLog.isInfoEnabled() ? System.nanoTime() : 0;
  while (running && datanode.shouldRun && !lastPacketInBlock) {
    long totalAckTimeNanos=0;
    boolean isInterrupted=false;
    try {
      Packet pkt=null;
      long expected=-2;
      PipelineAck ack=new PipelineAck();
      long seqno=PipelineAck.UNKOWN_SEQNO;
      long ackRecvNanoTime=0;
      try {
        if (type != PacketResponderType.LAST_IN_PIPELINE && !mirrorError) {
          ack.readFields(downstreamIn);
          ackRecvNanoTime=System.nanoTime();
          if (LOG.isDebugEnabled()) {
            LOG.debug(myString + " got " + ack);
          }
          seqno=ack.getSeqno();
        }
        if (seqno != PipelineAck.UNKOWN_SEQNO || type == PacketResponderType.LAST_IN_PIPELINE) {
synchronized (this) {
            while (running && datanode.shouldRun && ackQueue.size() == 0) {
              if (LOG.isDebugEnabled()) {
                LOG.debug(myString + ": seqno=" + seqno+ " waiting for local datanode to finish write.");
              }
              wait();
            }
            if (!running || !datanode.shouldRun) {
              break;
            }
            pkt=ackQueue.getFirst();
            expected=pkt.seqno;
            if (type == PacketResponderType.HAS_DOWNSTREAM_IN_PIPELINE && seqno != expected) {
              throw new IOException(myString + "seqno: expected=" + expected+ ", received="+ seqno);
            }
            if (type == PacketResponderType.HAS_DOWNSTREAM_IN_PIPELINE) {
              totalAckTimeNanos=ackRecvNanoTime - pkt.ackEnqueueNanoTime;
              long ackTimeNanos=totalAckTimeNanos - ack.getDownstreamAckTimeNanos();
              if (ackTimeNanos < 0) {
                if (LOG.isDebugEnabled()) {
                  LOG.debug("Calculated invalid ack time: " + ackTimeNanos + "ns.");
                }
              }
 else {
                datanode.metrics.addPacketAckRoundTripTimeNanos(ackTimeNanos);
              }
            }
            lastPacketInBlock=pkt.lastPacketInBlock;
          }
        }
      }
 catch (      InterruptedException ine) {
        isInterrupted=true;
      }
catch (      IOException ioe) {
        if (Thread.interrupted()) {
          isInterrupted=true;
        }
 else {
          mirrorError=true;
          LOG.info(myString,ioe);
        }
      }
      if (Thread.interrupted() || isInterrupted) {
        LOG.info(myString + ": Thread is interrupted.");
        running=false;
        continue;
      }
      if (lastPacketInBlock) {
        BlockReceiver.this.close();
        final long endTime=ClientTraceLog.isInfoEnabled() ? System.nanoTime() : 0;
        block.setNumBytes(replicaInfo.getNumBytes());
        datanode.data.finalizeBlock(block);
        datanode.closeBlock(block,DataNode.EMPTY_DEL_HINT);
        if (ClientTraceLog.isInfoEnabled() && isClient) {
          long offset=0;
          DatanodeRegistration dnR=datanode.getDNRegistrationForBP(block.getBlockPoolId());
          ClientTraceLog.info(String.format(DN_CLIENTTRACE_FORMAT,inAddr,myAddr,block.getNumBytes(),"HDFS_WRITE",clientname,offset,dnR.getStorageID(),block,endTime - startTime));
        }
 else {
          LOG.info("Received " + block + " size "+ block.getNumBytes()+ " from "+ inAddr);
        }
      }
      Status[] replies=null;
      if (mirrorError) {
        replies=new Status[2];
        replies[0]=Status.SUCCESS;
        replies[1]=Status.ERROR;
      }
 else {
        short ackLen=type == PacketResponderType.LAST_IN_PIPELINE ? 0 : ack.getNumOfReplies();
        replies=new Status[1 + ackLen];
        replies[0]=Status.SUCCESS;
        for (int i=0; i < ackLen; i++) {
          replies[i + 1]=ack.getReply(i);
        }
      }
      PipelineAck replyAck=new PipelineAck(expected,replies,totalAckTimeNanos);
      if (replyAck.isSuccess() && pkt.offsetInBlock > replicaInfo.getBytesAcked())       replicaInfo.setBytesAcked(pkt.offsetInBlock);
      replyAck.write(upstreamOut);
      upstreamOut.flush();
      if (LOG.isDebugEnabled()) {
        LOG.debug(myString + ", replyAck=" + replyAck);
      }
      if (pkt != null) {
        removeAckHead();
      }
    }
 catch (    IOException e) {
      LOG.warn("IOException in BlockReceiver.run(): ",e);
      if (running) {
        try {
          datanode.checkDiskError(e);
        }
 catch (        IOException ioe) {
          LOG.warn("DataNode.checkDiskError failed in run() with: ",ioe);
        }
        LOG.info(myString,e);
        running=false;
        if (!Thread.interrupted()) {
          receiverThread.interrupt();
        }
      }
    }
catch (    Throwable e) {
      if (running) {
        LOG.info(myString,e);
        running=false;
        receiverThread.interrupt();
      }
    }
  }
  LOG.info(myString + " terminating");
}
