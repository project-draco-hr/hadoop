{
  syncOnClose=datanode.getDnConf().syncOnClose;
  boolean responderClosed=false;
  mirrorOut=mirrOut;
  mirrorAddr=mirrAddr;
  throttler=throttlerArg;
  this.replyOut=replyOut;
  this.isReplaceBlock=isReplaceBlock;
  try {
    if (isClient && !isTransfer) {
      responder=new Daemon(datanode.threadGroup,new PacketResponder(replyOut,mirrIn,downstreams));
      responder.start();
    }
    while (receivePacket() >= 0) {
    }
    if (responder != null) {
      ((PacketResponder)responder.getRunnable()).close();
      responderClosed=true;
    }
    if (isDatanode || isTransfer) {
      try (ReplicaHandler handler=claimReplicaHandler()){
        close();
        block.setNumBytes(replicaInfo.getNumBytes());
        if (stage == BlockConstructionStage.TRANSFER_RBW) {
          datanode.data.convertTemporaryToRbw(block);
        }
 else {
          datanode.data.finalizeBlock(block);
        }
      }
       datanode.metrics.incrBlocksWritten();
    }
  }
 catch (  IOException ioe) {
    replicaInfo.releaseAllBytesReserved();
    if (datanode.isRestarting()) {
      LOG.info("Shutting down for restart (" + block + ").");
    }
 else {
      LOG.info("Exception for " + block,ioe);
      throw ioe;
    }
  }
 finally {
    Thread.interrupted();
    if (!responderClosed) {
      if (responder != null) {
        if (datanode.isRestarting() && isClient && !isTransfer) {
          try (Writer out=new OutputStreamWriter(replicaInfo.createRestartMetaStream(),"UTF-8")){
            out.write(Long.toString(Time.now() + restartBudget));
            out.flush();
          }
 catch (          IOException ioe) {
          }
 finally {
            IOUtils.cleanup(LOG,out);
          }
          try {
            Thread.sleep(1000);
          }
 catch (          InterruptedException ie) {
          }
        }
        responder.interrupt();
      }
      IOUtils.closeStream(this);
      cleanupBlock();
    }
    if (responder != null) {
      try {
        responder.interrupt();
        long joinTimeout=datanode.getDnConf().getXceiverStopTimeout();
        joinTimeout=joinTimeout > 1 ? joinTimeout * 8 / 10 : joinTimeout;
        responder.join(joinTimeout);
        if (responder.isAlive()) {
          String msg="Join on responder thread " + responder + " timed out";
          LOG.warn(msg + "\n" + StringUtils.getStackTrace(responder));
          throw new IOException(msg);
        }
      }
 catch (      InterruptedException e) {
        responder.interrupt();
        if (!datanode.isRestarting()) {
          throw new IOException("Interrupted receiveBlock");
        }
      }
      responder=null;
    }
  }
}
