{
  syncOnClose=datanode.getDnConf().syncOnClose;
  boolean responderClosed=false;
  mirrorOut=mirrOut;
  mirrorAddr=mirrAddr;
  throttler=throttlerArg;
  try {
    if (isClient && !isTransfer) {
      responder=new Daemon(datanode.threadGroup,new PacketResponder(replyOut,mirrIn,downstreams));
      responder.start();
    }
    while (receivePacket() >= 0) {
    }
    if (responder != null) {
      ((PacketResponder)responder.getRunnable()).close();
      responderClosed=true;
    }
    if (isDatanode || isTransfer) {
      close();
      block.setNumBytes(replicaInfo.getNumBytes());
      if (stage == BlockConstructionStage.TRANSFER_RBW) {
        datanode.data.convertTemporaryToRbw(block);
      }
 else {
        datanode.data.finalizeBlock(block);
      }
      datanode.metrics.incrBlocksWritten();
    }
  }
 catch (  IOException ioe) {
    LOG.info("Exception for " + block,ioe);
    throw ioe;
  }
 finally {
    if (!responderClosed) {
      IOUtils.closeStream(this);
      if (responder != null) {
        responder.interrupt();
      }
      cleanupBlock();
    }
    if (responder != null) {
      try {
        responder.join(datanode.getDnConf().getXceiverStopTimeout());
        if (responder.isAlive()) {
          String msg="Join on responder thread " + responder + " timed out";
          LOG.warn(msg + "\n" + StringUtils.getStackTrace(responder));
          throw new IOException(msg);
        }
      }
 catch (      InterruptedException e) {
        responder.interrupt();
        throw new IOException("Interrupted receiveBlock");
      }
      responder=null;
    }
  }
}
