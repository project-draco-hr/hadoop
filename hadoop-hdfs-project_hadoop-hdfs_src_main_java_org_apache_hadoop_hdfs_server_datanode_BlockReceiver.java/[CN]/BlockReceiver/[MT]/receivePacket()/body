{
  packetReceiver.receiveNextPacket(in);
  PacketHeader header=packetReceiver.getHeader();
  if (LOG.isDebugEnabled()) {
    LOG.debug("Receiving one packet for block " + block + ": "+ header);
  }
  if (header.getOffsetInBlock() > replicaInfo.getNumBytes()) {
    throw new IOException("Received an out-of-sequence packet for " + block + "from "+ inAddr+ " at offset "+ header.getOffsetInBlock()+ ". Expecting packet starting at "+ replicaInfo.getNumBytes());
  }
  if (header.getDataLen() < 0) {
    throw new IOException("Got wrong length during writeBlock(" + block + ") from "+ inAddr+ " at offset "+ header.getOffsetInBlock()+ ": "+ header.getDataLen());
  }
  long offsetInBlock=header.getOffsetInBlock();
  long seqno=header.getSeqno();
  boolean lastPacketInBlock=header.isLastPacketInBlock();
  final int len=header.getDataLen();
  boolean syncBlock=header.getSyncBlock();
  if (syncBlock && lastPacketInBlock) {
    this.syncOnClose=false;
  }
  final long firstByteInBlock=offsetInBlock;
  offsetInBlock+=len;
  if (replicaInfo.getNumBytes() < offsetInBlock) {
    replicaInfo.setNumBytes(offsetInBlock);
  }
  if (responder != null && !syncBlock && !shouldVerifyChecksum()) {
    ((PacketResponder)responder.getRunnable()).enqueue(seqno,lastPacketInBlock,offsetInBlock,Status.SUCCESS);
  }
  if (mirrorOut != null && !mirrorError) {
    try {
      long begin=Time.monotonicNow();
      packetReceiver.mirrorPacketTo(mirrorOut);
      mirrorOut.flush();
      long duration=Time.monotonicNow() - begin;
      if (duration > datanodeSlowLogThresholdMs) {
        LOG.warn("Slow BlockReceiver write packet to mirror took " + duration + "ms (threshold="+ datanodeSlowLogThresholdMs+ "ms)");
      }
    }
 catch (    IOException e) {
      handleMirrorOutError(e);
    }
  }
  ByteBuffer dataBuf=packetReceiver.getDataSlice();
  ByteBuffer checksumBuf=packetReceiver.getChecksumSlice();
  if (lastPacketInBlock || len == 0) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Receiving an empty packet or the end of the block " + block);
    }
    if (syncBlock) {
      flushOrSync(true);
    }
  }
 else {
    final int checksumLen=diskChecksum.getChecksumSize(len);
    final int checksumReceivedLen=checksumBuf.capacity();
    if (checksumReceivedLen > 0 && checksumReceivedLen != checksumLen) {
      throw new IOException("Invalid checksum length: received length is " + checksumReceivedLen + " but expected length is "+ checksumLen);
    }
    if (checksumReceivedLen > 0 && shouldVerifyChecksum()) {
      try {
        verifyChunks(dataBuf,checksumBuf);
      }
 catch (      IOException ioe) {
        if (responder != null) {
          try {
            ((PacketResponder)responder.getRunnable()).enqueue(seqno,lastPacketInBlock,offsetInBlock,Status.ERROR_CHECKSUM);
            Thread.sleep(3000);
          }
 catch (          InterruptedException e) {
          }
        }
        throw new IOException("Terminating due to a checksum error." + ioe);
      }
      if (needsChecksumTranslation) {
        translateChunks(dataBuf,checksumBuf);
      }
    }
    if (checksumReceivedLen == 0 && !streams.isTransientStorage()) {
      checksumBuf=ByteBuffer.allocate(checksumLen);
      diskChecksum.calculateChunkedSums(dataBuf,checksumBuf);
    }
    final boolean shouldNotWriteChecksum=checksumReceivedLen == 0 && streams.isTransientStorage();
    try {
      long onDiskLen=replicaInfo.getBytesOnDisk();
      if (onDiskLen < offsetInBlock) {
        if (onDiskLen % bytesPerChecksum != 0) {
          adjustCrcFilePosition();
        }
        Checksum partialCrc=null;
        if (!shouldNotWriteChecksum && firstByteInBlock % bytesPerChecksum != 0) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("receivePacket for " + block + ": bytesPerChecksum="+ bytesPerChecksum+ " does not divide firstByteInBlock="+ firstByteInBlock);
          }
          long offsetInChecksum=BlockMetadataHeader.getHeaderSize() + onDiskLen / bytesPerChecksum * checksumSize;
          partialCrc=computePartialChunkCrc(onDiskLen,offsetInChecksum);
        }
        int startByteToDisk=(int)(onDiskLen - firstByteInBlock) + dataBuf.arrayOffset() + dataBuf.position();
        int numBytesToDisk=(int)(offsetInBlock - onDiskLen);
        long begin=Time.monotonicNow();
        out.write(dataBuf.array(),startByteToDisk,numBytesToDisk);
        long duration=Time.monotonicNow() - begin;
        if (duration > datanodeSlowLogThresholdMs) {
          LOG.warn("Slow BlockReceiver write data to disk cost:" + duration + "ms (threshold="+ datanodeSlowLogThresholdMs+ "ms)");
        }
        final byte[] lastCrc;
        if (shouldNotWriteChecksum) {
          lastCrc=null;
        }
 else         if (partialCrc != null) {
          if (len > bytesPerChecksum) {
            throw new IOException("Unexpected packet data length for " + block + " from "+ inAddr+ ": a partial chunk must be "+ " sent in an individual packet (data length = "+ len+ " > bytesPerChecksum = "+ bytesPerChecksum+ ")");
          }
          partialCrc.update(dataBuf.array(),startByteToDisk,numBytesToDisk);
          byte[] buf=FSOutputSummer.convertToByteStream(partialCrc,checksumSize);
          lastCrc=copyLastChunkChecksum(buf,checksumSize,buf.length);
          checksumOut.write(buf);
          if (LOG.isDebugEnabled()) {
            LOG.debug("Writing out partial crc for data len " + len);
          }
          partialCrc=null;
        }
 else {
          final int offset=checksumBuf.arrayOffset() + checksumBuf.position();
          final int end=offset + checksumLen;
          lastCrc=copyLastChunkChecksum(checksumBuf.array(),checksumSize,end);
          checksumOut.write(checksumBuf.array(),offset,checksumLen);
        }
        flushOrSync(syncBlock);
        replicaInfo.setLastChecksumAndDataLen(offsetInBlock,lastCrc);
        datanode.metrics.incrBytesWritten(len);
        manageWriterOsCache(offsetInBlock);
      }
    }
 catch (    IOException iex) {
      datanode.checkDiskErrorAsync();
      throw iex;
    }
  }
  if (responder != null && (syncBlock || shouldVerifyChecksum())) {
    ((PacketResponder)responder.getRunnable()).enqueue(seqno,lastPacketInBlock,offsetInBlock,Status.SUCCESS);
  }
  if (isReplaceBlock && (Time.monotonicNow() - lastResponseTime > responseInterval)) {
    BlockOpResponseProto.Builder response=BlockOpResponseProto.newBuilder().setStatus(Status.IN_PROGRESS);
    response.build().writeDelimitedTo(replyOut);
    replyOut.flush();
    lastResponseTime=Time.monotonicNow();
  }
  if (throttler != null) {
    throttler.throttle(len);
  }
  return lastPacketInBlock ? -1 : len;
}
