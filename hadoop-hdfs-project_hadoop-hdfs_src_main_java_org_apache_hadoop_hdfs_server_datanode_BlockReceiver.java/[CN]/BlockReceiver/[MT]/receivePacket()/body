{
  packetReceiver.receiveNextPacket(in);
  PacketHeader header=packetReceiver.getHeader();
  if (LOG.isDebugEnabled()) {
    LOG.debug("Receiving one packet for block " + block + ": "+ header);
  }
  if (header.getOffsetInBlock() > replicaInfo.getNumBytes()) {
    throw new IOException("Received an out-of-sequence packet for " + block + "from "+ inAddr+ " at offset "+ header.getOffsetInBlock()+ ". Expecting packet starting at "+ replicaInfo.getNumBytes());
  }
  if (header.getDataLen() < 0) {
    throw new IOException("Got wrong length during writeBlock(" + block + ") from "+ inAddr+ " at offset "+ header.getOffsetInBlock()+ ": "+ header.getDataLen());
  }
  long offsetInBlock=header.getOffsetInBlock();
  long seqno=header.getSeqno();
  boolean lastPacketInBlock=header.isLastPacketInBlock();
  final int len=header.getDataLen();
  boolean syncBlock=header.getSyncBlock();
  if (syncBlock && lastPacketInBlock) {
    this.syncOnClose=false;
  }
  final long firstByteInBlock=offsetInBlock;
  offsetInBlock+=len;
  if (replicaInfo.getNumBytes() < offsetInBlock) {
    replicaInfo.setNumBytes(offsetInBlock);
  }
  if (responder != null && !syncBlock && !shouldVerifyChecksum()) {
    ((PacketResponder)responder.getRunnable()).enqueue(seqno,lastPacketInBlock,offsetInBlock,Status.SUCCESS);
  }
  if (seqno < 0 && len == 0 && DataNodeFaultInjector.get().dropHeartbeatPacket()) {
    return 0;
  }
  if (mirrorOut != null && !mirrorError) {
    try {
      long begin=Time.monotonicNow();
      packetReceiver.mirrorPacketTo(mirrorOut);
      mirrorOut.flush();
      long now=Time.monotonicNow();
      setLastSentTime(now);
      long duration=now - begin;
      if (duration > datanodeSlowLogThresholdMs) {
        LOG.warn("Slow BlockReceiver write packet to mirror took " + duration + "ms (threshold="+ datanodeSlowLogThresholdMs+ "ms)");
      }
    }
 catch (    IOException e) {
      handleMirrorOutError(e);
    }
  }
  ByteBuffer dataBuf=packetReceiver.getDataSlice();
  ByteBuffer checksumBuf=packetReceiver.getChecksumSlice();
  if (lastPacketInBlock || len == 0) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Receiving an empty packet or the end of the block " + block);
    }
    if (syncBlock) {
      flushOrSync(true);
    }
  }
 else {
    final int checksumLen=diskChecksum.getChecksumSize(len);
    final int checksumReceivedLen=checksumBuf.capacity();
    if (checksumReceivedLen > 0 && checksumReceivedLen != checksumLen) {
      throw new IOException("Invalid checksum length: received length is " + checksumReceivedLen + " but expected length is "+ checksumLen);
    }
    if (checksumReceivedLen > 0 && shouldVerifyChecksum()) {
      try {
        verifyChunks(dataBuf,checksumBuf);
      }
 catch (      IOException ioe) {
        if (responder != null) {
          try {
            ((PacketResponder)responder.getRunnable()).enqueue(seqno,lastPacketInBlock,offsetInBlock,Status.ERROR_CHECKSUM);
            Thread.sleep(3000);
          }
 catch (          InterruptedException e) {
          }
        }
        throw new IOException("Terminating due to a checksum error." + ioe);
      }
      if (needsChecksumTranslation) {
        translateChunks(dataBuf,checksumBuf);
      }
    }
    if (checksumReceivedLen == 0 && !streams.isTransientStorage()) {
      checksumBuf=ByteBuffer.allocate(checksumLen);
      diskChecksum.calculateChunkedSums(dataBuf,checksumBuf);
    }
    final boolean shouldNotWriteChecksum=checksumReceivedLen == 0 && streams.isTransientStorage();
    try {
      long onDiskLen=replicaInfo.getBytesOnDisk();
      if (onDiskLen < offsetInBlock) {
        long partialChunkSizeOnDisk=onDiskLen % bytesPerChecksum;
        long lastChunkBoundary=onDiskLen - partialChunkSizeOnDisk;
        boolean alignedOnDisk=partialChunkSizeOnDisk == 0;
        boolean alignedInPacket=firstByteInBlock % bytesPerChecksum == 0;
        boolean overwriteLastCrc=!alignedOnDisk && !shouldNotWriteChecksum;
        boolean doCrcRecalc=overwriteLastCrc && (lastChunkBoundary != firstByteInBlock);
        if (!alignedInPacket && len > bytesPerChecksum) {
          throw new IOException("Unexpected packet data length for " + block + " from "+ inAddr+ ": a partial chunk must be "+ " sent in an individual packet (data length = "+ len+ " > bytesPerChecksum = "+ bytesPerChecksum+ ")");
        }
        Checksum partialCrc=null;
        if (doCrcRecalc) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("receivePacket for " + block + ": previous write did not end at the chunk boundary."+ " onDiskLen="+ onDiskLen);
          }
          long offsetInChecksum=BlockMetadataHeader.getHeaderSize() + onDiskLen / bytesPerChecksum * checksumSize;
          partialCrc=computePartialChunkCrc(onDiskLen,offsetInChecksum);
        }
        int startByteToDisk=(int)(onDiskLen - firstByteInBlock) + dataBuf.arrayOffset() + dataBuf.position();
        int numBytesToDisk=(int)(offsetInBlock - onDiskLen);
        long begin=Time.monotonicNow();
        out.write(dataBuf.array(),startByteToDisk,numBytesToDisk);
        long duration=Time.monotonicNow() - begin;
        if (duration > maxWriteToDiskMs) {
          maxWriteToDiskMs=duration;
        }
        if (duration > datanodeSlowLogThresholdMs) {
          LOG.warn("Slow BlockReceiver write data to disk cost:" + duration + "ms (threshold="+ datanodeSlowLogThresholdMs+ "ms)");
        }
        final byte[] lastCrc;
        if (shouldNotWriteChecksum) {
          lastCrc=null;
        }
 else {
          int skip=0;
          byte[] crcBytes=null;
          if (overwriteLastCrc) {
            adjustCrcFilePosition();
          }
          if (doCrcRecalc) {
            int bytesToReadForRecalc=(int)(bytesPerChecksum - partialChunkSizeOnDisk);
            if (numBytesToDisk < bytesToReadForRecalc) {
              bytesToReadForRecalc=numBytesToDisk;
            }
            partialCrc.update(dataBuf.array(),startByteToDisk,bytesToReadForRecalc);
            byte[] buf=FSOutputSummer.convertToByteStream(partialCrc,checksumSize);
            crcBytes=copyLastChunkChecksum(buf,checksumSize,buf.length);
            checksumOut.write(buf);
            if (LOG.isDebugEnabled()) {
              LOG.debug("Writing out partial crc for data len " + len + ", skip="+ skip);
            }
            skip++;
          }
          long skippedDataBytes=lastChunkBoundary - firstByteInBlock;
          if (skippedDataBytes > 0) {
            skip+=(int)(skippedDataBytes / bytesPerChecksum) + ((skippedDataBytes % bytesPerChecksum == 0) ? 0 : 1);
          }
          skip*=checksumSize;
          final int offset=checksumBuf.arrayOffset() + checksumBuf.position() + skip;
          final int end=offset + checksumLen - skip;
          if (offset >= end && doCrcRecalc) {
            lastCrc=crcBytes;
          }
 else {
            final int remainingBytes=checksumLen - skip;
            lastCrc=copyLastChunkChecksum(checksumBuf.array(),checksumSize,end);
            checksumOut.write(checksumBuf.array(),offset,remainingBytes);
          }
        }
        flushOrSync(syncBlock);
        replicaInfo.setLastChecksumAndDataLen(offsetInBlock,lastCrc);
        datanode.metrics.incrBytesWritten(len);
        datanode.metrics.incrTotalWriteTime(duration);
        manageWriterOsCache(offsetInBlock);
      }
    }
 catch (    IOException iex) {
      datanode.checkDiskErrorAsync();
      throw iex;
    }
  }
  if (responder != null && (syncBlock || shouldVerifyChecksum())) {
    ((PacketResponder)responder.getRunnable()).enqueue(seqno,lastPacketInBlock,offsetInBlock,Status.SUCCESS);
  }
  if (isReplaceBlock && (Time.monotonicNow() - lastResponseTime > responseInterval)) {
    BlockOpResponseProto.Builder response=BlockOpResponseProto.newBuilder().setStatus(Status.IN_PROGRESS);
    response.build().writeDelimitedTo(replyOut);
    replyOut.flush();
    lastResponseTime=Time.monotonicNow();
  }
  if (throttler != null) {
    throttler.throttle(len);
  }
  return lastPacketInBlock ? -1 : len;
}
