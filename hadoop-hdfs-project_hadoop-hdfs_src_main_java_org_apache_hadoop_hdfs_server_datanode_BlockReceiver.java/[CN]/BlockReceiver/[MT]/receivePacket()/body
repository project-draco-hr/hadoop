{
  packetReceiver.receiveNextPacket(in);
  PacketHeader header=packetReceiver.getHeader();
  if (LOG.isDebugEnabled()) {
    LOG.debug("Receiving one packet for block " + block + ": "+ header);
  }
  if (header.getOffsetInBlock() > replicaInfo.getNumBytes()) {
    throw new IOException("Received an out-of-sequence packet for " + block + "from "+ inAddr+ " at offset "+ header.getOffsetInBlock()+ ". Expecting packet starting at "+ replicaInfo.getNumBytes());
  }
  if (header.getDataLen() < 0) {
    throw new IOException("Got wrong length during writeBlock(" + block + ") from "+ inAddr+ " at offset "+ header.getOffsetInBlock()+ ": "+ header.getDataLen());
  }
  long offsetInBlock=header.getOffsetInBlock();
  long seqno=header.getSeqno();
  boolean lastPacketInBlock=header.isLastPacketInBlock();
  int len=header.getDataLen();
  boolean syncBlock=header.getSyncBlock();
  if (syncBlock && lastPacketInBlock) {
    this.syncOnClose=false;
  }
  long firstByteInBlock=offsetInBlock;
  offsetInBlock+=len;
  if (replicaInfo.getNumBytes() < offsetInBlock) {
    replicaInfo.setNumBytes(offsetInBlock);
  }
  if (responder != null && !syncBlock && !shouldVerifyChecksum()) {
    ((PacketResponder)responder.getRunnable()).enqueue(seqno,lastPacketInBlock,offsetInBlock,Status.SUCCESS);
  }
  if (mirrorOut != null && !mirrorError) {
    try {
      packetReceiver.mirrorPacketTo(mirrorOut);
      mirrorOut.flush();
    }
 catch (    IOException e) {
      handleMirrorOutError(e);
    }
  }
  ByteBuffer dataBuf=packetReceiver.getDataSlice();
  ByteBuffer checksumBuf=packetReceiver.getChecksumSlice();
  if (lastPacketInBlock || len == 0) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Receiving an empty packet or the end of the block " + block);
    }
    if (syncBlock) {
      flushOrSync(true);
    }
  }
 else {
    int checksumLen=((len + bytesPerChecksum - 1) / bytesPerChecksum) * checksumSize;
    if (checksumBuf.capacity() != checksumLen) {
      throw new IOException("Length of checksums in packet " + checksumBuf.capacity() + " does not match calculated checksum "+ "length "+ checksumLen);
    }
    if (shouldVerifyChecksum()) {
      try {
        verifyChunks(dataBuf,checksumBuf);
      }
 catch (      IOException ioe) {
        if (responder != null) {
          try {
            ((PacketResponder)responder.getRunnable()).enqueue(seqno,lastPacketInBlock,offsetInBlock,Status.ERROR_CHECKSUM);
            Thread.sleep(3000);
          }
 catch (          InterruptedException e) {
          }
        }
        throw new IOException("Terminating due to a checksum error." + ioe);
      }
      if (needsChecksumTranslation) {
        translateChunks(dataBuf,checksumBuf);
      }
    }
    byte[] lastChunkChecksum;
    try {
      long onDiskLen=replicaInfo.getBytesOnDisk();
      if (onDiskLen < offsetInBlock) {
        if (onDiskLen % bytesPerChecksum != 0) {
          adjustCrcFilePosition();
        }
        if (firstByteInBlock % bytesPerChecksum != 0) {
          LOG.info("Packet starts at " + firstByteInBlock + " for "+ block+ " which is not a multiple of bytesPerChecksum "+ bytesPerChecksum);
          long offsetInChecksum=BlockMetadataHeader.getHeaderSize() + onDiskLen / bytesPerChecksum * checksumSize;
          computePartialChunkCrc(onDiskLen,offsetInChecksum,bytesPerChecksum);
        }
        int startByteToDisk=(int)(onDiskLen - firstByteInBlock) + dataBuf.arrayOffset() + dataBuf.position();
        int numBytesToDisk=(int)(offsetInBlock - onDiskLen);
        out.write(dataBuf.array(),startByteToDisk,numBytesToDisk);
        if (partialCrc != null) {
          if (len > bytesPerChecksum) {
            throw new IOException("Got wrong length during writeBlock(" + block + ") from "+ inAddr+ " "+ "A packet can have only one partial chunk."+ " len = "+ len+ " bytesPerChecksum "+ bytesPerChecksum);
          }
          partialCrc.update(dataBuf.array(),startByteToDisk,numBytesToDisk);
          byte[] buf=FSOutputSummer.convertToByteStream(partialCrc,checksumSize);
          lastChunkChecksum=Arrays.copyOfRange(buf,buf.length - checksumSize,buf.length);
          checksumOut.write(buf);
          if (LOG.isDebugEnabled()) {
            LOG.debug("Writing out partial crc for data len " + len);
          }
          partialCrc=null;
        }
 else {
          lastChunkChecksum=Arrays.copyOfRange(checksumBuf.array(),checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);
          checksumOut.write(checksumBuf.array(),checksumBuf.arrayOffset() + checksumBuf.position(),checksumLen);
        }
        flushOrSync(syncBlock);
        replicaInfo.setLastChecksumAndDataLen(offsetInBlock,lastChunkChecksum);
        datanode.metrics.incrBytesWritten(len);
        manageWriterOsCache(offsetInBlock);
      }
    }
 catch (    IOException iex) {
      datanode.checkDiskError(iex);
      throw iex;
    }
  }
  if (responder != null && (syncBlock || shouldVerifyChecksum())) {
    ((PacketResponder)responder.getRunnable()).enqueue(seqno,lastPacketInBlock,offsetInBlock,Status.SUCCESS);
  }
  if (throttler != null) {
    throttler.throttle(len);
  }
  return lastPacketInBlock ? -1 : len;
}
