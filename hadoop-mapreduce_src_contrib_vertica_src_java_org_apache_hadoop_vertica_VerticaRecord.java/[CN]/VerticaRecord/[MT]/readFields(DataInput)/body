{
  columns=in.readInt();
  if (types.size() > 0)   types.clear();
  for (int i=0; i < columns; i++)   types.add(in.readInt());
  for (int i=0; i < columns; i++) {
    int type=types.get(i);
switch (type) {
case Types.NULL:
      values.add(null);
    break;
case Types.BIGINT:
  values.add(in.readLong());
break;
case Types.INTEGER:
values.add(in.readInt());
break;
case Types.TINYINT:
case Types.SMALLINT:
values.add(in.readShort());
break;
case Types.REAL:
case Types.DECIMAL:
case Types.NUMERIC:
values.add(new BigDecimal(Text.readString(in)));
break;
case Types.DOUBLE:
values.add(in.readDouble());
break;
case Types.FLOAT:
values.add(in.readFloat());
break;
case Types.BINARY:
case Types.LONGVARBINARY:
case Types.VARBINARY:
values.add(StringUtils.hexStringToByte(Text.readString(in)));
break;
case Types.BIT:
case Types.BOOLEAN:
values.add(in.readBoolean());
break;
case Types.CHAR:
values.add(in.readChar());
break;
case Types.LONGNVARCHAR:
case Types.LONGVARCHAR:
case Types.NCHAR:
case Types.NVARCHAR:
case Types.VARCHAR:
values.add(Text.readString(in));
break;
case Types.DATE:
if (dateString) try {
values.add(new Date(datefmt.parse(Text.readString(in)).getTime()));
}
 catch (ParseException e) {
throw new IOException(e);
}
 else values.add(new Date(in.readLong()));
break;
case Types.TIME:
if (dateString) try {
values.add(new Time(timefmt.parse(Text.readString(in)).getTime()));
}
 catch (ParseException e) {
throw new IOException(e);
}
 else values.add(new Time(in.readLong()));
break;
case Types.TIMESTAMP:
if (dateString) try {
values.add(new Timestamp(tmstmpfmt.parse(Text.readString(in)).getTime()));
}
 catch (ParseException e) {
throw new IOException(e);
}
 else values.add(new Timestamp(in.readLong()));
break;
default :
throw new IOException("Unknown type value " + type);
}
}
}
