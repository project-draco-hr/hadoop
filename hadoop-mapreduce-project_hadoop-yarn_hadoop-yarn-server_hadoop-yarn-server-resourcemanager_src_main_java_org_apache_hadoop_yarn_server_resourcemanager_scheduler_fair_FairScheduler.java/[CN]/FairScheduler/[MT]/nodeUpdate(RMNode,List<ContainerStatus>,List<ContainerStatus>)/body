{
  LOG.info("nodeUpdate: " + nm + " cluster capacity: "+ clusterCapacity);
  eventLog.log("HEARTBEAT",nm.getHostName());
  FSSchedulerNode node=nodes.get(nm.getNodeID());
  for (  ContainerStatus launchedContainer : newlyLaunchedContainers) {
    containerLaunchedOnNode(launchedContainer.getContainerId(),node);
  }
  for (  ContainerStatus completedContainer : completedContainers) {
    ContainerId containerId=completedContainer.getContainerId();
    LOG.debug("Container FINISHED: " + containerId);
    completedContainer(getRMContainer(containerId),completedContainer,RMContainerEventType.FINISHED);
  }
  RMContainer reservedContainer=node.getReservedContainer();
  if (reservedContainer != null) {
    FSSchedulerApp reservedApplication=applications.get(reservedContainer.getApplicationAttemptId());
    LOG.info("Trying to fulfill reservation for application " + reservedApplication.getApplicationId() + " on node: "+ nm);
    FSQueue queue=queueMgr.getQueue(reservedApplication.getQueueName());
    queue.getQueueSchedulable().assignContainer(node,true);
  }
 else {
    int assignedContainers=0;
    while (true) {
      List<FSQueueSchedulable> scheds=this.getQueueSchedulables();
      Collections.sort(scheds,new SchedulingAlgorithms.FairShareComparator());
      boolean assignedContainer=false;
      for (      FSQueueSchedulable sched : scheds) {
        Resource assigned=sched.assignContainer(node,false);
        if (Resources.greaterThan(assigned,Resources.none())) {
          eventLog.log("ASSIGN",nm.getHostName(),assigned);
          assignedContainers++;
          assignedContainer=true;
          break;
        }
      }
      if (!assignedContainer) {
        break;
      }
      if (!assignMultiple) {
        break;
      }
      if ((assignedContainers >= maxAssign) && (maxAssign > 0)) {
        break;
      }
    }
  }
}
