{
  if (failovers >= maxFailovers) {
    return new RetryAction(RetryAction.RetryDecision.FAIL,0,"failovers (" + failovers + ") exceeded maximum allowed ("+ maxFailovers+ ")");
  }
  if (e instanceof ConnectException || e instanceof NoRouteToHostException || e instanceof UnknownHostException|| e instanceof StandbyException|| e instanceof ConnectTimeoutException|| isWrappedStandbyException(e)) {
    return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,failovers == 0 ? 0 : calculateExponentialTime(delayMillis,failovers,maxDelayBase));
  }
 else   if (e instanceof SocketException || (e instanceof IOException && !(e instanceof RemoteException))) {
    if (isMethodIdempotent) {
      return RetryAction.FAILOVER_AND_RETRY;
    }
 else {
      return new RetryAction(RetryAction.RetryDecision.FAIL,0,"the invoked method is not idempotent, and unable to determine " + "whether it was invoked");
    }
  }
 else {
    return fallbackPolicy.shouldRetry(e,retries,failovers,isMethodIdempotent);
  }
}
