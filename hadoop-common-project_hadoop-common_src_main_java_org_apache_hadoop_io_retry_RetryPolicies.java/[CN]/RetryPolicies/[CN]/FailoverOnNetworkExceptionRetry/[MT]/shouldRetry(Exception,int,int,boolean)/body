{
  if (failovers >= maxFailovers) {
    LOG.info("Failovers (" + failovers + ") exceeded maximum allowed ("+ maxFailovers+ ")");
    return RetryAction.FAIL;
  }
  if (e instanceof ConnectException || e instanceof NoRouteToHostException || e instanceof UnknownHostException|| e instanceof StandbyException|| isWrappedStandbyException(e)) {
    return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,failovers == 0 ? 0 : calculateExponentialTime(delayMillis,failovers,maxDelayBase));
  }
 else   if (e instanceof SocketException || (e instanceof IOException && !(e instanceof RemoteException))) {
    if (isMethodIdempotent) {
      return RetryAction.FAILOVER_AND_RETRY;
    }
 else {
      return RetryAction.FAIL;
    }
  }
 else {
    return fallbackPolicy.shouldRetry(e,retries,failovers,isMethodIdempotent);
  }
}
