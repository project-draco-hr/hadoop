{
  if (failovers >= maxFailovers) {
    return new RetryAction(RetryAction.RetryDecision.FAIL,0,"failovers (" + failovers + ") exceeded maximum allowed ("+ maxFailovers+ ")");
  }
  if (e instanceof ConnectException || e instanceof NoRouteToHostException || e instanceof UnknownHostException|| e instanceof StandbyException|| e instanceof ConnectTimeoutException|| isWrappedStandbyException(e)) {
    return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,getFailoverOrRetrySleepTime(failovers));
  }
 else   if (e instanceof SocketException || (e instanceof IOException && !(e instanceof RemoteException))) {
    if (isIdempotentOrAtMostOnce) {
      return RetryAction.FAILOVER_AND_RETRY;
    }
 else {
      return new RetryAction(RetryAction.RetryDecision.FAIL,0,"the invoked method is not idempotent, and unable to determine " + "whether it was invoked");
    }
  }
 else {
    RetriableException re=getWrappedRetriableException(e);
    if (re != null) {
      return new RetryAction(RetryAction.RetryDecision.RETRY,getFailoverOrRetrySleepTime(retries));
    }
 else {
      return fallbackPolicy.shouldRetry(e,retries,failovers,isIdempotentOrAtMostOnce);
    }
  }
}
