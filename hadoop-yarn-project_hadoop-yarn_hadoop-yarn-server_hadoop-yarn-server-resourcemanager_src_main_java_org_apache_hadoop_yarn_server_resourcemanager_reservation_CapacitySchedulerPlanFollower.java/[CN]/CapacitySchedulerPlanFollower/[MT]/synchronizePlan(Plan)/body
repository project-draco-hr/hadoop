{
  String planQueueName=plan.getQueueName();
  if (LOG.isDebugEnabled()) {
    LOG.debug("Running plan follower edit policy for plan: " + planQueueName);
  }
  long step=plan.getStep();
  long now=clock.getTime();
  if (now % step != 0) {
    now+=step - (now % step);
  }
  CSQueue queue=scheduler.getQueue(planQueueName);
  if (!(queue instanceof PlanQueue)) {
    LOG.error("The Plan is not an PlanQueue!");
    return;
  }
  PlanQueue planQueue=(PlanQueue)queue;
  Resource clusterResources=scheduler.getClusterResource();
  float planAbsCap=planQueue.getAbsoluteCapacity();
  Resource planResources=Resources.multiply(clusterResources,planAbsCap);
  plan.setTotalCapacity(planResources);
  Set<ReservationAllocation> currentReservations=plan.getReservationsAtTime(now);
  Set<String> curReservationNames=new HashSet<String>();
  Resource reservedResources=Resource.newInstance(0,0);
  int numRes=0;
  if (currentReservations != null) {
    numRes=currentReservations.size();
    for (    ReservationAllocation reservation : currentReservations) {
      curReservationNames.add(reservation.getReservationId().toString());
      Resources.addTo(reservedResources,reservation.getResourcesAtTime(now));
    }
  }
  String defReservationQueue=planQueueName + PlanQueue.DEFAULT_QUEUE_SUFFIX;
  if (scheduler.getQueue(defReservationQueue) == null) {
    ReservationQueue defQueue=new ReservationQueue(scheduler,defReservationQueue,planQueue);
    try {
      scheduler.addQueue(defQueue);
    }
 catch (    SchedulerDynamicEditException e) {
      LOG.warn("Exception while trying to create default reservation queue for plan: {}",planQueueName,e);
    }
  }
  curReservationNames.add(defReservationQueue);
  if (Resources.greaterThan(scheduler.getResourceCalculator(),clusterResources,reservedResources,planResources)) {
    try {
      plan.getReplanner().plan(plan,null);
    }
 catch (    PlanningException e) {
      LOG.warn("Exception while trying to replan: {}",planQueueName,e);
    }
  }
  List<CSQueue> resQueues=planQueue.getChildQueues();
  Set<String> expired=new HashSet<String>();
  for (  CSQueue resQueue : resQueues) {
    String resQueueName=resQueue.getQueueName();
    if (curReservationNames.contains(resQueueName)) {
      curReservationNames.remove(resQueueName);
    }
 else {
      expired.add(resQueueName);
    }
  }
  cleanupExpiredQueues(plan.getMoveOnExpiry(),expired,defReservationQueue);
  float totalAssignedCapacity=0f;
  if (currentReservations != null) {
    try {
      scheduler.setEntitlement(defReservationQueue,new QueueEntitlement(0f,1.0f));
    }
 catch (    YarnException e) {
      LOG.warn("Exception while trying to release default queue capacity for plan: {}",planQueueName,e);
    }
    List<ReservationAllocation> sortedAllocations=sortByDelta(new ArrayList<ReservationAllocation>(currentReservations),now);
    for (    ReservationAllocation res : sortedAllocations) {
      String currResId=res.getReservationId().toString();
      if (curReservationNames.contains(currResId)) {
        ReservationQueue resQueue=new ReservationQueue(scheduler,currResId,planQueue);
        try {
          scheduler.addQueue(resQueue);
        }
 catch (        SchedulerDynamicEditException e) {
          LOG.warn("Exception while trying to activate reservation: {} for plan: {}",currResId,planQueueName,e);
        }
      }
      Resource capToAssign=res.getResourcesAtTime(now);
      float targetCapacity=0f;
      if (planResources.getMemory() > 0 && planResources.getVirtualCores() > 0) {
        targetCapacity=Resources.divide(scheduler.getResourceCalculator(),clusterResources,capToAssign,planResources);
      }
      if (LOG.isDebugEnabled()) {
        LOG.debug("Assigning capacity of {} to queue {} with target capacity {}",capToAssign,currResId,targetCapacity);
      }
      float maxCapacity=1.0f;
      if (res.containsGangs()) {
        maxCapacity=targetCapacity;
      }
      try {
        scheduler.setEntitlement(currResId,new QueueEntitlement(targetCapacity,maxCapacity));
      }
 catch (      YarnException e) {
        LOG.warn("Exception while trying to size reservation for plan: {}",currResId,planQueueName,e);
      }
      totalAssignedCapacity+=targetCapacity;
    }
  }
  float defQCap=1.0f - totalAssignedCapacity;
  if (LOG.isDebugEnabled()) {
    LOG.debug("PlanFollowerEditPolicyTask: total Plan Capacity: {} " + "currReservation: {} default-queue capacity: {}",planResources,numRes,defQCap);
  }
  try {
    scheduler.setEntitlement(defReservationQueue,new QueueEntitlement(defQCap,1.0f));
  }
 catch (  YarnException e) {
    LOG.warn("Exception while trying to reclaim default queue capacity for plan: {}",planQueueName,e);
  }
  try {
    plan.archiveCompletedReservations(now);
  }
 catch (  PlanningException e) {
    LOG.error("Exception in archiving completed reservations: ",e);
  }
  LOG.info("Finished iteration of plan follower edit policy for plan: " + planQueueName);
}
