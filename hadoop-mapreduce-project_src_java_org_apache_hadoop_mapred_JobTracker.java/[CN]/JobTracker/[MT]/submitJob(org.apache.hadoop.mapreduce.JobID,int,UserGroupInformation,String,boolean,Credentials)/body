{
  JobID jobId=null;
  JobInfo jobInfo;
synchronized (this) {
    jobId=JobID.downgrade(jobID);
    if (jobs.containsKey(jobId)) {
      return jobs.get(jobId).getStatus();
    }
    jobInfo=new JobInfo(jobId,new Text(ugi.getShortUserName()),new Path(jobSubmitDir));
  }
  JobInProgress job=new JobInProgress(this,this.conf,restartCount,jobInfo,ts);
synchronized (this) {
    try {
      checkQueueValidity(job);
    }
 catch (    IOException ioe) {
      LOG.error("Queue given for job " + job.getJobID() + " is not valid: "+ ioe);
      throw ioe;
    }
    try {
      aclsManager.checkAccess(job,ugi,Operation.SUBMIT_JOB);
    }
 catch (    AccessControlException ace) {
      LOG.warn("Access denied for user " + job.getJobConf().getUser() + ". Ignoring job "+ jobId,ace);
      throw ace;
    }
    try {
      this.taskScheduler.checkJobSubmission(job);
    }
 catch (    IOException ioe) {
      LOG.error("Problem in submitting job " + jobId,ioe);
      throw ioe;
    }
    try {
      checkMemoryRequirements(job);
    }
 catch (    IOException ioe) {
      throw ioe;
    }
    if (!recovered) {
      Path jobDir=getSystemDirectoryForJob(jobId);
      FileSystem.mkdirs(fs,jobDir,new FsPermission(SYSTEM_DIR_PERMISSION));
      FSDataOutputStream out=fs.create(getSystemFileForJob(jobId));
      jobInfo.write(out);
      out.close();
    }
    return addJob(jobId,job);
  }
}
