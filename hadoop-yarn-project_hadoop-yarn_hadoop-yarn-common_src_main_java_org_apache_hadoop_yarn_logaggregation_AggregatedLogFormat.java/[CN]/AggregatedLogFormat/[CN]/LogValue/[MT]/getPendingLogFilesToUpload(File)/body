{
  Set<File> candidates=new HashSet<File>(Arrays.asList(containerLogDir.listFiles()));
  for (  File logFile : candidates) {
    this.allExistingFileMeta.add(getLogFileMetaData(logFile));
  }
  if (this.logAggregationContext != null && candidates.size() > 0) {
    if (this.logAggregationContext.getIncludePattern() != null && !this.logAggregationContext.getIncludePattern().isEmpty()) {
      filterFiles(this.logAggregationContext.getIncludePattern(),candidates,false);
    }
    if (this.logAggregationContext.getExcludePattern() != null && !this.logAggregationContext.getExcludePattern().isEmpty()) {
      filterFiles(this.logAggregationContext.getExcludePattern(),candidates,true);
    }
    Iterable<File> mask=Iterables.filter(candidates,new Predicate<File>(){
      @Override public boolean apply(      File next){
        return !alreadyUploadedLogFiles.contains(getLogFileMetaData(next));
      }
    }
);
    candidates=Sets.newHashSet(mask);
  }
  return candidates;
}
