{
  Set<File> candidates=new HashSet<File>(Arrays.asList(containerLogDir.listFiles()));
  for (  File logFile : candidates) {
    this.allExistingFileMeta.add(getLogFileMetaData(logFile));
  }
  if (logRetentionContext != null && !logRetentionContext.shouldRetainLog()) {
    obseleteRetentionLogFiles.addAll(candidates);
    candidates.clear();
    return candidates;
  }
  if (this.logAggregationContext != null && candidates.size() > 0) {
    filterFiles(this.appFinished ? this.logAggregationContext.getIncludePattern() : this.logAggregationContext.getRolledLogsIncludePattern(),candidates,false);
    filterFiles(this.appFinished ? this.logAggregationContext.getExcludePattern() : this.logAggregationContext.getRolledLogsExcludePattern(),candidates,true);
    Iterable<File> mask=Iterables.filter(candidates,new Predicate<File>(){
      @Override public boolean apply(      File next){
        return !alreadyUploadedLogFiles.contains(getLogFileMetaData(next));
      }
    }
);
    candidates=Sets.newHashSet(mask);
  }
  return candidates;
}
