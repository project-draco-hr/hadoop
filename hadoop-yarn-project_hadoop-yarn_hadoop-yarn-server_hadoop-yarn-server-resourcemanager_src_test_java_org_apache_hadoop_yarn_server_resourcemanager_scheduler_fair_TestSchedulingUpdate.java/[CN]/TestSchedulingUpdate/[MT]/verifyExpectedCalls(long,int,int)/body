{
  boolean verified=false;
  int count=0;
  while (count < 100) {
    if (scheduler.fsOpDurations.hasUpdateThreadRunChanged()) {
      break;
    }
    count++;
    Thread.sleep(10);
  }
  assertTrue("Update Thread has not run based on its metrics",scheduler.fsOpDurations.hasUpdateThreadRunChanged());
  assertEquals("Root queue metrics memory does not have expected value",memory,scheduler.getRootQueueMetrics().getAvailableMB());
  assertEquals("Root queue metrics cpu does not have expected value",vcores,scheduler.getRootQueueMetrics().getAvailableVirtualCores());
  MetricsCollectorImpl collector=new MetricsCollectorImpl();
  scheduler.fsOpDurations.getMetrics(collector,true);
  MetricsRecord record=collector.getRecords().get(0);
  for (  AbstractMetric abstractMetric : record.metrics()) {
    if (abstractMetric.name().contains("UpdateThreadRunNumOps")) {
      assertEquals("Update Thread did not run expected number of times " + "based on metric record count",expectedCalls,abstractMetric.value());
      verified=true;
    }
  }
  assertTrue("Did not find metric for UpdateThreadRunNumOps",verified);
}
