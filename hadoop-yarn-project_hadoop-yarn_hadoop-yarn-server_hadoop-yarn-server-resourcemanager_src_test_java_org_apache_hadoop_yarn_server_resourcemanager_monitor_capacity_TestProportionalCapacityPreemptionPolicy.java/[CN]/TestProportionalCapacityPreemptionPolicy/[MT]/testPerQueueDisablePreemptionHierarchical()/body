{
  int[][] qData=new int[][]{{200,100,50,50,100,10,90},{200,200,200,200,200,200,200},{200,110,60,50,90,90,0},{10,0,0,0,10,0,10},{0,0,0,0,0,0,0},{4,2,1,1,2,1,1},{-1,-1,1,1,-1,1,1},{2,2,0,0,2,0,0}};
  ProportionalCapacityPreemptionPolicy policy=buildPolicy(qData);
  policy.editSchedule();
  ApplicationAttemptId expectedAttemptOnQueueB=ApplicationAttemptId.newInstance(appA.getApplicationId(),appA.getAttemptId());
  assertTrue("appA should be running on queueB",mCS.getAppsInQueue("queueB").contains(expectedAttemptOnQueueB));
  verify(mDisp,times(9)).handle(argThat(new IsPreemptionRequestFor(appA)));
  setup();
  schedConf.setBoolean(BASE_YARN_RM_PREEMPTION + "root.queueA.queueB" + SUFFIX_DISABLE_PREEMPTION,true);
  ProportionalCapacityPreemptionPolicy policy2=buildPolicy(qData);
  policy2.editSchedule();
  ApplicationAttemptId expectedAttemptOnQueueC=ApplicationAttemptId.newInstance(appB.getApplicationId(),appB.getAttemptId());
  ApplicationAttemptId expectedAttemptOnQueueE=ApplicationAttemptId.newInstance(appC.getApplicationId(),appC.getAttemptId());
  assertTrue("appB should be running on queueC",mCS.getAppsInQueue("queueC").contains(expectedAttemptOnQueueC));
  assertTrue("appC should be running on queueE",mCS.getAppsInQueue("queueE").contains(expectedAttemptOnQueueE));
  verify(mDisp,never()).handle(argThat(new IsPreemptionRequestFor(appA)));
  verify(mDisp,times(9)).handle(argThat(new IsPreemptionRequestFor(appC)));
}
