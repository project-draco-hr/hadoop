{
  checkNotClosed();
  if (wrappedStream == null) {
    return;
  }
  long diff=targetPos - pos;
  if (diff > 0) {
    int available=wrappedStream.available();
    long forwardSeekRange=Math.max(readahead,available);
    long remainingInCurrentRequest=remainingInCurrentRequest();
    long forwardSeekLimit=Math.min(remainingInCurrentRequest,forwardSeekRange);
    boolean skipForward=remainingInCurrentRequest > 0 && diff <= forwardSeekLimit;
    if (skipForward) {
      LOG.debug("Forward seek on {}, of {} bytes",uri,diff);
      streamStatistics.seekForwards(diff);
      long skipped=wrappedStream.skip(diff);
      if (skipped > 0) {
        pos+=skipped;
        incrementBytesRead(diff);
      }
      if (pos == targetPos) {
        return;
      }
 else {
        LOG.warn("Failed to seek on {} to {}. Current position {}",uri,targetPos,pos);
      }
    }
  }
 else   if (diff < 0) {
    streamStatistics.seekBackwards(diff);
  }
 else {
    if (remainingInCurrentRequest() > 0) {
      return;
    }
  }
  closeStream("seekInStream()",this.contentRangeFinish);
  pos=targetPos;
}
