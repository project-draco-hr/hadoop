{
  if (dest.isFile()) {
    return;
  }
  Path destPath=dest.getPath();
  String destStr=destPath.toUri().getPath();
  if (destFs.exists(new Path(destPath,destPath.getName() + HAR_SUFFIX))) {
    return;
  }
  FileStatus[] files=null;
  files=destFs.listStatus(destPath);
  boolean shouldHar=false;
  if (files != null) {
    shouldHar=files.length > 0;
    for (    FileStatus one : files) {
      if (one.isDirectory()) {
        recurseHar(info,destFs,one,destPrefix,srcFs,cutoff,tmpHarPath);
        shouldHar=false;
      }
 else       if (one.getModificationTime() > cutoff) {
        if (shouldHar) {
          LOG.info("Cannot archive " + destPath + " because "+ one.getPath()+ " was modified after cutoff");
          shouldHar=false;
        }
      }
    }
    if (shouldHar) {
      String src=destStr.replaceFirst(destPrefix,"");
      Path srcPath=new Path(src);
      FileStatus[] statuses=srcFs.listStatus(srcPath);
      Path destPathPrefix=new Path(destPrefix).makeQualified(destFs);
      if (statuses != null) {
        for (        FileStatus status : statuses) {
          if (getParityFile(destPathPrefix,status.getPath().makeQualified(srcFs)) == null) {
            LOG.info("Cannot archive " + destPath + " because it doesn't contain parity file for "+ status.getPath().makeQualified(srcFs)+ " on destination "+ destPathPrefix);
            shouldHar=false;
            break;
          }
        }
      }
    }
  }
  if (shouldHar) {
    LOG.info("Archiving " + dest.getPath() + " to "+ tmpHarPath);
    singleHar(info,destFs,dest,tmpHarPath);
  }
}
