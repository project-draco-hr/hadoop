{
  int vc=0;
  final int vlen;
  final int preRec=nRec;
  final int vcCheck, recCheck;
  ((StringBuilder)fmt.out()).setLength(keylen);
  if (25 == key.getLength()) {
    recCheck=1;
switch ((char)key.getBytes()[0]) {
case 'A':
      vlen=getValLen(++aKey,nMaps) - 128;
    vcCheck=aKey;
  break;
case 'B':
vlen=getValLen(++bKey,nMaps);
vcCheck=bKey;
break;
default :
vlen=vcCheck=-1;
fail("Unexpected tag on record: " + ((char)key.getBytes()[24]));
}
kb.set((char)key.getBytes()[0] + fmt.format(tagfmt,vcCheck).toString());
}
 else {
kb.set(fmt.format(tagfmt,++nKey).toString());
vlen=1000;
recCheck=nMaps;
vcCheck=(nMaps * (nMaps - 1)) >>> 1;
}
assertEquals(kb,key);
while (values.hasNext()) {
final Text val=values.next();
vc+=val.getBytes()[0];
assertEquals(0,WritableComparator.compareBytes(vb.getBytes(),1,vlen - 1,val.getBytes(),1,val.getLength() - 1));
out.collect(key,val);
++nRec;
}
assertEquals("Bad rec count for " + key,recCheck,nRec - preRec);
assertEquals("Bad rec group for " + key,vcCheck,vc);
}
