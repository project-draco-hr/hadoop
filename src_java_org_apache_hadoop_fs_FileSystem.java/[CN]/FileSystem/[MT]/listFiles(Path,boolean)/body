{
  return new Iterator<LocatedFileStatus>(){
    private Stack<Iterator<LocatedFileStatus>> itors=new Stack<Iterator<LocatedFileStatus>>();
    Iterator<LocatedFileStatus> curItor=listLocatedStatus(f);
    LocatedFileStatus curFile;
    /** 
 * {@inheritDoc}
 * @return {@inheritDog} 
 * @throws Runtimeexception if any IOException occurs during traversal;
 * the IOException is set as the cause of the RuntimeException
 */
    @Override public boolean hasNext(){
      while (curFile == null) {
        if (curItor.hasNext()) {
          handleFileStat(curItor.next());
        }
 else         if (!itors.empty()) {
          curItor=itors.pop();
        }
 else {
          return false;
        }
      }
      return true;
    }
    /** 
 * Process the input stat.
 * If it is a file, return the file stat.
 * If it is a directory, tranverse the directory if recursive is true;
 * ignore it if recursive is false.
 * @param stat input status
 * @throws RuntimeException if any io error occurs; the io exception
 * is set as the cause of RuntimeException
 */
    private void handleFileStat(    LocatedFileStatus stat){
      try {
        if (stat.isFile()) {
          curFile=stat;
        }
 else         if (recursive) {
          itors.push(curItor);
          curItor=listLocatedStatus(stat.getPath());
        }
      }
 catch (      IOException ioe) {
        throw (RuntimeException)new RuntimeException().initCause(ioe);
      }
    }
    /** 
 * {@inheritDoc}
 * @return {@inheritDoc} 
 * @throws Runtimeexception if any IOException occurs during traversal;
 * the IOException is set as the cause of the RuntimeException
 * @exception {@inheritDoc}
 */
    @Override public LocatedFileStatus next(){
      if (hasNext()) {
        LocatedFileStatus result=curFile;
        curFile=null;
        return result;
      }
      throw new java.util.NoSuchElementException("No more entry in " + f);
    }
    @Override public void remove(){
      throw new UnsupportedOperationException("Remove is not supported");
    }
  }
;
}
