{
  TaskTrackerStatus taskTrackerStatus=taskTracker.getStatus();
  final int numTaskTrackers=taskTrackerManager.getClusterStatus().getTaskTrackers();
  Collection<JobInProgress> jobQueue=jobQueueJobInProgressListener.getJobQueue();
  Task task;
  final int mapTasksNumber=taskTrackerStatus.countMapTasks();
  final int reduceTasksNumber=taskTrackerStatus.countReduceTasks();
  final int maximumMapTasksNumber=taskTrackerStatus.getMaxMapSlots();
  final int maximumReduceTasksNumber=taskTrackerStatus.getMaxReduceSlots();
  final int[] maxMapAndReduceLoad=getMaxMapAndReduceLoad(maximumMapTasksNumber,maximumReduceTasksNumber);
  final int maximumMapLoad=maxMapAndReduceLoad[0];
  final int maximumReduceLoad=maxMapAndReduceLoad[1];
  final int beginAtStep;
  if (maxTasksPerJob != Long.MAX_VALUE) {
    beginAtStep=0;
  }
 else {
    beginAtStep=2;
  }
  List<Task> assignedTasks=new ArrayList<Task>();
  scheduleTasks:   for (int step=beginAtStep; step <= 3; ++step) {
    if ((step == 0 || step == 2) && mapTasksNumber >= maximumMapLoad || (step == 1 || step == 3) && reduceTasksNumber >= maximumReduceLoad) {
      continue;
    }
synchronized (jobQueue) {
      for (      JobInProgress job : jobQueue) {
        if (job.getStatus().getRunState() != JobStatus.RUNNING) {
          continue;
        }
        if ((step == 0 || step == 1) && (job.runningMaps() + job.runningReduces() >= maxTasksPerJob)) {
          continue;
        }
        if (step == 0 || step == 2) {
          task=job.obtainNewMapTask(taskTrackerStatus,numTaskTrackers,taskTrackerManager.getNumberOfUniqueHosts());
        }
 else {
          task=job.obtainNewReduceTask(taskTrackerStatus,numTaskTrackers,taskTrackerManager.getNumberOfUniqueHosts());
        }
        if (task != null) {
          assignedTasks.add(task);
          break scheduleTasks;
        }
      }
    }
  }
  return assignedTasks;
}
