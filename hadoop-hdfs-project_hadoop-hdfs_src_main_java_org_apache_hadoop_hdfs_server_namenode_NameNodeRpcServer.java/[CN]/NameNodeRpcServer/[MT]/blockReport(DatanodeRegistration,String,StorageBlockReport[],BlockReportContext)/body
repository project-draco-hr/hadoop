{
  checkNNStartup();
  verifyRequest(nodeReg);
  if (blockStateChangeLog.isDebugEnabled()) {
    blockStateChangeLog.debug("*BLOCK* NameNode.blockReport: " + "from " + nodeReg + ", reports.length="+ reports.length);
  }
  final BlockManager bm=namesystem.getBlockManager();
  boolean noStaleStorages=false;
  for (int r=0; r < reports.length; r++) {
    final BlockListAsLongs blocks=reports[r].getBlocks();
    if (!blocks.isStorageReport()) {
      final int index=r;
      noStaleStorages=bm.runBlockOp(new Callable<Boolean>(){
        @Override public Boolean call() throws IOException {
          return bm.processReport(nodeReg,reports[index].getStorage(),blocks,context);
        }
      }
);
      metrics.incrStorageBlockReportOps();
    }
  }
  BlockManagerFaultInjector.getInstance().incomingBlockReportRpc(nodeReg,context);
  if (nn.getFSImage().isUpgradeFinalized() && context.getTotalRpcs() == context.getCurRpc() + 1) {
    Set<String> storageIDsInBlockReport=new HashSet<>();
    for (    StorageBlockReport report : reports) {
      storageIDsInBlockReport.add(report.getStorage().getStorageID());
    }
    bm.removeZombieStorages(nodeReg,context,storageIDsInBlockReport);
  }
  if (nn.getFSImage().isUpgradeFinalized() && !namesystem.isRollingUpgrade() && !nn.isStandbyState()&& noStaleStorages) {
    return new FinalizeCommand(poolId);
  }
  return null;
}
