{
  int len=(int)Math.min(endOffset - offset,(((long)bytesPerChecksum) * ((long)maxChunks)));
  int numChunks=(len + bytesPerChecksum - 1) / bytesPerChecksum;
  int packetLen=len + numChunks * checksumSize + 4;
  boolean lastDataPacket=offset + len == endOffset && len > 0;
  pkt.clear();
  PacketHeader header=new PacketHeader(packetLen,offset,seqno,(len == 0),len);
  header.putInBuffer(pkt);
  int checksumOff=pkt.position();
  int checksumLen=numChunks * checksumSize;
  byte[] buf=pkt.array();
  if (checksumSize > 0 && checksumIn != null) {
    try {
      checksumIn.readFully(buf,checksumOff,checksumLen);
    }
 catch (    IOException e) {
      LOG.warn(" Could not read or failed to veirfy checksum for data" + " at offset " + offset + " for block "+ block+ " got : "+ StringUtils.stringifyException(e));
      IOUtils.closeStream(checksumIn);
      checksumIn=null;
      if (corruptChecksumOk) {
        if (checksumOff < checksumLen) {
          Arrays.fill(buf,checksumOff,checksumLen,(byte)0);
        }
      }
 else {
        throw e;
      }
    }
    if (lastDataPacket && lastChunkChecksum != null) {
      int start=checksumOff + checksumLen - checksumSize;
      byte[] updatedChecksum=lastChunkChecksum.getChecksum();
      if (updatedChecksum != null) {
        System.arraycopy(updatedChecksum,0,buf,start,checksumSize);
      }
    }
  }
  int dataOff=checksumOff + checksumLen;
  if (blockInPosition < 0) {
    IOUtils.readFully(blockIn,buf,dataOff,len);
    if (verifyChecksum) {
      int dOff=dataOff;
      int cOff=checksumOff;
      int dLeft=len;
      for (int i=0; i < numChunks; i++) {
        checksum.reset();
        int dLen=Math.min(dLeft,bytesPerChecksum);
        checksum.update(buf,dOff,dLen);
        if (!checksum.compare(buf,cOff)) {
          long failedPos=offset + len - dLeft;
          throw new ChecksumException("Checksum failed at " + failedPos,failedPos);
        }
        dLeft-=dLen;
        dOff+=dLen;
        cOff+=checksumSize;
      }
    }
  }
  try {
    if (blockInPosition >= 0) {
      SocketOutputStream sockOut=(SocketOutputStream)out;
      sockOut.write(buf,0,dataOff);
      sockOut.transferToFully(((FileInputStream)blockIn).getChannel(),blockInPosition,len);
      blockInPosition+=len;
    }
 else {
      out.write(buf,0,dataOff + len);
    }
  }
 catch (  IOException e) {
    LOG.error("BlockSender.sendChunks() exception: " + StringUtils.stringifyException(e));
    throw ioeToSocketException(e);
  }
  if (throttler != null) {
    throttler.throttle(packetLen);
  }
  return len;
}
