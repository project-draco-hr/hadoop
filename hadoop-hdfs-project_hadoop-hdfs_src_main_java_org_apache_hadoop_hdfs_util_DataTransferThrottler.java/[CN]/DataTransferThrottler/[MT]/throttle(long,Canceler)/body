{
  if (numOfBytes <= 0) {
    return;
  }
  curReserve-=numOfBytes;
  bytesAlreadyUsed+=numOfBytes;
  while (curReserve <= 0) {
    if (canceler != null && canceler.isCancelled()) {
      return;
    }
    long now=monotonicNow();
    long curPeriodEnd=curPeriodStart + period;
    if (now < curPeriodEnd) {
      try {
        wait(curPeriodEnd - now);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        break;
      }
    }
 else     if (now < (curPeriodStart + periodExtension)) {
      curPeriodStart=curPeriodEnd;
      curReserve+=bytesPerPeriod;
    }
 else {
      curPeriodStart=now;
      curReserve=bytesPerPeriod - bytesAlreadyUsed;
    }
  }
  bytesAlreadyUsed-=numOfBytes;
}
