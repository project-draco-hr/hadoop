{
  checkOpen();
  Preconditions.checkArgument(length >= 0);
  LocatedBlocks blockLocations=callGetBlockLocations(namenode,src,0,length);
  if (null == blockLocations) {
    throw new FileNotFoundException("File does not exist: " + src);
  }
  if (blockLocations.isUnderConstruction()) {
    throw new IOException("Fail to get checksum, since file " + src + " is under construction.");
  }
  List<LocatedBlock> locatedblocks=blockLocations.getLocatedBlocks();
  final DataOutputBuffer md5out=new DataOutputBuffer();
  int bytesPerCRC=-1;
  DataChecksum.Type crcType=DataChecksum.Type.DEFAULT;
  long crcPerBlock=0;
  boolean refetchBlocks=false;
  int lastRetriedIndex=-1;
  long remaining=length;
  if (src.contains(HdfsConstants.SEPARATOR_DOT_SNAPSHOT_DIR_SEPARATOR)) {
    remaining=Math.min(length,blockLocations.getFileLength());
  }
  for (int i=0; i < locatedblocks.size() && remaining > 0; i++) {
    if (refetchBlocks) {
      blockLocations=callGetBlockLocations(namenode,src,0,length);
      if (null == blockLocations) {
        throw new FileNotFoundException("File does not exist: " + src);
      }
      if (blockLocations.isUnderConstruction()) {
        throw new IOException("Fail to get checksum, since file " + src + " is under construction.");
      }
      locatedblocks=blockLocations.getLocatedBlocks();
      refetchBlocks=false;
    }
    LocatedBlock lb=locatedblocks.get(i);
    final ExtendedBlock block=lb.getBlock();
    if (remaining < block.getNumBytes()) {
      block.setNumBytes(remaining);
    }
    remaining-=block.getNumBytes();
    final DatanodeInfo[] datanodes=lb.getLocations();
    final int timeout=3000 * datanodes.length + dfsClientConf.getSocketTimeout();
    boolean done=false;
    for (int j=0; !done && j < datanodes.length; j++) {
      DataOutputStream out=null;
      DataInputStream in=null;
      try {
        IOStreamPair pair=connectToDN(datanodes[j],timeout,lb);
        out=new DataOutputStream(new BufferedOutputStream(pair.out,smallBufferSize));
        in=new DataInputStream(pair.in);
        if (LOG.isDebugEnabled()) {
          LOG.debug("write to " + datanodes[j] + ": "+ Op.BLOCK_CHECKSUM+ ", block="+ block);
        }
        new Sender(out).blockChecksum(block,lb.getBlockToken());
        final BlockOpResponseProto reply=BlockOpResponseProto.parseFrom(PBHelperClient.vintPrefixed(in));
        String logInfo="for block " + block + " from datanode "+ datanodes[j];
        DataTransferProtoUtil.checkBlockOpStatus(reply,logInfo);
        OpBlockChecksumResponseProto checksumData=reply.getChecksumResponse();
        final int bpc=checksumData.getBytesPerCrc();
        if (i == 0) {
          bytesPerCRC=bpc;
        }
 else         if (bpc != bytesPerCRC) {
          throw new IOException("Byte-per-checksum not matched: bpc=" + bpc + " but bytesPerCRC="+ bytesPerCRC);
        }
        final long cpb=checksumData.getCrcPerBlock();
        if (locatedblocks.size() > 1 && i == 0) {
          crcPerBlock=cpb;
        }
        final MD5Hash md5=new MD5Hash(checksumData.getMd5().toByteArray());
        md5.write(md5out);
        final DataChecksum.Type ct;
        if (checksumData.hasCrcType()) {
          ct=PBHelperClient.convert(checksumData.getCrcType());
        }
 else {
          LOG.debug("Retrieving checksum from an earlier-version DataNode: " + "inferring checksum by reading first byte");
          ct=inferChecksumTypeByReading(lb,datanodes[j]);
        }
        if (i == 0) {
          crcType=ct;
        }
 else         if (crcType != DataChecksum.Type.MIXED && crcType != ct) {
          crcType=DataChecksum.Type.MIXED;
        }
        done=true;
        if (LOG.isDebugEnabled()) {
          if (i == 0) {
            LOG.debug("set bytesPerCRC=" + bytesPerCRC + ", crcPerBlock="+ crcPerBlock);
          }
          LOG.debug("got reply from " + datanodes[j] + ": md5="+ md5);
        }
      }
 catch (      InvalidBlockTokenException ibte) {
        if (i > lastRetriedIndex) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Got access token error in response to OP_BLOCK_CHECKSUM " + "for file " + src + " for block "+ block+ " from datanode "+ datanodes[j]+ ". Will retry the block once.");
          }
          lastRetriedIndex=i;
          done=true;
          i--;
          refetchBlocks=true;
          break;
        }
      }
catch (      IOException ie) {
        LOG.warn("src=" + src + ", datanodes["+ j+ "]="+ datanodes[j],ie);
      }
 finally {
        IOUtils.closeStream(in);
        IOUtils.closeStream(out);
      }
    }
    if (!done) {
      throw new IOException("Fail to get block MD5 for " + block);
    }
  }
  final MD5Hash fileMD5=MD5Hash.digest(md5out.getData());
switch (crcType) {
case CRC32:
    return new MD5MD5CRC32GzipFileChecksum(bytesPerCRC,crcPerBlock,fileMD5);
case CRC32C:
  return new MD5MD5CRC32CastagnoliFileChecksum(bytesPerCRC,crcPerBlock,fileMD5);
default :
if (locatedblocks.size() == 0) {
  return new MD5MD5CRC32GzipFileChecksum(0,0,fileMD5);
}
return null;
}
}
