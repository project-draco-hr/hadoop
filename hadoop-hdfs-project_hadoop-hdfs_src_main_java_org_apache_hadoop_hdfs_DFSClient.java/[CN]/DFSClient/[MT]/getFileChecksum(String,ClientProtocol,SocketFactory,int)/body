{
  List<LocatedBlock> locatedblocks=callGetBlockLocations(namenode,src,0,Long.MAX_VALUE).getLocatedBlocks();
  final DataOutputBuffer md5out=new DataOutputBuffer();
  int bytesPerCRC=0;
  long crcPerBlock=0;
  boolean refetchBlocks=false;
  int lastRetriedIndex=-1;
  for (int i=0; i < locatedblocks.size(); i++) {
    if (refetchBlocks) {
      locatedblocks=callGetBlockLocations(namenode,src,0,Long.MAX_VALUE).getLocatedBlocks();
      refetchBlocks=false;
    }
    LocatedBlock lb=locatedblocks.get(i);
    final ExtendedBlock block=lb.getBlock();
    final DatanodeInfo[] datanodes=lb.getLocations();
    final int timeout=3000 * datanodes.length + socketTimeout;
    boolean done=false;
    for (int j=0; !done && j < datanodes.length; j++) {
      Socket sock=null;
      DataOutputStream out=null;
      DataInputStream in=null;
      try {
        sock=socketFactory.createSocket();
        NetUtils.connect(sock,NetUtils.createSocketAddr(datanodes[j].getName()),timeout);
        sock.setSoTimeout(timeout);
        out=new DataOutputStream(new BufferedOutputStream(NetUtils.getOutputStream(sock),HdfsConstants.SMALL_BUFFER_SIZE));
        in=new DataInputStream(NetUtils.getInputStream(sock));
        if (LOG.isDebugEnabled()) {
          LOG.debug("write to " + datanodes[j].getName() + ": "+ Op.BLOCK_CHECKSUM+ ", block="+ block);
        }
        new Sender(out).blockChecksum(block,lb.getBlockToken());
        final BlockOpResponseProto reply=BlockOpResponseProto.parseFrom(HdfsProtoUtil.vintPrefixed(in));
        if (reply.getStatus() != Status.SUCCESS) {
          if (reply.getStatus() == Status.ERROR_ACCESS_TOKEN && i > lastRetriedIndex) {
            if (LOG.isDebugEnabled()) {
              LOG.debug("Got access token error in response to OP_BLOCK_CHECKSUM " + "for file " + src + " for block "+ block+ " from datanode "+ datanodes[j].getName()+ ". Will retry the block once.");
            }
            lastRetriedIndex=i;
            done=true;
            i--;
            refetchBlocks=true;
            break;
          }
 else {
            throw new IOException("Bad response " + reply + " for block "+ block+ " from datanode "+ datanodes[j].getName());
          }
        }
        OpBlockChecksumResponseProto checksumData=reply.getChecksumResponse();
        final int bpc=checksumData.getBytesPerCrc();
        if (i == 0) {
          bytesPerCRC=bpc;
        }
 else         if (bpc != bytesPerCRC) {
          throw new IOException("Byte-per-checksum not matched: bpc=" + bpc + " but bytesPerCRC="+ bytesPerCRC);
        }
        final long cpb=checksumData.getCrcPerBlock();
        if (locatedblocks.size() > 1 && i == 0) {
          crcPerBlock=cpb;
        }
        final MD5Hash md5=new MD5Hash(checksumData.getMd5().toByteArray());
        md5.write(md5out);
        done=true;
        if (LOG.isDebugEnabled()) {
          if (i == 0) {
            LOG.debug("set bytesPerCRC=" + bytesPerCRC + ", crcPerBlock="+ crcPerBlock);
          }
          LOG.debug("got reply from " + datanodes[j].getName() + ": md5="+ md5);
        }
      }
 catch (      IOException ie) {
        LOG.warn("src=" + src + ", datanodes["+ j+ "].getName()="+ datanodes[j].getName(),ie);
      }
 finally {
        IOUtils.closeStream(in);
        IOUtils.closeStream(out);
        IOUtils.closeSocket(sock);
      }
    }
    if (!done) {
      throw new IOException("Fail to get block MD5 for " + block);
    }
  }
  final MD5Hash fileMD5=MD5Hash.digest(md5out.getData());
  return new MD5MD5CRC32FileChecksum(bytesPerCRC,crcPerBlock,fileMD5);
}
