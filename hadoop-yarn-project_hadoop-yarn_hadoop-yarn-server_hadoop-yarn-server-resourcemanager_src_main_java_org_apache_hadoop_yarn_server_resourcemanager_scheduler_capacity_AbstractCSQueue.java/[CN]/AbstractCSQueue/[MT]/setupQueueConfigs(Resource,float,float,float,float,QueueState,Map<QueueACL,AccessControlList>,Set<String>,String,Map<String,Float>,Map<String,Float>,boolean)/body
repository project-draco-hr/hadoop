{
  CSQueueUtils.checkMaxCapacity(getQueueName(),capacity,maximumCapacity);
  CSQueueUtils.checkAbsoluteCapacity(getQueueName(),absoluteCapacity,absoluteMaxCapacity);
  this.capacity=capacity;
  this.absoluteCapacity=absoluteCapacity;
  this.maximumCapacity=maximumCapacity;
  this.absoluteMaxCapacity=absoluteMaxCapacity;
  this.state=state;
  this.acls=acls;
  this.accessibleLabels=labels;
  this.defaultLabelExpression=defaultLabelExpression;
  this.capacitiyByNodeLabels=new HashMap<String,Float>(nodeLabelCapacities);
  this.maxCapacityByNodeLabels=new HashMap<String,Float>(maximumNodeLabelCapacities);
  CSQueueUtils.updateQueueStatistics(resourceCalculator,this,parent,clusterResource,minimumAllocation);
  if (parent != null && parent.getParent() != null) {
    if (parent.getAccessibleNodeLabels() != null && !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {
      if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {
        throw new IOException("Parent's accessible queue is not ANY(*), " + "but child's accessible queue is *");
      }
 else {
        Set<String> diff=Sets.difference(this.getAccessibleNodeLabels(),parent.getAccessibleNodeLabels());
        if (!diff.isEmpty()) {
          throw new IOException("Some labels of child queue is not a subset " + "of parent queue, these labels=[" + StringUtils.join(diff,",") + "]");
        }
      }
    }
  }
  this.absoluteCapacityByNodeLabels=CSQueueUtils.computeAbsoluteCapacityByNodeLabels(this.capacitiyByNodeLabels,parent);
  this.absoluteMaxCapacityByNodeLabels=CSQueueUtils.computeAbsoluteMaxCapacityByNodeLabels(maximumNodeLabelCapacities,parent);
  CSQueueUtils.checkAbsoluteCapacitiesByLabel(getQueueName(),absoluteCapacityByNodeLabels,absoluteCapacityByNodeLabels);
  this.reservationsContinueLooking=reservationContinueLooking;
  this.preemptionDisabled=isQueueHierarchyPreemptionDisabled(this);
}
