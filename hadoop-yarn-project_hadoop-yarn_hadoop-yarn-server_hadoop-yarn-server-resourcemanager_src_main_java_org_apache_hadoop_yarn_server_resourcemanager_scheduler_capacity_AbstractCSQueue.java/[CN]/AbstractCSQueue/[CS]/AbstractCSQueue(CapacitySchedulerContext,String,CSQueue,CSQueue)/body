{
  this.minimumAllocation=cs.getMinimumResourceCapability();
  this.maximumAllocation=cs.getMaximumResourceCapability();
  this.labelManager=cs.getRMContext().getNodeLabelManager();
  this.parent=parent;
  this.queueName=queueName;
  this.resourceCalculator=cs.getResourceCalculator();
  this.metrics=old != null ? old.getMetrics() : QueueMetrics.forQueue(getQueuePath(),parent,cs.getConfiguration().getEnableUserMetrics(),cs.getConf());
  this.accessibleLabels=cs.getConfiguration().getAccessibleNodeLabels(getQueuePath());
  this.defaultLabelExpression=cs.getConfiguration().getDefaultNodeLabelExpression(getQueuePath());
  if (this.accessibleLabels == null && parent != null) {
    this.accessibleLabels=parent.getAccessibleNodeLabels();
  }
  SchedulerUtils.checkIfLabelInClusterNodeLabels(labelManager,this.accessibleLabels);
  if (this.defaultLabelExpression == null && parent != null && this.accessibleLabels.containsAll(parent.getAccessibleNodeLabels())) {
    this.defaultLabelExpression=parent.getDefaultNodeLabelExpression();
  }
  capacitiyByNodeLabels=cs.getConfiguration().getNodeLabelCapacities(getQueuePath(),accessibleLabels,labelManager);
  maxCapacityByNodeLabels=cs.getConfiguration().getMaximumNodeLabelCapacities(getQueuePath(),accessibleLabels,labelManager);
  this.csContext=cs;
  queueUsage=new ResourceUsage();
  queueEntity=new PrivilegedEntity(EntityType.QUEUE,getQueuePath());
  authorizer=YarnAuthorizationProvider.getInstance(cs.getConf());
}
