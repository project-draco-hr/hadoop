{
  MyContainerManager containerManager=new MyContainerManager();
  MockRM rm=new MockRMWithAMS(conf,containerManager);
  rm.start();
  MockNM nm1=rm.registerNode("localhost:1234",5120);
  RMApp app=rm.submitApp(1024);
  nm1.nodeHeartbeat(true);
  int waitCount=0;
  while (containerManager.containerTokens == null && waitCount++ < 40) {
    LOG.info("Waiting for AM Launch to happen..");
    Thread.sleep(1000);
  }
  Assert.assertNotNull(containerManager.containerTokens);
  RMAppAttempt attempt=app.getCurrentAppAttempt();
  ApplicationAttemptId applicationAttemptId=attempt.getAppAttemptId();
  waitForLaunchedState(attempt);
  final Configuration conf=rm.getConfig();
  final YarnRPC rpc=YarnRPC.create(conf);
  final InetSocketAddress serviceAddr=conf.getSocketAddr(YarnConfiguration.RM_SCHEDULER_ADDRESS,YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);
  UserGroupInformation currentUser=UserGroupInformation.createRemoteUser(applicationAttemptId.toString());
  ApplicationMasterProtocol client=currentUser.doAs(new PrivilegedAction<ApplicationMasterProtocol>(){
    @Override public ApplicationMasterProtocol run(){
      return (ApplicationMasterProtocol)rpc.getProxy(ApplicationMasterProtocol.class,serviceAddr,conf);
    }
  }
);
  RegisterApplicationMasterRequest request=Records.newRecord(RegisterApplicationMasterRequest.class);
  request.setApplicationAttemptId(applicationAttemptId);
  try {
    client.registerApplicationMaster(request);
    Assert.fail("Should fail with authorization error");
  }
 catch (  Exception e) {
    String availableAuthMethods;
    if (UserGroupInformation.isSecurityEnabled()) {
      availableAuthMethods="[TOKEN, KERBEROS]";
    }
 else {
      availableAuthMethods="[TOKEN]";
    }
    Assert.assertTrue(e.getCause().getMessage().contains("SIMPLE authentication is not enabled.  " + "Available:" + availableAuthMethods));
  }
  Credentials credentials=containerManager.getContainerCredentials();
  currentUser.addCredentials(credentials);
  client=currentUser.doAs(new PrivilegedAction<ApplicationMasterProtocol>(){
    @Override public ApplicationMasterProtocol run(){
      return (ApplicationMasterProtocol)rpc.getProxy(ApplicationMasterProtocol.class,serviceAddr,conf);
    }
  }
);
  request=Records.newRecord(RegisterApplicationMasterRequest.class);
  ApplicationAttemptId otherAppAttemptId=BuilderUtils.newApplicationAttemptId(applicationAttemptId.getApplicationId(),42);
  request.setApplicationAttemptId(otherAppAttemptId);
  try {
    client.registerApplicationMaster(request);
    Assert.fail("Should fail with authorization error");
  }
 catch (  YarnException e) {
    Assert.assertTrue(e.getMessage().contains("Unauthorized request from ApplicationMaster. " + "Expected ApplicationAttemptID: " + applicationAttemptId.toString() + " Found: "+ otherAppAttemptId.toString()));
  }
 finally {
    rm.stop();
  }
}
