{
  try {
    Invocation call=(Invocation)param;
    if (verbose)     log("Call: " + call);
    Method method=protocol.getMethod(call.getMethodName(),call.getParameterClasses());
    method.setAccessible(true);
    if (call.getRpcVersion() != writableRpcVersion) {
      throw new IOException("WritableRpc version mismatch, client side version=" + call.getRpcVersion() + ", server side version="+ writableRpcVersion);
    }
    if (!method.getDeclaringClass().equals(VersionedProtocol.class)) {
      long clientVersion=call.getProtocolVersion();
      ProtocolSignature serverInfo=((VersionedProtocol)instance).getProtocolSignature(protocol.getCanonicalName(),call.getProtocolVersion(),call.getClientMethodsHash());
      long serverVersion=serverInfo.getVersion();
      if (serverVersion != clientVersion) {
        LOG.warn("Version mismatch: client version=" + clientVersion + ", server version="+ serverVersion);
        throw new RPC.VersionMismatch(protocol.getName(),clientVersion,serverVersion);
      }
    }
    long startTime=System.currentTimeMillis();
    Object value=method.invoke(instance,call.getParameters());
    int processingTime=(int)(System.currentTimeMillis() - startTime);
    int qTime=(int)(startTime - receivedTime);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Served: " + call.getMethodName() + " queueTime= "+ qTime+ " procesingTime= "+ processingTime);
    }
    rpcMetrics.rpcQueueTime.inc(qTime);
    rpcMetrics.rpcProcessingTime.inc(processingTime);
    MetricsTimeVaryingRate m=(MetricsTimeVaryingRate)rpcDetailedMetrics.registry.get(call.getMethodName());
    if (m == null) {
      try {
        m=new MetricsTimeVaryingRate(call.getMethodName(),rpcDetailedMetrics.registry);
      }
 catch (      IllegalArgumentException iae) {
        LOG.info("Error register " + call.getMethodName(),iae);
        m=(MetricsTimeVaryingRate)rpcDetailedMetrics.registry.get(call.getMethodName());
      }
    }
    m.inc(processingTime);
    if (verbose)     log("Return: " + value);
    return new ObjectWritable(method.getReturnType(),value);
  }
 catch (  InvocationTargetException e) {
    Throwable target=e.getTargetException();
    if (target instanceof IOException) {
      throw (IOException)target;
    }
 else {
      IOException ioe=new IOException(target.toString());
      ioe.setStackTrace(target.getStackTrace());
      throw ioe;
    }
  }
catch (  Throwable e) {
    if (!(e instanceof IOException)) {
      LOG.error("Unexpected throwable object ",e);
    }
    IOException ioe=new IOException(e.toString());
    ioe.setStackTrace(e.getStackTrace());
    throw ioe;
  }
}
