{
  long totalCapacity=0;
  long totalUsed=0;
  sortedQueue.clear();
  for (  DiskBalancerVolume volume : volumes) {
    if (!volume.isFailed() && !volume.isSkip()) {
      if (volume.computeEffectiveCapacity() < 0) {
        skipMisConfiguredVolume(volume);
        continue;
      }
      totalCapacity+=volume.computeEffectiveCapacity();
      totalUsed+=volume.getUsed();
    }
  }
  if (totalCapacity != 0) {
    this.idealUsed=totalUsed / (float)totalCapacity;
  }
  for (  DiskBalancerVolume volume : volumes) {
    if (!volume.isFailed() && !volume.isSkip()) {
      float dfsUsedRatio=volume.getUsed() / (float)volume.computeEffectiveCapacity();
      volume.setVolumeDataDensity(this.idealUsed - dfsUsedRatio);
      sortedQueue.add(volume);
    }
  }
}
