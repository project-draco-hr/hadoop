{
  setChunkSize(chunkSize);
  prepareBufferAllocator(usingSlicedBuffer);
  setAllowChangeInputs(allowChangeInputs);
  dumpSetting();
  ECChunk[] dataChunks=prepareDataChunksForEncoding();
  if (useBadInput) {
    corruptSomeChunk(dataChunks);
  }
  dumpChunks("Testing data chunks",dataChunks);
  ECChunk[] parityChunks=prepareParityChunksForEncoding();
  ECChunk[] clonedDataChunks=cloneChunksWithData(dataChunks);
  markChunks(dataChunks);
  encoder.encode(dataChunks,parityChunks);
  dumpChunks("Encoded parity chunks",parityChunks);
  if (!allowChangeInputs) {
    restoreChunksFromMark(dataChunks);
    compareAndVerify(clonedDataChunks,dataChunks);
  }
  ECChunk[] backupChunks=backupAndEraseChunks(clonedDataChunks,parityChunks);
  ECChunk[] inputChunks=prepareInputChunksForDecoding(clonedDataChunks,parityChunks);
  ensureOnlyLeastRequiredChunks(inputChunks);
  ECChunk[] recoveredChunks=prepareOutputChunksForDecoding();
  if (useBadOutput) {
    corruptSomeChunk(recoveredChunks);
  }
  ECChunk[] clonedInputChunks=null;
  if (!allowChangeInputs) {
    markChunks(inputChunks);
    clonedInputChunks=cloneChunksWithData(inputChunks);
  }
  dumpChunks("Decoding input chunks",inputChunks);
  decoder.decode(inputChunks,getErasedIndexesForDecoding(),recoveredChunks);
  dumpChunks("Decoded/recovered chunks",recoveredChunks);
  if (!allowChangeInputs) {
    restoreChunksFromMark(inputChunks);
    compareAndVerify(clonedInputChunks,inputChunks);
  }
  compareAndVerify(backupChunks,recoveredChunks);
}
