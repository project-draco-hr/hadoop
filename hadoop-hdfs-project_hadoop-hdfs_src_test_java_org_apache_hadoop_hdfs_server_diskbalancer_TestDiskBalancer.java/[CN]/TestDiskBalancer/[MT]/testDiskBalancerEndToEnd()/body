{
  Configuration conf=new HdfsConfiguration();
  final int defaultBlockSize=100;
  conf.setBoolean(DFSConfigKeys.DFS_DISK_BALANCER_ENABLED,true);
  conf.setLong(DFSConfigKeys.DFS_BLOCK_SIZE_KEY,defaultBlockSize);
  conf.setInt(DFSConfigKeys.DFS_BYTES_PER_CHECKSUM_KEY,defaultBlockSize);
  conf.setLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,1L);
  final int numDatanodes=1;
  final String fileName="/tmp.txt";
  final Path filePath=new Path(fileName);
  final int blocks=100;
  final int blocksSize=1024;
  final int fileLen=blocks * blocksSize;
  long[] capacities=new long[]{defaultBlockSize * 2 * fileLen,defaultBlockSize * 2 * fileLen};
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(numDatanodes).storageCapacities(capacities).storageTypes(new StorageType[]{StorageType.DISK,StorageType.DISK}).storagesPerDatanode(2).build();
  FsVolumeImpl source=null;
  FsVolumeImpl dest=null;
  try {
    cluster.waitActive();
    Random r=new Random();
    FileSystem fs=cluster.getFileSystem(0);
    TestBalancer.createFile(cluster,filePath,fileLen,(short)1,numDatanodes - 1);
    DFSTestUtil.waitReplication(fs,filePath,(short)1);
    cluster.restartDataNodes();
    cluster.waitActive();
    DataNode dnNode=cluster.getDataNodes().get(numDatanodes - 1);
    try (FsDatasetSpi.FsVolumeReferences refs=dnNode.getFSDataset().getFsVolumeReferences()){
      source=(FsVolumeImpl)refs.get(0);
      dest=(FsVolumeImpl)refs.get(1);
      assertTrue(DiskBalancerTestUtil.getBlockCount(source) > 0);
      DiskBalancerTestUtil.moveAllDataToDestVolume(dnNode.getFSDataset(),source,dest);
      assertTrue(DiskBalancerTestUtil.getBlockCount(source) == 0);
    }
     cluster.restartDataNodes();
    cluster.waitActive();
    final DataNode newDN=cluster.getDataNodes().get(numDatanodes - 1);
    ClusterConnector nameNodeConnector=ConnectorFactory.getCluster(cluster.getFileSystem(0).getUri(),conf);
    DiskBalancerCluster diskBalancerCluster=new DiskBalancerCluster(nameNodeConnector);
    diskBalancerCluster.readClusterInfo();
    List<DiskBalancerDataNode> nodesToProcess=new LinkedList<>();
    setVolumeCapacity(diskBalancerCluster,defaultBlockSize * 2 * fileLen,"DISK");
    nodesToProcess.add(diskBalancerCluster.getNodeByUUID(dnNode.getDatanodeUuid()));
    diskBalancerCluster.setNodesToProcess(nodesToProcess);
    List<NodePlan> clusterplan=diskBalancerCluster.computePlan(0.0f);
    assertTrue(clusterplan.size() == 1);
    NodePlan plan=clusterplan.get(0);
    plan.setNodeUUID(dnNode.getDatanodeUuid());
    plan.setTimeStamp(Time.now());
    String planJson=plan.toJson();
    String planID=DigestUtils.sha512Hex(planJson);
    assertNotNull(plan.getVolumeSetPlans());
    assertTrue(plan.getVolumeSetPlans().size() > 0);
    plan.getVolumeSetPlans().get(0).setTolerancePercent(10);
    newDN.submitDiskBalancerPlan(planID,1,planJson,false);
    String jmxString=newDN.getDiskBalancerStatus();
    assertNotNull(jmxString);
    DiskBalancerWorkStatus status=DiskBalancerWorkStatus.parseJson(jmxString);
    DiskBalancerWorkStatus realStatus=newDN.queryDiskBalancerPlan();
    assertEquals(realStatus.getPlanID(),status.getPlanID());
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        try {
          return newDN.queryDiskBalancerPlan().getResult() == DiskBalancerWorkStatus.Result.PLAN_DONE;
        }
 catch (        IOException ex) {
          return false;
        }
      }
    }
,1000,100000);
    dnNode=cluster.getDataNodes().get(numDatanodes - 1);
    assertEquals(dnNode.queryDiskBalancerPlan().getResult(),DiskBalancerWorkStatus.Result.PLAN_DONE);
    try (FsDatasetSpi.FsVolumeReferences refs=dnNode.getFSDataset().getFsVolumeReferences()){
      source=(FsVolumeImpl)refs.get(0);
      assertTrue(DiskBalancerTestUtil.getBlockCount(source) > 0);
    }
     long delta=(plan.getVolumeSetPlans().get(0).getBytesToMove() * 10) / 100;
    assertTrue((DiskBalancerTestUtil.getBlockCount(source) * defaultBlockSize + delta) >= plan.getVolumeSetPlans().get(0).getBytesToMove());
  }
  finally {
    cluster.shutdown();
  }
}
