{
  Reducer<INKEY,INVALUE,OUTKEY,OUTVALUE> reducer=ReflectionUtils.newInstance(job.getReducerClass(),job);
  String finalName=getOutputName(getPartition());
  RecordWriter<OUTKEY,OUTVALUE> out=new OldTrackingRecordWriter<OUTKEY,OUTVALUE>(this,job,reporter,finalName);
  final RecordWriter<OUTKEY,OUTVALUE> finalOut=out;
  OutputCollector<OUTKEY,OUTVALUE> collector=new OutputCollector<OUTKEY,OUTVALUE>(){
    public void collect(    OUTKEY key,    OUTVALUE value) throws IOException {
      finalOut.write(key,value);
      reporter.progress();
    }
  }
;
  try {
    boolean incrProcCount=SkipBadRecords.getReducerMaxSkipGroups(job) > 0 && SkipBadRecords.getAutoIncrReducerProcCount(job);
    ReduceValuesIterator<INKEY,INVALUE> values=isSkipping() ? new SkippingReduceValuesIterator<INKEY,INVALUE>(rIter,comparator,keyClass,valueClass,job,reporter,umbilical) : new ReduceValuesIterator<INKEY,INVALUE>(rIter,job.getOutputValueGroupingComparator(),keyClass,valueClass,job,reporter);
    values.informReduceProgress();
    while (values.more()) {
      reduceInputKeyCounter.increment(1);
      reducer.reduce(values.getKey(),values,collector,reporter);
      if (incrProcCount) {
        reporter.incrCounter(SkipBadRecords.COUNTER_GROUP,SkipBadRecords.COUNTER_REDUCE_PROCESSED_GROUPS,1);
      }
      values.nextKey();
      values.informReduceProgress();
    }
    reducer.close();
    reducer=null;
    out.close(reporter);
    out=null;
  }
  finally {
    IOUtils.cleanup(LOG,reducer);
    closeQuietly(out,reporter);
  }
}
