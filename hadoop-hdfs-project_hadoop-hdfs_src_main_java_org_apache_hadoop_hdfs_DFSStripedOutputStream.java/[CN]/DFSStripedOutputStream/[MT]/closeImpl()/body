{
  if (isClosed()) {
    final MultipleIOException.Builder b=new MultipleIOException.Builder();
    for (int i=0; i < streamers.size(); i++) {
      final StripedDataStreamer si=getStripedDataStreamer(i);
      try {
        si.getLastException().check(true);
      }
 catch (      IOException e) {
        b.add(e);
      }
    }
    final IOException ioe=b.build();
    if (ioe != null) {
      throw ioe;
    }
    return;
  }
  try {
    try {
      flushBuffer();
      if (currentPacket != null) {
        enqueueCurrentPacket();
      }
    }
 catch (    Exception e) {
      handleStreamerFailure("closeImpl",e);
    }
    writeParityCellsForLastStripe();
    for (int i=0; i < numAllBlocks; i++) {
      final StripedDataStreamer s=setCurrentStreamer(i);
      if (!s.isFailed()) {
        try {
          if (s.getBytesCurBlock() > 0) {
            setCurrentPacket2Empty();
          }
          flushInternal();
        }
 catch (        Exception e) {
          handleStreamerFailure("closeImpl",e);
        }
      }
    }
    closeThreads(false);
    final ExtendedBlock lastBlock=coordinator.getBlockGroup();
    TraceScope scope=Trace.startSpan("completeFile",Sampler.NEVER);
    try {
      completeFile(lastBlock);
    }
  finally {
      scope.close();
    }
    dfsClient.endFileLease(fileId);
  }
 catch (  ClosedChannelException ignored) {
  }
 finally {
    setClosed();
  }
}
