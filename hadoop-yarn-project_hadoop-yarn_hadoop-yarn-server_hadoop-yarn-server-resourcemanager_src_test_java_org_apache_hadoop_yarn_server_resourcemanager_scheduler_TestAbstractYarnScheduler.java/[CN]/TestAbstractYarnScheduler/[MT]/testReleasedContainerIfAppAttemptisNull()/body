{
  YarnConfiguration conf=getConf();
  conf.set(YarnConfiguration.RM_STORE,MemoryRMStateStore.class.getName());
  MemoryRMStateStore memStore=new MemoryRMStateStore();
  memStore.init(conf);
  MockRM rm1=new MockRM(conf,memStore);
  try {
    rm1.start();
    MockNM nm1=new MockNM("127.0.0.1:1234",8192,rm1.getResourceTrackerService());
    nm1.registerNode();
    AbstractYarnScheduler scheduler=(AbstractYarnScheduler)rm1.getResourceScheduler();
    RMApp mockAPp=new MockRMApp(125,System.currentTimeMillis(),RMAppState.NEW);
    SchedulerApplication<FiCaSchedulerApp> application=new SchedulerApplication<FiCaSchedulerApp>(null,mockAPp.getUser());
    RMApp app=rm1.submitApp(200);
    MockAM am1=MockRM.launchAndRegisterAM(app,rm1,nm1);
    final ContainerId runningContainer=ContainerId.newContainerId(am1.getApplicationAttemptId(),2);
    am1.allocate(null,Arrays.asList(runningContainer));
    Map schedulerApplications=scheduler.getSchedulerApplications();
    SchedulerApplication schedulerApp=(SchedulerApplication)scheduler.getSchedulerApplications().get(app.getApplicationId());
    schedulerApplications.put(mockAPp.getApplicationId(),application);
    scheduler.clearPendingContainerCache();
    Assert.assertEquals("Pending containers are not released " + "when one of the application attempt is null !",schedulerApp.getCurrentAppAttempt().getPendingRelease().size(),0);
  }
  finally {
    if (rm1 != null) {
      rm1.stop();
    }
  }
}
