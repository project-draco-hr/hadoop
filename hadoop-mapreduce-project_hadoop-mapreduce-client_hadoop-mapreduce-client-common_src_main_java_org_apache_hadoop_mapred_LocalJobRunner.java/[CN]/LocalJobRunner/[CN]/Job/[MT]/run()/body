{
  JobID jobId=profile.getJobID();
  JobContext jContext=new JobContextImpl(job,jobId);
  org.apache.hadoop.mapreduce.OutputCommitter outputCommitter=null;
  try {
    outputCommitter=createOutputCommitter(conf.getUseNewMapper(),jobId,conf);
  }
 catch (  Exception e) {
    LOG.info("Failed to createOutputCommitter",e);
    return;
  }
  try {
    TaskSplitMetaInfo[] taskSplitMetaInfos=SplitMetaInfoReader.readSplitMetaInfo(jobId,localFs,conf,systemJobDir);
    int numReduceTasks=job.getNumReduceTasks();
    outputCommitter.setupJob(jContext);
    status.setSetupProgress(1.0f);
    Map<TaskAttemptID,MapOutputFile> mapOutputFiles=Collections.synchronizedMap(new HashMap<TaskAttemptID,MapOutputFile>());
    List<RunnableWithThrowable> mapRunnables=getMapTaskRunnables(taskSplitMetaInfos,jobId,mapOutputFiles);
    initCounters(mapRunnables.size(),numReduceTasks);
    ExecutorService mapService=createMapExecutor();
    runTasks(mapRunnables,mapService,"map");
    try {
      if (numReduceTasks > 0) {
        List<RunnableWithThrowable> reduceRunnables=getReduceTaskRunnables(jobId,mapOutputFiles);
        ExecutorService reduceService=createReduceExecutor();
        runTasks(reduceRunnables,reduceService,"reduce");
      }
    }
  finally {
      for (      MapOutputFile output : mapOutputFiles.values()) {
        output.removeAll();
      }
    }
    outputCommitter.commitJob(jContext);
    status.setCleanupProgress(1.0f);
    if (killed) {
      this.status.setRunState(JobStatus.KILLED);
    }
 else {
      this.status.setRunState(JobStatus.SUCCEEDED);
    }
    JobEndNotifier.localRunnerNotification(job,status);
  }
 catch (  Throwable t) {
    try {
      outputCommitter.abortJob(jContext,org.apache.hadoop.mapreduce.JobStatus.State.FAILED);
    }
 catch (    IOException ioe) {
      LOG.info("Error cleaning up job:" + id);
    }
    status.setCleanupProgress(1.0f);
    if (killed) {
      this.status.setRunState(JobStatus.KILLED);
    }
 else {
      this.status.setRunState(JobStatus.FAILED);
    }
    LOG.warn(id,t);
    JobEndNotifier.localRunnerNotification(job,status);
  }
 finally {
    try {
      fs.delete(systemJobFile.getParent(),true);
      localFs.delete(localJobFile,true);
      localDistributedCacheManager.close();
    }
 catch (    IOException e) {
      LOG.warn("Error cleaning up " + id + ": "+ e);
    }
  }
}
