{
  super.dumpTreeRecursively(out,prefix,snapshot);
  if (snapshot == null) {
    out.println();
    out.print(prefix);
    int n=0;
    for (    DirectoryDiff diff : getDiffs()) {
      if (diff.isSnapshotRoot()) {
        n++;
      }
    }
    out.print(n);
    out.print(n <= 1 ? " snapshot of " : " snapshots of ");
    final String name=getLocalName();
    out.println(name.isEmpty() ? "/" : name);
    dumpTreeRecursively(out,prefix,new Iterable<Pair<? extends INode,Snapshot>>(){
      @Override public Iterator<Pair<? extends INode,Snapshot>> iterator(){
        return new Iterator<Pair<? extends INode,Snapshot>>(){
          final Iterator<DirectoryDiff> i=getDiffs().iterator();
          private DirectoryDiff next=findNext();
          private DirectoryDiff findNext(){
            for (; i.hasNext(); ) {
              final DirectoryDiff diff=i.next();
              if (diff.isSnapshotRoot()) {
                return diff;
              }
            }
            return null;
          }
          @Override public boolean hasNext(){
            return next != null;
          }
          @Override public Pair<INodeDirectory,Snapshot> next(){
            final Snapshot s=next.snapshot;
            final Pair<INodeDirectory,Snapshot> pair=new Pair<INodeDirectory,Snapshot>(s.getRoot(),s);
            next=findNext();
            return pair;
          }
          @Override public void remove(){
            throw new UnsupportedOperationException();
          }
        }
;
      }
    }
);
  }
}
