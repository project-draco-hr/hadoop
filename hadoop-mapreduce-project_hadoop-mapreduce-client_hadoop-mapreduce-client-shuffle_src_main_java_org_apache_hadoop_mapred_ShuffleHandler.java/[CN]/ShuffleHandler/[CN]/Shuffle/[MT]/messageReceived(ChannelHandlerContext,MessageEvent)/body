{
  HttpRequest request=(HttpRequest)evt.getMessage();
  if (request.getMethod() != GET) {
    sendError(ctx,METHOD_NOT_ALLOWED);
    return;
  }
  if (!ShuffleHeader.DEFAULT_HTTP_HEADER_NAME.equals(request.getHeader(ShuffleHeader.HTTP_HEADER_NAME)) || !ShuffleHeader.DEFAULT_HTTP_HEADER_VERSION.equals(request.getHeader(ShuffleHeader.HTTP_HEADER_VERSION))) {
    sendError(ctx,"Incompatible shuffle request version",BAD_REQUEST);
  }
  final Map<String,List<String>> q=new QueryStringDecoder(request.getUri()).getParameters();
  final List<String> mapIds=splitMaps(q.get("map"));
  final List<String> reduceQ=q.get("reduce");
  final List<String> jobQ=q.get("job");
  if (LOG.isDebugEnabled()) {
    LOG.debug("RECV: " + request.getUri() + "\n  mapId: "+ mapIds+ "\n  reduceId: "+ reduceQ+ "\n  jobId: "+ jobQ);
  }
  if (mapIds == null || reduceQ == null || jobQ == null) {
    sendError(ctx,"Required param job, map and reduce",BAD_REQUEST);
    return;
  }
  if (reduceQ.size() != 1 || jobQ.size() != 1) {
    sendError(ctx,"Too many job/reduce parameters",BAD_REQUEST);
    return;
  }
  int reduceId;
  String jobId;
  try {
    reduceId=Integer.parseInt(reduceQ.get(0));
    jobId=jobQ.get(0);
  }
 catch (  NumberFormatException e) {
    sendError(ctx,"Bad reduce parameter",BAD_REQUEST);
    return;
  }
catch (  IllegalArgumentException e) {
    sendError(ctx,"Bad job parameter",BAD_REQUEST);
    return;
  }
  final String reqUri=request.getUri();
  if (null == reqUri) {
    sendError(ctx,FORBIDDEN);
    return;
  }
  HttpResponse response=new DefaultHttpResponse(HTTP_1_1,OK);
  try {
    verifyRequest(jobId,ctx,request,response,new URL("http","",this.port,reqUri));
  }
 catch (  IOException e) {
    LOG.warn("Shuffle failure ",e);
    sendError(ctx,e.getMessage(),UNAUTHORIZED);
    return;
  }
  Channel ch=evt.getChannel();
  ch.write(response);
  ChannelFuture lastMap=null;
  for (  String mapId : mapIds) {
    try {
      lastMap=sendMapOutput(ctx,ch,userRsrc.get(jobId),jobId,mapId,reduceId);
      if (null == lastMap) {
        sendError(ctx,NOT_FOUND);
        return;
      }
    }
 catch (    IOException e) {
      LOG.error("Shuffle error :",e);
      StringBuffer sb=new StringBuffer(e.getMessage());
      Throwable t=e;
      while (t.getCause() != null) {
        sb.append(t.getCause().getMessage());
        t=t.getCause();
      }
      sendError(ctx,sb.toString(),INTERNAL_SERVER_ERROR);
      return;
    }
  }
  lastMap.addListener(metrics);
  lastMap.addListener(ChannelFutureListener.CLOSE);
}
