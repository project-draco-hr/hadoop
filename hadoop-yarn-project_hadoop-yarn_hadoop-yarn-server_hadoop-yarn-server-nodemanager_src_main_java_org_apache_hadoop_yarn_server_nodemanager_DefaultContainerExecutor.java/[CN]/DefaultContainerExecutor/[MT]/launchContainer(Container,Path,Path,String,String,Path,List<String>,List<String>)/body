{
  FsPermission dirPerm=new FsPermission(APPDIR_PERM);
  ContainerId containerId=container.getContainerId();
  String containerIdStr=ConverterUtils.toString(containerId);
  String appIdStr=ConverterUtils.toString(containerId.getApplicationAttemptId().getApplicationId());
  for (  String sLocalDir : localDirs) {
    Path usersdir=new Path(sLocalDir,ContainerLocalizer.USERCACHE);
    Path userdir=new Path(usersdir,userName);
    Path appCacheDir=new Path(userdir,ContainerLocalizer.APPCACHE);
    Path appDir=new Path(appCacheDir,appIdStr);
    Path containerDir=new Path(appDir,containerIdStr);
    createDir(containerDir,dirPerm,true);
  }
  createContainerLogDirs(appIdStr,containerIdStr,logDirs);
  Path tmpDir=new Path(containerWorkDir,YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);
  createDir(tmpDir,dirPerm,false);
  Path launchDst=new Path(containerWorkDir,ContainerLaunch.CONTAINER_SCRIPT);
  lfs.util().copy(nmPrivateContainerScriptPath,launchDst);
  Path tokenDst=new Path(containerWorkDir,ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);
  lfs.util().copy(nmPrivateTokensPath,tokenDst);
  LocalWrapperScriptBuilder sb=Shell.WINDOWS ? new WindowsLocalWrapperScriptBuilder(containerIdStr,containerWorkDir) : new UnixLocalWrapperScriptBuilder(containerWorkDir);
  if (Shell.WINDOWS && sb.getWrapperScriptPath().toString().length() > WIN_MAX_PATH) {
    throw new IOException(String.format("Cannot launch container using script at path %s, because it exceeds " + "the maximum supported path length of %d characters.  Consider " + "configuring shorter directories in %s.",sb.getWrapperScriptPath(),WIN_MAX_PATH,YarnConfiguration.NM_LOCAL_DIRS));
  }
  Path pidFile=getPidFilePath(containerId);
  if (pidFile != null) {
    sb.writeLocalWrapperScript(launchDst,pidFile);
  }
 else {
    LOG.info("Container " + containerIdStr + " was marked as inactive. Returning terminated error");
    return ExitCode.TERMINATED.getExitCode();
  }
  ShellCommandExecutor shExec=null;
  try {
    lfs.setPermission(launchDst,ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);
    lfs.setPermission(sb.getWrapperScriptPath(),ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);
    String[] command=getRunCommand(sb.getWrapperScriptPath().toString(),containerIdStr,this.getConf());
    LOG.info("launchContainer: " + Arrays.toString(command));
    shExec=new ShellCommandExecutor(command,new File(containerWorkDir.toUri().getPath()),container.getLaunchContext().getEnvironment());
    if (isContainerActive(containerId)) {
      shExec.execute();
    }
 else {
      LOG.info("Container " + containerIdStr + " was marked as inactive. Returning terminated error");
      return ExitCode.TERMINATED.getExitCode();
    }
  }
 catch (  IOException e) {
    if (null == shExec) {
      return -1;
    }
    int exitCode=shExec.getExitCode();
    LOG.warn("Exit code from container " + containerId + " is : "+ exitCode);
    if (exitCode != ExitCode.FORCE_KILLED.getExitCode() && exitCode != ExitCode.TERMINATED.getExitCode()) {
      LOG.warn("Exception from container-launch with container ID: " + containerId + " and exit code: "+ exitCode,e);
      logOutput(shExec.getOutput());
      String diagnostics="Exception from container-launch: \n" + StringUtils.stringifyException(e) + "\n"+ shExec.getOutput();
      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,diagnostics));
    }
 else {
      container.handle(new ContainerDiagnosticsUpdateEvent(containerId,"Container killed on request. Exit code is " + exitCode));
    }
    return exitCode;
  }
 finally {
    ;
  }
  return 0;
}
