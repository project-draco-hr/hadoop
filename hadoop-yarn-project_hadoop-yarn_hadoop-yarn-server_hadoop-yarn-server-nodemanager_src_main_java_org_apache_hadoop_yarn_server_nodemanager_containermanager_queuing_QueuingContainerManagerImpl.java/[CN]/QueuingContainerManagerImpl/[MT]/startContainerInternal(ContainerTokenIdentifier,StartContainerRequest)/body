{
  this.context.getQueuingContext().getQueuedContainers().put(containerTokenIdentifier.getContainerID(),containerTokenIdentifier);
  AllocatedContainerInfo allocatedContInfo=new AllocatedContainerInfo(containerTokenIdentifier,request,containerTokenIdentifier.getExecutionType(),containerTokenIdentifier.getResource(),getConfig());
  if (queuedGuaranteedContainers.isEmpty() && queuedOpportunisticContainers.isEmpty() && getContainersMonitor().hasResourcesAvailable(allocatedContInfo.getPti())) {
    startAllocatedContainer(allocatedContInfo);
  }
 else {
    ContainerId cIdToStart=containerTokenIdentifier.getContainerID();
    this.context.getNMStateStore().storeContainer(cIdToStart,request);
    this.context.getNMStateStore().storeContainerQueued(cIdToStart);
    LOG.info("No available resources for container {} to start its execution " + "immediately.",cIdToStart);
    if (allocatedContInfo.getExecutionType() == ExecutionType.GUARANTEED) {
      queuedGuaranteedContainers.add(allocatedContInfo);
      killOpportunisticContainers(allocatedContInfo);
    }
 else {
      LOG.info("Opportunistic container {} will be queued at the NM.",cIdToStart);
      queuedOpportunisticContainers.add(allocatedContInfo);
    }
  }
}
