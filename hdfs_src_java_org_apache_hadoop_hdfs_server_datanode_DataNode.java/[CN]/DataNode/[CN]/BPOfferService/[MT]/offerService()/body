{
  LOG.info("For namenode " + nnAddr + " using BLOCKREPORT_INTERVAL of "+ blockReportInterval+ "msec"+ " Initial delay: "+ initialBlockReportDelay+ "msec"+ "; heartBeatInterval="+ heartBeatInterval);
  while (shouldRun && shouldServiceRun) {
    try {
      long startTime=now();
      if (startTime - lastHeartbeat > heartBeatInterval) {
        lastHeartbeat=startTime;
        if (!heartbeatsDisabledForTests) {
          DatanodeCommand[] cmds=sendHeartBeat();
          metrics.addHeartbeat(now() - startTime);
          if (!processCommand(cmds))           continue;
        }
      }
      reportReceivedBlocks();
      DatanodeCommand cmd=blockReport();
      processCommand(cmd);
      if (blockScanner != null) {
        blockScanner.addBlockPool(this.blockPoolId);
      }
      long waitTime=heartBeatInterval - (System.currentTimeMillis() - lastHeartbeat);
synchronized (receivedBlockList) {
        if (waitTime > 0 && receivedBlockList.size() == 0) {
          try {
            receivedBlockList.wait(waitTime);
          }
 catch (          InterruptedException ie) {
            LOG.warn("BPOfferService for block pool=" + this.getBlockPoolId() + " received exception:"+ ie);
          }
        }
      }
    }
 catch (    RemoteException re) {
      String reClass=re.getClassName();
      if (UnregisteredNodeException.class.getName().equals(reClass) || DisallowedDatanodeException.class.getName().equals(reClass) || IncorrectVersionException.class.getName().equals(reClass)) {
        LOG.warn("blockpool " + blockPoolId + " is shutting down: "+ StringUtils.stringifyException(re));
        shouldServiceRun=false;
        return;
      }
      LOG.warn(StringUtils.stringifyException(re));
      try {
        long sleepTime=Math.min(1000,heartBeatInterval);
        Thread.sleep(sleepTime);
      }
 catch (      InterruptedException ie) {
        Thread.currentThread().interrupt();
      }
    }
catch (    IOException e) {
      LOG.warn(StringUtils.stringifyException(e));
    }
  }
}
