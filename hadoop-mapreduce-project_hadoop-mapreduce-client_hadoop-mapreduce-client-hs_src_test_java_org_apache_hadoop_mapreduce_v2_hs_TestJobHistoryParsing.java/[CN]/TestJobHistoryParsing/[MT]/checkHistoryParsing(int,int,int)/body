{
  Configuration conf=new Configuration();
  conf.set(MRJobConfig.USER_NAME,System.getProperty("user.name"));
  long amStartTimeEst=System.currentTimeMillis();
  conf.setClass(CommonConfigurationKeysPublic.NET_TOPOLOGY_NODE_SWITCH_MAPPING_IMPL_KEY,MyResolver.class,DNSToSwitchMapping.class);
  RackResolver.init(conf);
  MRApp app=new MRAppWithHistory(numMaps,numReduces,true,this.getClass().getName(),true);
  app.submit(conf);
  Job job=app.getContext().getAllJobs().values().iterator().next();
  JobId jobId=job.getID();
  LOG.info("JOBID is " + TypeConverter.fromYarn(jobId).toString());
  app.waitForState(job,JobState.SUCCEEDED);
  app.waitForState(Service.STATE.STOPPED);
  String jobhistoryDir=JobHistoryUtils.getHistoryIntermediateDoneDirForUser(conf);
  FileContext fc=null;
  try {
    fc=FileContext.getFileContext(conf);
  }
 catch (  IOException ioe) {
    LOG.info("Can not get FileContext",ioe);
    throw (new Exception("Can not get File Context"));
  }
  if (numMaps == numSuccessfulMaps) {
    String summaryFileName=JobHistoryUtils.getIntermediateSummaryFileName(jobId);
    Path summaryFile=new Path(jobhistoryDir,summaryFileName);
    String jobSummaryString=getJobSummary(fc,summaryFile);
    Assert.assertNotNull(jobSummaryString);
    Assert.assertTrue(jobSummaryString.contains("resourcesPerMap=100"));
    Assert.assertTrue(jobSummaryString.contains("resourcesPerReduce=100"));
    Map<String,String> jobSummaryElements=new HashMap<String,String>();
    StringTokenizer strToken=new StringTokenizer(jobSummaryString,",");
    while (strToken.hasMoreTokens()) {
      String keypair=strToken.nextToken();
      jobSummaryElements.put(keypair.split("=")[0],keypair.split("=")[1]);
    }
    Assert.assertEquals("JobId does not match",jobId.toString(),jobSummaryElements.get("jobId"));
    Assert.assertEquals("JobName does not match","test",jobSummaryElements.get("jobName"));
    Assert.assertTrue("submitTime should not be 0",Long.parseLong(jobSummaryElements.get("submitTime")) != 0);
    Assert.assertTrue("launchTime should not be 0",Long.parseLong(jobSummaryElements.get("launchTime")) != 0);
    Assert.assertTrue("firstMapTaskLaunchTime should not be 0",Long.parseLong(jobSummaryElements.get("firstMapTaskLaunchTime")) != 0);
    Assert.assertTrue("firstReduceTaskLaunchTime should not be 0",Long.parseLong(jobSummaryElements.get("firstReduceTaskLaunchTime")) != 0);
    Assert.assertTrue("finishTime should not be 0",Long.parseLong(jobSummaryElements.get("finishTime")) != 0);
    Assert.assertEquals("Mismatch in num map slots",numSuccessfulMaps,Integer.parseInt(jobSummaryElements.get("numMaps")));
    Assert.assertEquals("Mismatch in num reduce slots",numReduces,Integer.parseInt(jobSummaryElements.get("numReduces")));
    Assert.assertEquals("User does not match",System.getProperty("user.name"),jobSummaryElements.get("user"));
    Assert.assertEquals("Queue does not match","default",jobSummaryElements.get("queue"));
    Assert.assertEquals("Status does not match","SUCCEEDED",jobSummaryElements.get("status"));
  }
  JobHistory jobHistory=new JobHistory();
  jobHistory.init(conf);
  HistoryFileInfo fileInfo=jobHistory.getJobFileInfo(jobId);
  JobInfo jobInfo;
  long numFinishedMaps;
synchronized (fileInfo) {
    Path historyFilePath=fileInfo.getHistoryFile();
    FSDataInputStream in=null;
    LOG.info("JobHistoryFile is: " + historyFilePath);
    try {
      in=fc.open(fc.makeQualified(historyFilePath));
    }
 catch (    IOException ioe) {
      LOG.info("Can not open history file: " + historyFilePath,ioe);
      throw (new Exception("Can not open History File"));
    }
    JobHistoryParser parser=new JobHistoryParser(in);
    final EventReader realReader=new EventReader(in);
    EventReader reader=Mockito.mock(EventReader.class);
    if (numMaps == numSuccessfulMaps) {
      reader=realReader;
    }
 else {
      final AtomicInteger numFinishedEvents=new AtomicInteger(0);
      Mockito.when(reader.getNextEvent()).thenAnswer(new Answer<HistoryEvent>(){
        public HistoryEvent answer(        InvocationOnMock invocation) throws IOException {
          HistoryEvent event=realReader.getNextEvent();
          if (event instanceof TaskFinishedEvent) {
            numFinishedEvents.incrementAndGet();
          }
          if (numFinishedEvents.get() <= numSuccessfulMaps) {
            return event;
          }
 else {
            throw new IOException("test");
          }
        }
      }
);
    }
    jobInfo=parser.parse(reader);
    numFinishedMaps=computeFinishedMaps(jobInfo,numMaps,numSuccessfulMaps);
    if (numFinishedMaps != numMaps) {
      Exception parseException=parser.getParseException();
      Assert.assertNotNull("Didn't get expected parse exception",parseException);
    }
  }
  Assert.assertEquals("Incorrect username ",System.getProperty("user.name"),jobInfo.getUsername());
  Assert.assertEquals("Incorrect jobName ","test",jobInfo.getJobname());
  Assert.assertEquals("Incorrect queuename ","default",jobInfo.getJobQueueName());
  Assert.assertEquals("incorrect conf path","test",jobInfo.getJobConfPath());
  Assert.assertEquals("incorrect finishedMap ",numSuccessfulMaps,numFinishedMaps);
  Assert.assertEquals("incorrect finishedReduces ",numReduces,jobInfo.getFinishedReduces());
  Assert.assertEquals("incorrect uberized ",job.isUber(),jobInfo.getUberized());
  Map<TaskID,TaskInfo> allTasks=jobInfo.getAllTasks();
  int totalTasks=allTasks.size();
  Assert.assertEquals("total number of tasks is incorrect  ",(numMaps + numReduces),totalTasks);
  Assert.assertEquals(1,jobInfo.getAMInfos().size());
  Assert.assertEquals(MRApp.NM_HOST,jobInfo.getAMInfos().get(0).getNodeManagerHost());
  AMInfo amInfo=jobInfo.getAMInfos().get(0);
  Assert.assertEquals(MRApp.NM_PORT,amInfo.getNodeManagerPort());
  Assert.assertEquals(MRApp.NM_HTTP_PORT,amInfo.getNodeManagerHttpPort());
  Assert.assertEquals(1,amInfo.getAppAttemptId().getAttemptId());
  Assert.assertEquals(amInfo.getAppAttemptId(),amInfo.getContainerId().getApplicationAttemptId());
  Assert.assertTrue(amInfo.getStartTime() <= System.currentTimeMillis() && amInfo.getStartTime() >= amStartTimeEst);
  ContainerId fakeCid=MRApp.newContainerId(-1,-1,-1,-1);
  for (  TaskInfo taskInfo : allTasks.values()) {
    int taskAttemptCount=taskInfo.getAllTaskAttempts().size();
    Assert.assertEquals("total number of task attempts ",1,taskAttemptCount);
    TaskAttemptInfo taInfo=taskInfo.getAllTaskAttempts().values().iterator().next();
    Assert.assertNotNull(taInfo.getContainerId());
    Assert.assertFalse(taInfo.getContainerId().equals(fakeCid));
  }
  for (  Task task : job.getTasks().values()) {
    TaskInfo taskInfo=allTasks.get(TypeConverter.fromYarn(task.getID()));
    Assert.assertNotNull("TaskInfo not found",taskInfo);
    for (    TaskAttempt taskAttempt : task.getAttempts().values()) {
      TaskAttemptInfo taskAttemptInfo=taskInfo.getAllTaskAttempts().get(TypeConverter.fromYarn((taskAttempt.getID())));
      Assert.assertNotNull("TaskAttemptInfo not found",taskAttemptInfo);
      Assert.assertEquals("Incorrect shuffle port for task attempt",taskAttempt.getShufflePort(),taskAttemptInfo.getShufflePort());
      if (numMaps == numSuccessfulMaps) {
        Assert.assertEquals(MRApp.NM_HOST,taskAttemptInfo.getHostname());
        Assert.assertEquals(MRApp.NM_PORT,taskAttemptInfo.getPort());
        Assert.assertEquals("rack-name is incorrect",taskAttemptInfo.getRackname(),RACK_NAME);
      }
    }
  }
  PrintStream stdps=System.out;
  try {
    System.setOut(new PrintStream(outContent));
    HistoryViewer viewer=new HistoryViewer(fc.makeQualified(fileInfo.getHistoryFile()).toString(),conf,true);
    viewer.print();
    for (    TaskInfo taskInfo : allTasks.values()) {
      String test=(taskInfo.getTaskStatus() == null ? "" : taskInfo.getTaskStatus()) + " " + taskInfo.getTaskType()+ " task list for "+ taskInfo.getTaskId().getJobID();
      Assert.assertTrue(outContent.toString().indexOf(test) > 0);
      Assert.assertTrue(outContent.toString().indexOf(taskInfo.getTaskId().toString()) > 0);
    }
  }
  finally {
    System.setOut(stdps);
  }
}
