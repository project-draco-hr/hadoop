{
  Cell cell=null;
  startNext();
  ByteArrayComparator comp=new ByteArrayComparator();
  byte[] currentColumnQualifier=TimelineStorageUtils.EMPTY_BYTES;
  AggregationOperation currentAggOp=null;
  SortedSet<Cell> currentColumnCells=new TreeSet<>(KeyValue.COMPARATOR);
  Set<String> alreadySeenAggDim=new HashSet<>();
  int addedCnt=0;
  ValueConverter converter=null;
  while (((cell=peekAtNextCell(cellLimit)) != null) && (cellLimit <= 0 || addedCnt < cellLimit)) {
    byte[] newColumnQualifier=CellUtil.cloneQualifier(cell);
    if (comp.compare(currentColumnQualifier,newColumnQualifier) != 0) {
      if (converter != null && isNumericConverter(converter)) {
        addedCnt+=emitCells(cells,currentColumnCells,currentAggOp,(NumericValueConverter)converter);
      }
      resetState(currentColumnCells,alreadySeenAggDim);
      currentColumnQualifier=newColumnQualifier;
      currentAggOp=getCurrentAggOp(cell);
      converter=getValueConverter(newColumnQualifier);
    }
    if (!isNumericConverter(converter)) {
      nextCell(cellLimit);
      continue;
    }
    collectCells(currentColumnCells,currentAggOp,cell,alreadySeenAggDim,(NumericValueConverter)converter);
    nextCell(cellLimit);
  }
  if (!currentColumnCells.isEmpty()) {
    emitCells(cells,currentColumnCells,currentAggOp,(NumericValueConverter)converter);
  }
  return hasMore();
}
