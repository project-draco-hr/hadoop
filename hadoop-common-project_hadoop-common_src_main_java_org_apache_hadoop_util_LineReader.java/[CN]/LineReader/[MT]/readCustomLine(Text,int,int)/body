{
  str.clear();
  int txtLength=0;
  long bytesConsumed=0;
  int delPosn=0;
  int ambiguousByteCount=0;
  do {
    int startPosn=bufferPosn;
    if (bufferPosn >= bufferLength) {
      startPosn=bufferPosn=0;
      bufferLength=fillBuffer(in,buffer,ambiguousByteCount > 0);
      if (bufferLength <= 0) {
        str.append(recordDelimiterBytes,0,ambiguousByteCount);
        break;
      }
    }
    for (; bufferPosn < bufferLength; ++bufferPosn) {
      if (buffer[bufferPosn] == recordDelimiterBytes[delPosn]) {
        delPosn++;
        if (delPosn >= recordDelimiterBytes.length) {
          bufferPosn++;
          break;
        }
      }
 else       if (delPosn != 0) {
        bufferPosn--;
        delPosn=0;
      }
    }
    int readLength=bufferPosn - startPosn;
    bytesConsumed+=readLength;
    int appendLength=readLength - delPosn;
    if (appendLength > maxLineLength - txtLength) {
      appendLength=maxLineLength - txtLength;
    }
    if (appendLength > 0) {
      if (ambiguousByteCount > 0) {
        str.append(recordDelimiterBytes,0,ambiguousByteCount);
        bytesConsumed+=ambiguousByteCount;
        ambiguousByteCount=0;
      }
      str.append(buffer,startPosn,appendLength);
      txtLength+=appendLength;
    }
    if (bufferPosn >= bufferLength) {
      if (delPosn > 0 && delPosn < recordDelimiterBytes.length) {
        ambiguousByteCount=delPosn;
        bytesConsumed-=ambiguousByteCount;
      }
    }
  }
 while (delPosn < recordDelimiterBytes.length && bytesConsumed < maxBytesToConsume);
  if (bytesConsumed > (long)Integer.MAX_VALUE) {
    throw new IOException("Too many bytes before delimiter: " + bytesConsumed);
  }
  return (int)bytesConsumed;
}
