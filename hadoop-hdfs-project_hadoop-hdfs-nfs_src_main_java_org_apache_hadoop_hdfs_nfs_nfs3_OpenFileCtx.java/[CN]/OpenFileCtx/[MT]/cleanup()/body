{
  if (!activeState) {
    LOG.info("Current OpenFileCtx is already inactive, no need to cleanup.");
    return;
  }
  activeState=false;
  if (dumpThread != null && dumpThread.isAlive()) {
    dumpThread.interrupt();
    try {
      dumpThread.join(3000);
    }
 catch (    InterruptedException ignored) {
    }
  }
  try {
    if (fos != null) {
      fos.close();
    }
  }
 catch (  IOException e) {
    LOG.info("Can't close stream for fileId:" + latestAttr.getFileId() + ", error:"+ e);
  }
  LOG.info("There are " + pendingWrites.size() + " pending writes.");
  WccAttr preOpAttr=latestAttr.getWccAttr();
  while (!pendingWrites.isEmpty()) {
    OffsetRange key=pendingWrites.firstKey();
    LOG.info("Fail pending write: (" + key.getMin() + ","+ key.getMax()+ "), nextOffset="+ nextOffset.get());
    WriteCtx writeCtx=pendingWrites.remove(key);
    if (!writeCtx.getReplied()) {
      WccData fileWcc=new WccData(preOpAttr,latestAttr);
      WRITE3Response response=new WRITE3Response(Nfs3Status.NFS3ERR_IO,fileWcc,0,writeCtx.getStableHow(),Nfs3Constant.WRITE_COMMIT_VERF);
      Nfs3Utils.writeChannel(writeCtx.getChannel(),response.serialize(new XDR(),writeCtx.getXid(),new VerifierNone()),writeCtx.getXid());
    }
  }
  if (dumpOut != null) {
    try {
      dumpOut.close();
    }
 catch (    IOException e) {
      LOG.error("Failed to close outputstream of dump file" + dumpFilePath,e);
    }
    File dumpFile=new File(dumpFilePath);
    if (dumpFile.exists() && !dumpFile.delete()) {
      LOG.error("Failed to delete dumpfile: " + dumpFile);
    }
  }
  if (raf != null) {
    try {
      raf.close();
    }
 catch (    IOException e) {
      LOG.error("Got exception when closing input stream of dump file.",e);
    }
  }
}
