{
  Preconditions.checkArgument(fencer != null,"failover requires a fencer");
  preFailoverChecks(toSvc,toSvcAddr);
  boolean tryFence=true;
  try {
    HAServiceProtocolHelper.transitionToStandby(fromSvc);
    tryFence=forceFence ? true : false;
  }
 catch (  ServiceFailedException sfe) {
    LOG.warn("Unable to make " + fromSvcAddr + " standby ("+ sfe.getMessage()+ ")");
  }
catch (  IOException ioe) {
    LOG.warn("Unable to make " + fromSvcAddr + " standby (unable to connect)",ioe);
  }
  if (tryFence) {
    if (!fencer.fence(fromSvcAddr)) {
      throw new FailoverFailedException("Unable to fence " + fromSvcAddr + ". Fencing failed.");
    }
  }
  boolean failed=false;
  Throwable cause=null;
  try {
    HAServiceProtocolHelper.transitionToActive(toSvc);
  }
 catch (  ServiceFailedException sfe) {
    LOG.error("Unable to make " + toSvcAddr + " active ("+ sfe.getMessage()+ "). Failing back.");
    failed=true;
    cause=sfe;
  }
catch (  IOException ioe) {
    LOG.error("Unable to make " + toSvcAddr + " active (unable to connect). Failing back.",ioe);
    failed=true;
    cause=ioe;
  }
  if (failed) {
    String msg="Unable to failover to " + toSvcAddr;
    if (!tryFence) {
      try {
        failover(toSvc,toSvcAddr,fromSvc,fromSvcAddr,fencer,true);
      }
 catch (      FailoverFailedException ffe) {
        msg+=". Failback to " + fromSvcAddr + " failed ("+ ffe.getMessage()+ ")";
        LOG.fatal(msg);
      }
    }
    throw new FailoverFailedException(msg,cause);
  }
}
