{
  FSDirectory fsDir=fsNamesys.dir;
  int numEdits=0;
  int numOpAdd=0, numOpClose=0, numOpDelete=0, numOpRenameOld=0, numOpSetRepl=0, numOpMkDir=0, numOpSetPerm=0, numOpSetOwner=0, numOpSetGenStamp=0, numOpTimes=0, numOpRename=0, numOpConcatDelete=0, numOpSymlink=0, numOpGetDelegationToken=0, numOpRenewDelegationToken=0, numOpCancelDelegationToken=0, numOpUpdateMasterKey=0, numOpReassignLease=0, numOpOther=0;
  fsNamesys.writeLock();
  fsDir.writeLock();
  PositionTrackingInputStream tracker=new PositionTrackingInputStream(in);
  in=new DataInputStream(tracker);
  long recentOpcodeOffsets[]=new long[4];
  Arrays.fill(recentOpcodeOffsets,-1);
  try {
    long txId=expectedStartingTxId - 1;
    try {
      FSEditLogOp.Reader reader=new FSEditLogOp.Reader(in,logVersion,checksum);
      FSEditLogOp op;
      while ((op=reader.readOp()) != null) {
        recentOpcodeOffsets[numEdits % recentOpcodeOffsets.length]=tracker.getPos();
        if (LayoutVersion.supports(Feature.STORED_TXIDS,logVersion)) {
          long thisTxId=op.txid;
          if (thisTxId != txId + 1) {
            throw new IOException("Expected transaction ID " + (txId + 1) + " but got "+ thisTxId);
          }
          txId=thisTxId;
        }
        numEdits++;
switch (op.opCode) {
case OP_ADD:
case OP_CLOSE:
{
            AddCloseOp addCloseOp=(AddCloseOp)op;
            short replication=fsNamesys.adjustReplication(addCloseOp.replication);
            long blockSize=addCloseOp.blockSize;
            BlockInfo blocks[]=new BlockInfo[addCloseOp.blocks.length];
            for (int i=0; i < addCloseOp.blocks.length; i++) {
              if (addCloseOp.opCode == FSEditLogOpCodes.OP_ADD && i == addCloseOp.blocks.length - 1) {
                blocks[i]=new BlockInfoUnderConstruction(addCloseOp.blocks[i],replication);
              }
 else {
                blocks[i]=new BlockInfo(addCloseOp.blocks[i],replication);
              }
            }
            PermissionStatus permissions=fsNamesys.getUpgradePermission();
            if (addCloseOp.permissions != null) {
              permissions=addCloseOp.permissions;
            }
            if (-8 <= logVersion && blockSize == 0) {
              if (blocks.length > 1) {
                blockSize=blocks[0].getNumBytes();
              }
 else {
                long first=((blocks.length == 1) ? blocks[0].getNumBytes() : 0);
                blockSize=Math.max(fsNamesys.getDefaultBlockSize(),first);
              }
            }
            if (FSNamesystem.LOG.isDebugEnabled()) {
              FSNamesystem.LOG.debug(op.opCode + ": " + addCloseOp.path+ " numblocks : "+ blocks.length+ " clientHolder "+ addCloseOp.clientName+ " clientMachine "+ addCloseOp.clientMachine);
            }
            fsDir.unprotectedDelete(addCloseOp.path,addCloseOp.mtime);
            INodeFile node=(INodeFile)fsDir.unprotectedAddFile(addCloseOp.path,permissions,blocks,replication,addCloseOp.mtime,addCloseOp.atime,blockSize);
            if (addCloseOp.opCode == FSEditLogOpCodes.OP_ADD) {
              numOpAdd++;
              INodeFileUnderConstruction cons=new INodeFileUnderConstruction(node.getLocalNameBytes(),node.getReplication(),node.getModificationTime(),node.getPreferredBlockSize(),node.getBlocks(),node.getPermissionStatus(),addCloseOp.clientName,addCloseOp.clientMachine,null);
              fsDir.replaceNode(addCloseOp.path,node,cons);
              fsNamesys.leaseManager.addLease(cons.getClientName(),addCloseOp.path);
            }
            break;
          }
case OP_SET_REPLICATION:
{
          numOpSetRepl++;
          SetReplicationOp setReplicationOp=(SetReplicationOp)op;
          short replication=fsNamesys.adjustReplication(setReplicationOp.replication);
          fsDir.unprotectedSetReplication(setReplicationOp.path,replication,null);
          break;
        }
case OP_CONCAT_DELETE:
{
        numOpConcatDelete++;
        ConcatDeleteOp concatDeleteOp=(ConcatDeleteOp)op;
        fsDir.unprotectedConcat(concatDeleteOp.trg,concatDeleteOp.srcs,concatDeleteOp.timestamp);
        break;
      }
case OP_RENAME_OLD:
{
      numOpRenameOld++;
      RenameOldOp renameOp=(RenameOldOp)op;
      HdfsFileStatus dinfo=fsDir.getFileInfo(renameOp.dst,false);
      fsDir.unprotectedRenameTo(renameOp.src,renameOp.dst,renameOp.timestamp);
      fsNamesys.unprotectedChangeLease(renameOp.src,renameOp.dst,dinfo);
      break;
    }
case OP_DELETE:
{
    numOpDelete++;
    DeleteOp deleteOp=(DeleteOp)op;
    fsDir.unprotectedDelete(deleteOp.path,deleteOp.timestamp);
    break;
  }
case OP_MKDIR:
{
  numOpMkDir++;
  MkdirOp mkdirOp=(MkdirOp)op;
  PermissionStatus permissions=fsNamesys.getUpgradePermission();
  if (mkdirOp.permissions != null) {
    permissions=mkdirOp.permissions;
  }
  fsDir.unprotectedMkdir(mkdirOp.path,permissions,mkdirOp.timestamp);
  break;
}
case OP_SET_GENSTAMP:
{
numOpSetGenStamp++;
SetGenstampOp setGenstampOp=(SetGenstampOp)op;
fsNamesys.setGenerationStamp(setGenstampOp.genStamp);
break;
}
case OP_SET_PERMISSIONS:
{
numOpSetPerm++;
SetPermissionsOp setPermissionsOp=(SetPermissionsOp)op;
fsDir.unprotectedSetPermission(setPermissionsOp.src,setPermissionsOp.permissions);
break;
}
case OP_SET_OWNER:
{
numOpSetOwner++;
SetOwnerOp setOwnerOp=(SetOwnerOp)op;
fsDir.unprotectedSetOwner(setOwnerOp.src,setOwnerOp.username,setOwnerOp.groupname);
break;
}
case OP_SET_NS_QUOTA:
{
SetNSQuotaOp setNSQuotaOp=(SetNSQuotaOp)op;
fsDir.unprotectedSetQuota(setNSQuotaOp.src,setNSQuotaOp.nsQuota,FSConstants.QUOTA_DONT_SET);
break;
}
case OP_CLEAR_NS_QUOTA:
{
ClearNSQuotaOp clearNSQuotaOp=(ClearNSQuotaOp)op;
fsDir.unprotectedSetQuota(clearNSQuotaOp.src,FSConstants.QUOTA_RESET,FSConstants.QUOTA_DONT_SET);
break;
}
case OP_SET_QUOTA:
SetQuotaOp setQuotaOp=(SetQuotaOp)op;
fsDir.unprotectedSetQuota(setQuotaOp.src,setQuotaOp.nsQuota,setQuotaOp.dsQuota);
break;
case OP_TIMES:
{
numOpTimes++;
TimesOp timesOp=(TimesOp)op;
fsDir.unprotectedSetTimes(timesOp.path,timesOp.mtime,timesOp.atime,true);
break;
}
case OP_SYMLINK:
{
numOpSymlink++;
SymlinkOp symlinkOp=(SymlinkOp)op;
fsDir.unprotectedSymlink(symlinkOp.path,symlinkOp.value,symlinkOp.mtime,symlinkOp.atime,symlinkOp.permissionStatus);
break;
}
case OP_RENAME:
{
numOpRename++;
RenameOp renameOp=(RenameOp)op;
HdfsFileStatus dinfo=fsDir.getFileInfo(renameOp.dst,false);
fsDir.unprotectedRenameTo(renameOp.src,renameOp.dst,renameOp.timestamp,renameOp.options);
fsNamesys.unprotectedChangeLease(renameOp.src,renameOp.dst,dinfo);
break;
}
case OP_GET_DELEGATION_TOKEN:
{
numOpGetDelegationToken++;
GetDelegationTokenOp getDelegationTokenOp=(GetDelegationTokenOp)op;
fsNamesys.getDelegationTokenSecretManager().addPersistedDelegationToken(getDelegationTokenOp.token,getDelegationTokenOp.expiryTime);
break;
}
case OP_RENEW_DELEGATION_TOKEN:
{
numOpRenewDelegationToken++;
RenewDelegationTokenOp renewDelegationTokenOp=(RenewDelegationTokenOp)op;
fsNamesys.getDelegationTokenSecretManager().updatePersistedTokenRenewal(renewDelegationTokenOp.token,renewDelegationTokenOp.expiryTime);
break;
}
case OP_CANCEL_DELEGATION_TOKEN:
{
numOpCancelDelegationToken++;
CancelDelegationTokenOp cancelDelegationTokenOp=(CancelDelegationTokenOp)op;
fsNamesys.getDelegationTokenSecretManager().updatePersistedTokenCancellation(cancelDelegationTokenOp.token);
break;
}
case OP_UPDATE_MASTER_KEY:
{
numOpUpdateMasterKey++;
UpdateMasterKeyOp updateMasterKeyOp=(UpdateMasterKeyOp)op;
fsNamesys.getDelegationTokenSecretManager().updatePersistedMasterKey(updateMasterKeyOp.key);
break;
}
case OP_REASSIGN_LEASE:
{
numOpReassignLease++;
ReassignLeaseOp reassignLeaseOp=(ReassignLeaseOp)op;
Lease lease=fsNamesys.leaseManager.getLease(reassignLeaseOp.leaseHolder);
INodeFileUnderConstruction pendingFile=(INodeFileUnderConstruction)fsDir.getFileINode(reassignLeaseOp.path);
fsNamesys.reassignLeaseInternal(lease,reassignLeaseOp.path,reassignLeaseOp.newHolder,pendingFile);
break;
}
case OP_START_LOG_SEGMENT:
case OP_END_LOG_SEGMENT:
{
numOpOther++;
break;
}
case OP_DATANODE_ADD:
case OP_DATANODE_REMOVE:
numOpOther++;
break;
default :
throw new IOException("Invalid operation read " + op.opCode);
}
}
}
 catch (IOException ex) {
check203UpgradeFailure(logVersion,ex);
}
 finally {
if (closeOnExit) in.close();
}
}
 catch (Throwable t) {
StringBuilder sb=new StringBuilder();
sb.append("Error replaying edit log at offset " + tracker.getPos());
if (recentOpcodeOffsets[0] != -1) {
Arrays.sort(recentOpcodeOffsets);
sb.append("\nRecent opcode offsets:");
for (long offset : recentOpcodeOffsets) {
if (offset != -1) {
sb.append(' ').append(offset);
}
}
}
String errorMessage=sb.toString();
FSImage.LOG.error(errorMessage);
throw new IOException(errorMessage,t);
}
 finally {
fsDir.writeUnlock();
fsNamesys.writeUnlock();
}
if (FSImage.LOG.isDebugEnabled()) {
FSImage.LOG.debug("numOpAdd = " + numOpAdd + " numOpClose = "+ numOpClose+ " numOpDelete = "+ numOpDelete+ " numOpRenameOld = "+ numOpRenameOld+ " numOpSetRepl = "+ numOpSetRepl+ " numOpMkDir = "+ numOpMkDir+ " numOpSetPerm = "+ numOpSetPerm+ " numOpSetOwner = "+ numOpSetOwner+ " numOpSetGenStamp = "+ numOpSetGenStamp+ " numOpTimes = "+ numOpTimes+ " numOpConcatDelete  = "+ numOpConcatDelete+ " numOpRename = "+ numOpRename+ " numOpGetDelegationToken = "+ numOpGetDelegationToken+ " numOpRenewDelegationToken = "+ numOpRenewDelegationToken+ " numOpCancelDelegationToken = "+ numOpCancelDelegationToken+ " numOpUpdateMasterKey = "+ numOpUpdateMasterKey+ " numOpReassignLease = "+ numOpReassignLease+ " numOpOther = "+ numOpOther);
}
return numEdits;
}
