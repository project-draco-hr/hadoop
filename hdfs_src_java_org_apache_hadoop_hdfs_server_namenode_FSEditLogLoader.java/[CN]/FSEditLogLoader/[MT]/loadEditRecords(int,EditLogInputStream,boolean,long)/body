{
  FSDirectory fsDir=fsNamesys.dir;
  int numEdits=0;
  EnumMap<FSEditLogOpCodes,Holder<Integer>> opCounts=new EnumMap<FSEditLogOpCodes,Holder<Integer>>(FSEditLogOpCodes.class);
  fsNamesys.writeLock();
  fsDir.writeLock();
  long recentOpcodeOffsets[]=new long[4];
  Arrays.fill(recentOpcodeOffsets,-1);
  try {
    long txId=expectedStartingTxId - 1;
    try {
      FSEditLogOp op;
      while ((op=in.readOp()) != null) {
        recentOpcodeOffsets[numEdits % recentOpcodeOffsets.length]=in.getPosition();
        if (LayoutVersion.supports(Feature.STORED_TXIDS,logVersion)) {
          long thisTxId=op.txid;
          if (thisTxId != txId + 1) {
            throw new IOException("Expected transaction ID " + (txId + 1) + " but got "+ thisTxId);
          }
          txId=thisTxId;
        }
        numEdits++;
        incrOpCount(op.opCode,opCounts);
switch (op.opCode) {
case OP_ADD:
case OP_CLOSE:
{
            AddCloseOp addCloseOp=(AddCloseOp)op;
            final short replication=fsNamesys.getBlockManager().adjustReplication(addCloseOp.replication);
            long blockSize=addCloseOp.blockSize;
            BlockInfo blocks[]=new BlockInfo[addCloseOp.blocks.length];
            for (int i=0; i < addCloseOp.blocks.length; i++) {
              if (addCloseOp.opCode == FSEditLogOpCodes.OP_ADD && i == addCloseOp.blocks.length - 1) {
                blocks[i]=new BlockInfoUnderConstruction(addCloseOp.blocks[i],replication);
              }
 else {
                blocks[i]=new BlockInfo(addCloseOp.blocks[i],replication);
              }
            }
            PermissionStatus permissions=fsNamesys.getUpgradePermission();
            if (addCloseOp.permissions != null) {
              permissions=addCloseOp.permissions;
            }
            if (-8 <= logVersion && blockSize == 0) {
              if (blocks.length > 1) {
                blockSize=blocks[0].getNumBytes();
              }
 else {
                long first=((blocks.length == 1) ? blocks[0].getNumBytes() : 0);
                blockSize=Math.max(fsNamesys.getDefaultBlockSize(),first);
              }
            }
            if (FSNamesystem.LOG.isDebugEnabled()) {
              FSNamesystem.LOG.debug(op.opCode + ": " + addCloseOp.path+ " numblocks : "+ blocks.length+ " clientHolder "+ addCloseOp.clientName+ " clientMachine "+ addCloseOp.clientMachine);
            }
            fsDir.unprotectedDelete(addCloseOp.path,addCloseOp.mtime);
            INodeFile node=(INodeFile)fsDir.unprotectedAddFile(addCloseOp.path,permissions,blocks,replication,addCloseOp.mtime,addCloseOp.atime,blockSize);
            if (addCloseOp.opCode == FSEditLogOpCodes.OP_ADD) {
              INodeFileUnderConstruction cons=new INodeFileUnderConstruction(node.getLocalNameBytes(),node.getReplication(),node.getModificationTime(),node.getPreferredBlockSize(),node.getBlocks(),node.getPermissionStatus(),addCloseOp.clientName,addCloseOp.clientMachine,null);
              fsDir.replaceNode(addCloseOp.path,node,cons);
              fsNamesys.leaseManager.addLease(cons.getClientName(),addCloseOp.path);
            }
            break;
          }
case OP_SET_REPLICATION:
{
          SetReplicationOp setReplicationOp=(SetReplicationOp)op;
          short replication=fsNamesys.getBlockManager().adjustReplication(setReplicationOp.replication);
          fsDir.unprotectedSetReplication(setReplicationOp.path,replication,null);
          break;
        }
case OP_CONCAT_DELETE:
{
        ConcatDeleteOp concatDeleteOp=(ConcatDeleteOp)op;
        fsDir.unprotectedConcat(concatDeleteOp.trg,concatDeleteOp.srcs,concatDeleteOp.timestamp);
        break;
      }
case OP_RENAME_OLD:
{
      RenameOldOp renameOp=(RenameOldOp)op;
      HdfsFileStatus dinfo=fsDir.getFileInfo(renameOp.dst,false);
      fsDir.unprotectedRenameTo(renameOp.src,renameOp.dst,renameOp.timestamp);
      fsNamesys.unprotectedChangeLease(renameOp.src,renameOp.dst,dinfo);
      break;
    }
case OP_DELETE:
{
    DeleteOp deleteOp=(DeleteOp)op;
    fsDir.unprotectedDelete(deleteOp.path,deleteOp.timestamp);
    break;
  }
case OP_MKDIR:
{
  MkdirOp mkdirOp=(MkdirOp)op;
  PermissionStatus permissions=fsNamesys.getUpgradePermission();
  if (mkdirOp.permissions != null) {
    permissions=mkdirOp.permissions;
  }
  fsDir.unprotectedMkdir(mkdirOp.path,permissions,mkdirOp.timestamp);
  break;
}
case OP_SET_GENSTAMP:
{
SetGenstampOp setGenstampOp=(SetGenstampOp)op;
fsNamesys.setGenerationStamp(setGenstampOp.genStamp);
break;
}
case OP_SET_PERMISSIONS:
{
SetPermissionsOp setPermissionsOp=(SetPermissionsOp)op;
fsDir.unprotectedSetPermission(setPermissionsOp.src,setPermissionsOp.permissions);
break;
}
case OP_SET_OWNER:
{
SetOwnerOp setOwnerOp=(SetOwnerOp)op;
fsDir.unprotectedSetOwner(setOwnerOp.src,setOwnerOp.username,setOwnerOp.groupname);
break;
}
case OP_SET_NS_QUOTA:
{
SetNSQuotaOp setNSQuotaOp=(SetNSQuotaOp)op;
fsDir.unprotectedSetQuota(setNSQuotaOp.src,setNSQuotaOp.nsQuota,FSConstants.QUOTA_DONT_SET);
break;
}
case OP_CLEAR_NS_QUOTA:
{
ClearNSQuotaOp clearNSQuotaOp=(ClearNSQuotaOp)op;
fsDir.unprotectedSetQuota(clearNSQuotaOp.src,FSConstants.QUOTA_RESET,FSConstants.QUOTA_DONT_SET);
break;
}
case OP_SET_QUOTA:
SetQuotaOp setQuotaOp=(SetQuotaOp)op;
fsDir.unprotectedSetQuota(setQuotaOp.src,setQuotaOp.nsQuota,setQuotaOp.dsQuota);
break;
case OP_TIMES:
{
TimesOp timesOp=(TimesOp)op;
fsDir.unprotectedSetTimes(timesOp.path,timesOp.mtime,timesOp.atime,true);
break;
}
case OP_SYMLINK:
{
SymlinkOp symlinkOp=(SymlinkOp)op;
fsDir.unprotectedSymlink(symlinkOp.path,symlinkOp.value,symlinkOp.mtime,symlinkOp.atime,symlinkOp.permissionStatus);
break;
}
case OP_RENAME:
{
RenameOp renameOp=(RenameOp)op;
HdfsFileStatus dinfo=fsDir.getFileInfo(renameOp.dst,false);
fsDir.unprotectedRenameTo(renameOp.src,renameOp.dst,renameOp.timestamp,renameOp.options);
fsNamesys.unprotectedChangeLease(renameOp.src,renameOp.dst,dinfo);
break;
}
case OP_GET_DELEGATION_TOKEN:
{
GetDelegationTokenOp getDelegationTokenOp=(GetDelegationTokenOp)op;
fsNamesys.getDelegationTokenSecretManager().addPersistedDelegationToken(getDelegationTokenOp.token,getDelegationTokenOp.expiryTime);
break;
}
case OP_RENEW_DELEGATION_TOKEN:
{
RenewDelegationTokenOp renewDelegationTokenOp=(RenewDelegationTokenOp)op;
fsNamesys.getDelegationTokenSecretManager().updatePersistedTokenRenewal(renewDelegationTokenOp.token,renewDelegationTokenOp.expiryTime);
break;
}
case OP_CANCEL_DELEGATION_TOKEN:
{
CancelDelegationTokenOp cancelDelegationTokenOp=(CancelDelegationTokenOp)op;
fsNamesys.getDelegationTokenSecretManager().updatePersistedTokenCancellation(cancelDelegationTokenOp.token);
break;
}
case OP_UPDATE_MASTER_KEY:
{
UpdateMasterKeyOp updateMasterKeyOp=(UpdateMasterKeyOp)op;
fsNamesys.getDelegationTokenSecretManager().updatePersistedMasterKey(updateMasterKeyOp.key);
break;
}
case OP_REASSIGN_LEASE:
{
ReassignLeaseOp reassignLeaseOp=(ReassignLeaseOp)op;
Lease lease=fsNamesys.leaseManager.getLease(reassignLeaseOp.leaseHolder);
INodeFileUnderConstruction pendingFile=(INodeFileUnderConstruction)fsDir.getFileINode(reassignLeaseOp.path);
fsNamesys.reassignLeaseInternal(lease,reassignLeaseOp.path,reassignLeaseOp.newHolder,pendingFile);
break;
}
case OP_START_LOG_SEGMENT:
case OP_END_LOG_SEGMENT:
{
break;
}
case OP_DATANODE_ADD:
case OP_DATANODE_REMOVE:
break;
default :
throw new IOException("Invalid operation read " + op.opCode);
}
}
}
 catch (IOException ex) {
check203UpgradeFailure(logVersion,ex);
}
 finally {
if (closeOnExit) in.close();
}
}
 catch (Throwable t) {
StringBuilder sb=new StringBuilder();
sb.append("Error replaying edit log at offset " + in.getPosition());
if (recentOpcodeOffsets[0] != -1) {
Arrays.sort(recentOpcodeOffsets);
sb.append("\nRecent opcode offsets:");
for (long offset : recentOpcodeOffsets) {
if (offset != -1) {
sb.append(' ').append(offset);
}
}
}
String errorMessage=sb.toString();
FSImage.LOG.error(errorMessage);
throw new IOException(errorMessage,t);
}
 finally {
fsDir.writeUnlock();
fsNamesys.writeUnlock();
}
if (FSImage.LOG.isDebugEnabled()) {
dumpOpCounts(opCounts);
}
return numEdits;
}
