{
  try {
    Configuration conf=getConf();
    eventLog=new FairSchedulerEventLog();
    boolean logEnabled=conf.getBoolean("mapred.fairscheduler.eventlog.enabled",false);
    if (!mockMode && logEnabled) {
      String hostname="localhost";
      if (taskTrackerManager instanceof JobTracker) {
        hostname=((JobTracker)taskTrackerManager).getJobTrackerMachine();
      }
      eventLog.init(conf,hostname);
    }
    jobInitializer=new JobInitializer(conf,taskTrackerManager);
    taskTrackerManager.addJobInProgressListener(jobListener);
    poolMgr=new PoolManager(this);
    poolMgr.initialize();
    loadMgr=(LoadManager)ReflectionUtils.newInstance(conf.getClass("mapred.fairscheduler.loadmanager",CapBasedLoadManager.class,LoadManager.class),conf);
    loadMgr.setTaskTrackerManager(taskTrackerManager);
    loadMgr.setEventLog(eventLog);
    loadMgr.start();
    taskSelector=(TaskSelector)ReflectionUtils.newInstance(conf.getClass("mapred.fairscheduler.taskselector",DefaultTaskSelector.class,TaskSelector.class),conf);
    taskSelector.setTaskTrackerManager(taskTrackerManager);
    taskSelector.start();
    Class<?> weightAdjClass=conf.getClass("mapred.fairscheduler.weightadjuster",null);
    if (weightAdjClass != null) {
      weightAdjuster=(WeightAdjuster)ReflectionUtils.newInstance(weightAdjClass,conf);
    }
    updateInterval=conf.getLong("mapred.fairscheduler.update.interval",500);
    dumpInterval=conf.getLong("mapred.fairscheduler.dump.interval",10000);
    preemptionInterval=conf.getLong("mapred.fairscheduler.preemption.interval",15000);
    assignMultiple=conf.getBoolean("mapred.fairscheduler.assignmultiple",true);
    mapAssignCap=conf.getInt("mapred.fairscheduler.assignmultiple.maps",-1);
    reduceAssignCap=conf.getInt("mapred.fairscheduler.assignmultiple.reduces",-1);
    sizeBasedWeight=conf.getBoolean("mapred.fairscheduler.sizebasedweight",false);
    preemptionEnabled=conf.getBoolean("mapred.fairscheduler.preemption",false);
    onlyLogPreemption=conf.getBoolean("mapred.fairscheduler.preemption.only.log",false);
    long defaultDelay=conf.getLong("mapred.fairscheduler.locality.delay",-1);
    nodeLocalityDelay=conf.getLong("mapred.fairscheduler.locality.delay.node",defaultDelay);
    rackLocalityDelay=conf.getLong("mapred.fairscheduler.locality.delay.rack",defaultDelay);
    if (defaultDelay == -1 && (nodeLocalityDelay == -1 || rackLocalityDelay == -1)) {
      autoComputeLocalityDelay=true;
    }
    initialized=true;
    running=true;
    lastUpdateTime=clock.getTime();
    if (!mockMode) {
      new UpdateThread().start();
    }
    if (taskTrackerManager instanceof JobTracker) {
      JobTracker jobTracker=(JobTracker)taskTrackerManager;
      HttpServer infoServer=jobTracker.infoServer;
      infoServer.setAttribute("scheduler",this);
      infoServer.addServlet("scheduler","/scheduler",FairSchedulerServlet.class);
    }
    initMetrics();
    eventLog.log("INITIALIZED");
  }
 catch (  Exception e) {
    throw new RuntimeException("Failed to start FairScheduler",e);
  }
  LOG.info("Successfully configured FairScheduler");
}
