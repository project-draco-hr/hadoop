{
  if (!initialized)   return null;
  String trackerName=tracker.getTrackerName();
  eventLog.log("HEARTBEAT",trackerName);
  long currentTime=clock.getTime();
  int runnableMaps=0;
  int runningMaps=0;
  int runnableReduces=0;
  int runningReduces=0;
  for (  Pool pool : poolMgr.getPools()) {
    runnableMaps+=pool.getMapSchedulable().getDemand();
    runningMaps+=pool.getMapSchedulable().getRunningTasks();
    runnableReduces+=pool.getReduceSchedulable().getDemand();
    runningReduces+=pool.getReduceSchedulable().getRunningTasks();
  }
  ClusterStatus clusterStatus=taskTrackerManager.getClusterStatus();
  int totalMapSlots=getTotalSlots(TaskType.MAP,clusterStatus);
  int totalReduceSlots=getTotalSlots(TaskType.REDUCE,clusterStatus);
  eventLog.log("RUNNABLE_TASKS",runnableMaps,runningMaps,runnableReduces,runningReduces);
  updateLocalityWaitTimes(currentTime);
  TaskTrackerStatus tts=tracker.getStatus();
  int mapsAssigned=0;
  int reducesAssigned=0;
  int mapCapacity=maxTasksToAssign(TaskType.MAP,tts);
  int reduceCapacity=maxTasksToAssign(TaskType.REDUCE,tts);
  boolean mapRejected=false;
  boolean reduceRejected=false;
  Set<JobInProgress> visitedForMap=new HashSet<JobInProgress>();
  Set<JobInProgress> visitedForReduce=new HashSet<JobInProgress>();
  Set<JobInProgress> launchedMap=new HashSet<JobInProgress>();
  ArrayList<Task> tasks=new ArrayList<Task>();
  while (true) {
    if (!mapRejected) {
      if (mapsAssigned == mapCapacity || runningMaps == runnableMaps || !loadMgr.canAssignMap(tts,runnableMaps,totalMapSlots)) {
        eventLog.log("INFO","Can't assign another MAP to " + trackerName);
        mapRejected=true;
      }
    }
    if (!reduceRejected) {
      if (reducesAssigned == reduceCapacity || runningReduces == runnableReduces || !loadMgr.canAssignReduce(tts,runnableReduces,totalReduceSlots)) {
        eventLog.log("INFO","Can't assign another REDUCE to " + trackerName);
        reduceRejected=true;
      }
    }
    if (mapRejected && reduceRejected || !assignMultiple && tasks.size() > 0) {
      break;
    }
    TaskType taskType;
    if (mapRejected) {
      taskType=TaskType.REDUCE;
    }
 else     if (reduceRejected) {
      taskType=TaskType.MAP;
    }
 else {
      if (tts.countMapTasks() <= tts.countReduceTasks()) {
        taskType=TaskType.MAP;
      }
 else {
        taskType=TaskType.REDUCE;
      }
    }
    List<PoolSchedulable> scheds=getPoolSchedulables(taskType);
    Collections.sort(scheds,new SchedulingAlgorithms.FairShareComparator());
    boolean foundTask=false;
    for (    Schedulable sched : scheds) {
      eventLog.log("INFO","Checking for " + taskType + " task in "+ sched.getName());
      Task task=taskType == TaskType.MAP ? sched.assignTask(tts,currentTime,visitedForMap) : sched.assignTask(tts,currentTime,visitedForReduce);
      if (task != null) {
        foundTask=true;
        JobInProgress job=taskTrackerManager.getJob(task.getJobID());
        eventLog.log("ASSIGN",trackerName,taskType,job.getJobID(),task.getTaskID());
        if (taskType == TaskType.MAP) {
          launchedMap.add(job);
          mapsAssigned++;
          runningMaps++;
          updateLastMapLocalityLevel(job,task,tts);
        }
 else {
          reducesAssigned++;
          runningReduces++;
        }
        tasks.add(task);
        break;
      }
    }
    if (!foundTask) {
      if (taskType == TaskType.MAP) {
        mapRejected=true;
      }
 else {
        reduceRejected=true;
      }
    }
  }
  for (  JobInProgress job : visitedForMap) {
    if (!launchedMap.contains(job)) {
      infos.get(job).skippedAtLastHeartbeat=true;
    }
  }
  return tasks.isEmpty() ? null : tasks;
}
