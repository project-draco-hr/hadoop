{
  Configuration conf=new Configuration();
  FileContext files=FileContext.getLocalFSFileContext(conf);
  final Path basedir=files.makeQualified(new Path("target",TestFSDownload.class.getSimpleName()));
  files.mkdir(basedir,null,true);
  conf.setStrings(TestFSDownload.class.getName(),basedir.toString());
  Map<LocalResource,LocalResourceVisibility> rsrcVis=new HashMap<LocalResource,LocalResourceVisibility>();
  Random rand=new Random();
  long sharedSeed=rand.nextLong();
  rand.setSeed(sharedSeed);
  System.out.println("SEED: " + sharedSeed);
  Map<LocalResource,Future<Path>> pending=new HashMap<LocalResource,Future<Path>>();
  ExecutorService exec=Executors.newSingleThreadExecutor();
  LocalDirAllocator dirs=new LocalDirAllocator(TestFSDownload.class.getName());
  int[] sizes=new int[10];
  for (int i=0; i < 10; ++i) {
    sizes[i]=rand.nextInt(512) + 512;
    LocalResourceVisibility vis=LocalResourceVisibility.PUBLIC;
switch (i % 3) {
case 1:
      vis=LocalResourceVisibility.PRIVATE;
    break;
case 2:
  vis=LocalResourceVisibility.APPLICATION;
break;
}
LocalResource rsrc=createFile(files,new Path(basedir,"" + i),sizes[i],rand,vis);
rsrcVis.put(rsrc,vis);
FSDownload fsd=new FSDownload(files,UserGroupInformation.getCurrentUser(),conf,dirs,rsrc,new Random(sharedSeed));
pending.put(rsrc,exec.submit(fsd));
}
try {
for (Map.Entry<LocalResource,Future<Path>> p : pending.entrySet()) {
Path localized=p.getValue().get();
assertEquals(sizes[Integer.valueOf(localized.getName())],p.getKey().getSize());
FileStatus status=files.getFileStatus(localized);
FsPermission perm=status.getPermission();
System.out.println("File permission " + perm + " for rsrc vis "+ p.getKey().getVisibility().name());
assert(rsrcVis.containsKey(p.getKey()));
switch (rsrcVis.get(p.getKey())) {
case PUBLIC:
Assert.assertTrue("Public file should be 555",perm.toShort() == FSDownload.PUBLIC_FILE_PERMS.toShort());
break;
case PRIVATE:
case APPLICATION:
Assert.assertTrue("Private file should be 500",perm.toShort() == FSDownload.PRIVATE_FILE_PERMS.toShort());
break;
}
}
}
 catch (ExecutionException e) {
throw new IOException("Failed exec",e);
}
 finally {
exec.shutdown();
}
}
