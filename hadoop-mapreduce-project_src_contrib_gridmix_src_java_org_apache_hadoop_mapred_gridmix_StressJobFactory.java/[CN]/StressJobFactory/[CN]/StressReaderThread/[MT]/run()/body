{
  try {
    startFlag.await();
    if (Thread.currentThread().isInterrupted()) {
      LOG.warn("[STRESS] Interrupted before start!. Exiting..");
      return;
    }
    LOG.info("START STRESS @ " + System.currentTimeMillis());
    while (!Thread.currentThread().isInterrupted()) {
      try {
        while (loadStatus.overloaded()) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Updating the overload status.");
          }
          try {
            checkLoadAndGetSlotsToBackfill();
          }
 catch (          IOException ioe) {
            LOG.warn("[STRESS] Check failed!",ioe);
            return;
          }
          if (loadStatus.overloaded()) {
            if (LOG.isDebugEnabled()) {
              LOG.debug("[STRESS] Cluster overloaded in run! Sleeping...");
            }
            try {
              Thread.sleep(1000);
            }
 catch (            InterruptedException ie) {
              LOG.warn("[STRESS] Interrupted while sleeping! Exiting.",ie);
              return;
            }
          }
        }
        while (!loadStatus.overloaded()) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("[STRESS] Cluster underloaded in run! Stressing...");
          }
          try {
            final JobStory job=getNextJobFiltered();
            if (null == job) {
              LOG.warn("[STRESS] Finished consuming the input trace. " + "Exiting..");
              return;
            }
            if (LOG.isDebugEnabled()) {
              LOG.debug("Job Selected: " + job.getJobID());
            }
            UserGroupInformation ugi=UserGroupInformation.createRemoteUser(job.getUser());
            UserGroupInformation tgtUgi=userResolver.getTargetUgi(ugi);
            GridmixJob tJob=jobCreator.createGridmixJob(conf,0L,job,scratch,tgtUgi,sequence.getAndIncrement());
            submitter.add(tJob);
            int incompleteMapTasks=(int)calcEffectiveIncompleteMapTasks(loadStatus.getMapCapacity(),job.getNumberMaps(),0.0f);
            loadStatus.decrementMapLoad(incompleteMapTasks);
            int incompleteReduceTasks=(int)calcEffectiveIncompleteReduceTasks(loadStatus.getReduceCapacity(),job.getNumberReduces(),0.0f);
            loadStatus.decrementReduceLoad(incompleteReduceTasks);
            loadStatus.decrementJobLoad(1);
          }
 catch (          IOException e) {
            LOG.error("[STRESS] Error while submitting the job ",e);
            error=e;
            return;
          }
        }
      }
  finally {
      }
    }
  }
 catch (  InterruptedException e) {
    LOG.error("[STRESS] Interrupted in the main block!",e);
    return;
  }
 finally {
    IOUtils.cleanup(null,jobProducer);
  }
}
