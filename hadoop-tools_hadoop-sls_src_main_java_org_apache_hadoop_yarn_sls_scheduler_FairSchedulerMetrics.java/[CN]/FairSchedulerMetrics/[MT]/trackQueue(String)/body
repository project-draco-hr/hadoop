{
  trackedQueues.add(queueName);
  FairScheduler fair=(FairScheduler)scheduler;
  final FSQueue queue=fair.getQueueManager().getQueue(queueName);
  metrics.register("variable.queue." + queueName + ".demand.memory",new Gauge<Integer>(){
    @Override public Integer getValue(){
      return queue.getDemand().getMemory();
    }
  }
);
  metrics.register("variable.queue." + queueName + ".demand.vcores",new Gauge<Integer>(){
    @Override public Integer getValue(){
      return queue.getDemand().getVirtualCores();
    }
  }
);
  metrics.register("variable.queue." + queueName + ".usage.memory",new Gauge<Integer>(){
    @Override public Integer getValue(){
      return queue.getResourceUsage().getMemory();
    }
  }
);
  metrics.register("variable.queue." + queueName + ".usage.vcores",new Gauge<Integer>(){
    @Override public Integer getValue(){
      return queue.getResourceUsage().getVirtualCores();
    }
  }
);
  metrics.register("variable.queue." + queueName + ".minshare.memory",new Gauge<Integer>(){
    @Override public Integer getValue(){
      return queue.getMinShare().getMemory();
    }
  }
);
  metrics.register("variable.queue." + queueName + ".minshare.vcores",new Gauge<Integer>(){
    @Override public Integer getValue(){
      return queue.getMinShare().getVirtualCores();
    }
  }
);
  metrics.register("variable.queue." + queueName + ".maxshare.memory",new Gauge<Integer>(){
    @Override public Integer getValue(){
      if (!maxReset && SLSRunner.simulateInfoMap.containsKey("Number of nodes") && SLSRunner.simulateInfoMap.containsKey("Node memory (MB)")&& SLSRunner.simulateInfoMap.containsKey("Node VCores")) {
        int numNMs=Integer.parseInt(SLSRunner.simulateInfoMap.get("Number of nodes").toString());
        int numMemoryMB=Integer.parseInt(SLSRunner.simulateInfoMap.get("Node memory (MB)").toString());
        int numVCores=Integer.parseInt(SLSRunner.simulateInfoMap.get("Node VCores").toString());
        totalMemoryMB=numNMs * numMemoryMB;
        totalVCores=numNMs * numVCores;
        maxReset=false;
      }
      return Math.min(queue.getMaxShare().getMemory(),totalMemoryMB);
    }
  }
);
  metrics.register("variable.queue." + queueName + ".maxshare.vcores",new Gauge<Integer>(){
    @Override public Integer getValue(){
      return Math.min(queue.getMaxShare().getVirtualCores(),totalVCores);
    }
  }
);
  metrics.register("variable.queue." + queueName + ".fairshare.memory",new Gauge<Integer>(){
    @Override public Integer getValue(){
      return queue.getFairShare().getMemory();
    }
  }
);
  metrics.register("variable.queue." + queueName + ".fairshare.vcores",new Gauge<Integer>(){
    @Override public Integer getValue(){
      return queue.getFairShare().getVirtualCores();
    }
  }
);
}
