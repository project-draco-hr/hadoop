{
switch (reportedState) {
case FINALIZED:
switch (ucState) {
case COMPLETE:
case COMMITTED:
      if (storedBlock.getGenerationStamp() != reported.getGenerationStamp()) {
        final long reportedGS=reported.getGenerationStamp();
        return new BlockToMarkCorrupt(new Block(reported),storedBlock,reportedGS,"block is " + ucState + " and reported genstamp "+ reportedGS+ " does not match genstamp in block map "+ storedBlock.getGenerationStamp(),Reason.GENSTAMP_MISMATCH);
      }
 else       if (storedBlock.getNumBytes() != reported.getNumBytes()) {
        return new BlockToMarkCorrupt(new Block(reported),storedBlock,"block is " + ucState + " and reported length "+ reported.getNumBytes()+ " does not match "+ "length in block map "+ storedBlock.getNumBytes(),Reason.SIZE_MISMATCH);
      }
 else {
        return null;
      }
case UNDER_CONSTRUCTION:
    if (storedBlock.getGenerationStamp() > reported.getGenerationStamp()) {
      final long reportedGS=reported.getGenerationStamp();
      return new BlockToMarkCorrupt(new Block(reported),storedBlock,reportedGS,"block is " + ucState + " and reported state "+ reportedState+ ", But reported genstamp "+ reportedGS+ " does not match genstamp in block map "+ storedBlock.getGenerationStamp(),Reason.GENSTAMP_MISMATCH);
    }
  return null;
default :
return null;
}
case RBW:
case RWR:
if (!storedBlock.isComplete()) {
return null;
}
 else if (storedBlock.getGenerationStamp() != reported.getGenerationStamp()) {
final long reportedGS=reported.getGenerationStamp();
return new BlockToMarkCorrupt(new Block(reported),storedBlock,reportedGS,"reported " + reportedState + " replica with genstamp "+ reportedGS+ " does not match COMPLETE block's genstamp in block map "+ storedBlock.getGenerationStamp(),Reason.GENSTAMP_MISMATCH);
}
 else {
if (reportedState == ReplicaState.RBW) {
LOG.info("Received an RBW replica for " + storedBlock + " on "+ dn+ ": ignoring it, since it is "+ "complete with the same genstamp");
return null;
}
 else {
return new BlockToMarkCorrupt(new Block(reported),storedBlock,"reported replica has invalid state " + reportedState,Reason.INVALID_STATE);
}
}
case RUR:
case TEMPORARY:
default :
String msg="Unexpected replica state " + reportedState + " for block: "+ storedBlock+ " on "+ dn+ " size "+ storedBlock.getNumBytes();
LOG.warn(msg);
return new BlockToMarkCorrupt(new Block(reported),storedBlock,msg,Reason.INVALID_STATE);
}
}
