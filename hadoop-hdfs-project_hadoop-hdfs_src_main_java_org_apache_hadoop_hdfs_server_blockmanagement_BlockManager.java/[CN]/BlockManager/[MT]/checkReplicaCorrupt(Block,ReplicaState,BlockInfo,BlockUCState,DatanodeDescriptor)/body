{
switch (reportedState) {
case FINALIZED:
switch (ucState) {
case COMPLETE:
case COMMITTED:
      if (storedBlock.getGenerationStamp() != reported.getGenerationStamp()) {
        final long reportedGS=reported.getGenerationStamp();
        return new BlockToMarkCorrupt(storedBlock,reportedGS,"block is " + ucState + " and reported genstamp "+ reportedGS+ " does not match genstamp in block map "+ storedBlock.getGenerationStamp());
      }
 else       if (storedBlock.getNumBytes() != reported.getNumBytes()) {
        return new BlockToMarkCorrupt(storedBlock,"block is " + ucState + " and reported length "+ reported.getNumBytes()+ " does not match "+ "length in block map "+ storedBlock.getNumBytes());
      }
 else {
        return null;
      }
default :
    return null;
}
case RBW:
case RWR:
if (!storedBlock.isComplete()) {
return null;
}
 else if (storedBlock.getGenerationStamp() != reported.getGenerationStamp()) {
final long reportedGS=reported.getGenerationStamp();
return new BlockToMarkCorrupt(storedBlock,reportedGS,"reported " + reportedState + " replica with genstamp "+ reportedGS+ " does not match COMPLETE block's genstamp in block map "+ storedBlock.getGenerationStamp());
}
 else {
if (reportedState == ReplicaState.RBW) {
  LOG.info("Received an RBW replica for " + storedBlock + " on "+ dn+ ": ignoring it, since it is "+ "complete with the same genstamp");
  return null;
}
 else {
  return new BlockToMarkCorrupt(storedBlock,"reported replica has invalid state " + reportedState);
}
}
case RUR:
case TEMPORARY:
default :
String msg="Unexpected replica state " + reportedState + " for block: "+ storedBlock+ " on "+ dn+ " size "+ storedBlock.getNumBytes();
LOG.warn(msg);
return new BlockToMarkCorrupt(storedBlock,msg);
}
}
