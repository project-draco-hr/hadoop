{
  final boolean isEnabled=conf.getBoolean(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY,DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);
  LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + "=" + isEnabled);
  if (!isEnabled) {
    if (UserGroupInformation.isSecurityEnabled()) {
      LOG.error("Security is enabled but block access tokens " + "(via " + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + ") "+ "aren't enabled. This may cause issues "+ "when clients attempt to talk to a DataNode.");
    }
    return null;
  }
  final long updateMin=conf.getLong(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY,DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);
  final long lifetimeMin=conf.getLong(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY,DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);
  final String encryptionAlgorithm=conf.get(DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);
  LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY + "=" + updateMin+ " min(s), "+ DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY+ "="+ lifetimeMin+ " min(s), "+ DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY+ "="+ encryptionAlgorithm);
  String nsId=DFSUtil.getNamenodeNameServiceId(conf);
  boolean isHaEnabled=HAUtil.isHAEnabled(conf,nsId);
  if (isHaEnabled) {
    String thisNnId=HAUtil.getNameNodeId(conf,nsId);
    String otherNnId=HAUtil.getNameNodeIdOfOtherNode(conf,nsId);
    return new BlockTokenSecretManager(updateMin * 60 * 1000L,lifetimeMin * 60 * 1000L,thisNnId.compareTo(otherNnId) < 0 ? 0 : 1,null,encryptionAlgorithm);
  }
 else {
    return new BlockTokenSecretManager(updateMin * 60 * 1000L,lifetimeMin * 60 * 1000L,0,null,encryptionAlgorithm);
  }
}
