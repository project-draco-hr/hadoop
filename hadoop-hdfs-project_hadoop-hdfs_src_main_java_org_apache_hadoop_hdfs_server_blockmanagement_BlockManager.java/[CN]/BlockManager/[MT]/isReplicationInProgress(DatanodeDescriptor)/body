{
  boolean status=false;
  boolean firstReplicationLog=true;
  int underReplicatedBlocks=0;
  int decommissionOnlyReplicas=0;
  int underReplicatedInOpenFiles=0;
  final Iterator<? extends Block> it=srcNode.getBlockIterator();
  while (it.hasNext()) {
    final Block block=it.next();
    BlockCollection bc=blocksMap.getBlockCollection(block);
    if (bc != null) {
      NumberReplicas num=countNodes(block);
      int curReplicas=num.liveReplicas();
      int curExpectedReplicas=getReplication(block);
      if (isNeededReplication(block,curExpectedReplicas,curReplicas)) {
        if (curExpectedReplicas > curReplicas) {
          if (bc.isUnderConstruction()) {
            if (block.equals(bc.getLastBlock()) && curReplicas > minReplication) {
              continue;
            }
            underReplicatedInOpenFiles++;
          }
          if (!status) {
            status=true;
            if (firstReplicationLog) {
              logBlockReplicationInfo(block,srcNode,num);
            }
            if (curReplicas >= defaultReplication) {
              status=false;
              firstReplicationLog=false;
            }
          }
          underReplicatedBlocks++;
          if ((curReplicas == 0) && (num.decommissionedReplicas() > 0)) {
            decommissionOnlyReplicas++;
          }
        }
        if (!neededReplications.contains(block) && pendingReplications.getNumReplicas(block) == 0 && namesystem.isPopulatingReplQueues()) {
          neededReplications.add(block,curReplicas,num.decommissionedReplicas(),curExpectedReplicas);
        }
      }
    }
  }
  if (!status && !srcNode.isAlive) {
    LOG.warn("srcNode " + srcNode + " is dead "+ "when decommission is in progress. Continue to mark "+ "it as decommission in progress. In that way, when it rejoins the "+ "cluster it can continue the decommission process.");
    status=true;
  }
  srcNode.decommissioningStatus.set(underReplicatedBlocks,decommissionOnlyReplicas,underReplicatedInOpenFiles);
  return status;
}
