{
  boolean status=false;
  boolean firstReplicationLog=true;
  int underReplicatedBlocks=0;
  int decommissionOnlyReplicas=0;
  int underReplicatedInOpenFiles=0;
  final Iterator<? extends Block> it=srcNode.getBlockIterator();
  while (it.hasNext()) {
    final Block block=it.next();
    BlockCollection bc=blocksMap.getBlockCollection(block);
    if (bc != null) {
      NumberReplicas num=countNodes(block);
      int curReplicas=num.liveReplicas();
      int curExpectedReplicas=getReplication(block);
      if (isNeededReplication(block,curExpectedReplicas,curReplicas)) {
        if (curExpectedReplicas > curReplicas) {
          if (bc.isUnderConstruction()) {
            if (block.equals(bc.getLastBlock()) && curReplicas > minReplication) {
              continue;
            }
            underReplicatedInOpenFiles++;
          }
          if (!status) {
            status=true;
            if (firstReplicationLog) {
              logBlockReplicationInfo(block,srcNode,num);
            }
            if (curReplicas >= defaultReplication) {
              status=false;
              firstReplicationLog=false;
            }
          }
          underReplicatedBlocks++;
          if ((curReplicas == 0) && (num.decommissionedReplicas() > 0)) {
            decommissionOnlyReplicas++;
          }
        }
        if (!neededReplications.contains(block) && pendingReplications.getNumReplicas(block) == 0 && namesystem.isPopulatingReplQueues()) {
          neededReplications.add(block,curReplicas,num.decommissionedReplicas(),curExpectedReplicas);
        }
      }
    }
  }
  if (!status && !srcNode.isAlive) {
    updateState();
    if (pendingReplicationBlocksCount == 0 && underReplicatedBlocksCount == 0) {
      LOG.info("srcNode {} is dead and there are no under-replicated" + " blocks or blocks pending replication. Marking as " + "decommissioned.");
    }
 else {
      LOG.warn("srcNode " + srcNode + " is dead "+ "while decommission is in progress. Continuing to mark "+ "it as decommission in progress so when it rejoins the "+ "cluster it can continue the decommission process.");
      status=true;
    }
  }
  srcNode.decommissioningStatus.set(underReplicatedBlocks,decommissionOnlyReplicas,underReplicatedInOpenFiles);
  return status;
}
