{
  Collection<BlockInfo> toAdd=new LinkedList<BlockInfo>();
  Collection<Block> toRemove=new TreeSet<Block>();
  Collection<Block> toInvalidate=new LinkedList<Block>();
  Collection<BlockToMarkCorrupt> toCorrupt=new LinkedList<BlockToMarkCorrupt>();
  Collection<StatefulBlockInfo> toUC=new LinkedList<StatefulBlockInfo>();
  reportDiff(storageInfo,report,toAdd,toRemove,toInvalidate,toCorrupt,toUC);
  DatanodeDescriptor node=storageInfo.getDatanodeDescriptor();
  for (  StatefulBlockInfo b : toUC) {
    addStoredBlockUnderConstruction(b,storageInfo);
  }
  for (  Block b : toRemove) {
    removeStoredBlock(b,node);
  }
  int numBlocksLogged=0;
  for (  BlockInfo b : toAdd) {
    addStoredBlock(b,storageInfo,null,numBlocksLogged < maxNumBlocksToLog);
    numBlocksLogged++;
  }
  if (numBlocksLogged > maxNumBlocksToLog) {
    blockLog.info("BLOCK* processReport: logged info for " + maxNumBlocksToLog + " of "+ numBlocksLogged+ " reported.");
  }
  for (  Block b : toInvalidate) {
    blockLog.info("BLOCK* processReport: " + b + " on "+ node+ " size "+ b.getNumBytes()+ " does not belong to any file");
    addToInvalidates(b,node);
  }
  for (  BlockToMarkCorrupt b : toCorrupt) {
    markBlockAsCorrupt(b,storageInfo,node);
  }
}
