{
  containingNodes.clear();
  nodesContainingLiveReplicas.clear();
  LinkedList<DatanodeDescriptor> srcNodes=new LinkedList<>();
  int live=0;
  int decommissioned=0;
  int decommissioning=0;
  int corrupt=0;
  int excess=0;
  missingBlockIndices.clear();
  Set<Short> healthyIndices=new HashSet<>();
  Collection<DatanodeDescriptor> nodesCorrupt=corruptReplicas.getNodes(block);
  for (  DatanodeStorageInfo storage : blocksMap.getStorages(block)) {
    if (block.isStriped()) {
      healthyIndices.add((short)((BlockInfoStriped)block).getStorageBlockIndex(storage));
    }
    final DatanodeDescriptor node=storage.getDatanodeDescriptor();
    LightWeightLinkedSet<Block> excessBlocks=excessReplicateMap.get(node.getDatanodeUuid());
    int countableReplica=storage.getState() == State.NORMAL ? 1 : 0;
    if ((nodesCorrupt != null) && (nodesCorrupt.contains(node)))     corrupt+=countableReplica;
 else     if (node.isDecommissionInProgress()) {
      decommissioning+=countableReplica;
    }
 else     if (node.isDecommissioned()) {
      decommissioned+=countableReplica;
    }
 else     if (excessBlocks != null && excessBlocks.contains(block)) {
      excess+=countableReplica;
    }
 else {
      nodesContainingLiveReplicas.add(storage);
      live+=countableReplica;
    }
    containingNodes.add(node);
    if ((nodesCorrupt != null) && nodesCorrupt.contains(node))     continue;
    if (priority != UnderReplicatedBlocks.QUEUE_HIGHEST_PRIORITY && !node.isDecommissionInProgress() && node.getNumberOfBlocksToBeReplicated() >= maxReplicationStreams) {
      continue;
    }
    if (node.getNumberOfBlocksToBeReplicated() >= replicationStreamsHardLimit) {
      continue;
    }
    if (excessBlocks != null && excessBlocks.contains(block))     continue;
    if (node.isDecommissioned())     continue;
    if (srcNodes.size() < numSourceNodes) {
      srcNodes.add(node);
      continue;
    }
    if (ThreadLocalRandom.current().nextBoolean()) {
      int pos=ThreadLocalRandom.current().nextInt(numSourceNodes);
      if (!srcNodes.get(pos).isDecommissionInProgress()) {
        srcNodes.set(pos,node);
      }
    }
  }
  if (block.isStriped()) {
    for (short i=0; i < HdfsConstants.NUM_DATA_BLOCKS + HdfsConstants.NUM_PARITY_BLOCKS; i++) {
      if (!healthyIndices.contains(i)) {
        missingBlockIndices.add(i);
      }
    }
  }
  if (numReplicas != null)   numReplicas.initialize(live,decommissioned,decommissioning,corrupt,excess,0);
  return srcNodes.toArray(new DatanodeDescriptor[srcNodes.size()]);
}
