{
  BlockInfo block=rw.getBlock();
  int priority=rw.getPriority();
  if (block.isDeleted() || !block.isCompleteOrCommitted()) {
    neededReconstruction.remove(block,priority);
    rw.resetTargets();
    return false;
  }
  final short requiredRedundancy=getExpectedRedundancyNum(block);
  NumberReplicas numReplicas=countNodes(block);
  final int pendingNum=pendingReconstruction.getNumReplicas(block);
  if (hasEnoughEffectiveReplicas(block,numReplicas,pendingNum,requiredRedundancy)) {
    neededReconstruction.remove(block,priority);
    rw.resetTargets();
    blockLog.debug("BLOCK* Removing {} from neededReplications as" + " it has enough replicas",block);
    return false;
  }
  DatanodeStorageInfo[] targets=rw.getTargets();
  if ((numReplicas.liveReplicas() >= requiredRedundancy) && (!isPlacementPolicySatisfied(block))) {
    if (!isInNewRack(rw.getSrcNodes(),targets[0].getDatanodeDescriptor())) {
      return false;
    }
    rw.setNotEnoughRack();
  }
  rw.addTaskToDatanode(numReplicas);
  DatanodeStorageInfo.incrementBlocksScheduled(targets);
  pendingReconstruction.increment(block,DatanodeStorageInfo.toDatanodeDescriptors(targets));
  blockLog.debug("BLOCK* block {} is moved from neededReplications to " + "pendingReplications",block);
  int numEffectiveReplicas=numReplicas.liveReplicas() + pendingNum;
  if (numEffectiveReplicas + targets.length >= requiredRedundancy) {
    neededReconstruction.remove(block,priority);
  }
  return true;
}
