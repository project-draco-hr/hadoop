{
  containingNodes.clear();
  nodesContainingLiveReplicas.clear();
  List<DatanodeDescriptor> srcNodes=new ArrayList<>();
  liveBlockIndices.clear();
  final boolean isStriped=block.isStriped();
  BitSet bitSet=isStriped ? new BitSet(((BlockInfoStriped)block).getTotalBlockNum()) : null;
  for (  DatanodeStorageInfo storage : blocksMap.getStorages(block)) {
    final DatanodeDescriptor node=storage.getDatanodeDescriptor();
    final StoredReplicaState state=checkReplicaOnStorage(numReplicas,block,storage,corruptReplicas.getNodes(block),false);
    if (state == StoredReplicaState.LIVE) {
      nodesContainingLiveReplicas.add(storage);
    }
    containingNodes.add(node);
    if (state == StoredReplicaState.CORRUPT || state == StoredReplicaState.EXCESS) {
      continue;
    }
    if (priority != UnderReplicatedBlocks.QUEUE_HIGHEST_PRIORITY && !node.isDecommissionInProgress() && node.getNumberOfBlocksToBeReplicated() >= maxReplicationStreams) {
      continue;
    }
    if (node.getNumberOfBlocksToBeReplicated() >= replicationStreamsHardLimit) {
      continue;
    }
    if (node.isDecommissioned()) {
      continue;
    }
    if (isStriped || srcNodes.isEmpty()) {
      srcNodes.add(node);
      if (isStriped) {
        byte blockIndex=((BlockInfoStriped)block).getStorageBlockIndex(storage);
        liveBlockIndices.add(blockIndex);
        if (!bitSet.get(blockIndex)) {
          bitSet.set(blockIndex);
        }
 else         if (state == StoredReplicaState.LIVE) {
          numReplicas.subtract(StoredReplicaState.LIVE,1);
          numReplicas.add(StoredReplicaState.REDUNDANT,1);
        }
      }
      continue;
    }
    if (ThreadLocalRandom.current().nextBoolean()) {
      srcNodes.set(0,node);
    }
  }
  return srcNodes.toArray(new DatanodeDescriptor[srcNodes.size()]);
}
