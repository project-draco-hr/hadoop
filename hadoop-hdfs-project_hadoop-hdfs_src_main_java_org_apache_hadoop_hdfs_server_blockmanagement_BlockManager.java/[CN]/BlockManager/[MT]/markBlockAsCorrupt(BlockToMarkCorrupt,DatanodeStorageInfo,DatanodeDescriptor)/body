{
  if (b.getCorrupted().isDeleted()) {
    blockLog.debug("BLOCK markBlockAsCorrupt: {} cannot be marked as" + " corrupt as it does not belong to any file",b);
    addToInvalidates(b.getCorrupted(),node);
    return;
  }
  short expectedReplicas=b.getCorrupted().getReplication();
  if (storageInfo != null) {
    storageInfo.addBlock(b.getStored());
  }
  corruptReplicas.addToCorruptReplicasMap(b.getCorrupted(),node,b.getReason(),b.getReasonCode());
  NumberReplicas numberOfReplicas=countNodes(b.getStored());
  boolean hasEnoughLiveReplicas=numberOfReplicas.liveReplicas() >= expectedReplicas;
  boolean minReplicationSatisfied=numberOfReplicas.liveReplicas() >= minReplication;
  boolean hasMoreCorruptReplicas=minReplicationSatisfied && (numberOfReplicas.liveReplicas() + numberOfReplicas.corruptReplicas()) > expectedReplicas;
  boolean corruptedDuringWrite=minReplicationSatisfied && b.isCorruptedDuringWrite();
  if (hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite) {
    invalidateBlock(b,node);
  }
 else   if (namesystem.isPopulatingReplQueues()) {
    updateNeededReplications(b.getStored(),-1,0);
  }
}
