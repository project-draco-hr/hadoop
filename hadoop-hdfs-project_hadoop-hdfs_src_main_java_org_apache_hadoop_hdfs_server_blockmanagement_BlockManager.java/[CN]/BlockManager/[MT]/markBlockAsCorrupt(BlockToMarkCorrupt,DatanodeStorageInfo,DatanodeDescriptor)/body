{
  BlockCollection bc=b.corrupted.getBlockCollection();
  if (bc == null) {
    blockLog.info("BLOCK markBlockAsCorrupt: {} cannot be marked as" + " corrupt as it does not belong to any file",b);
    addToInvalidates(b.corrupted,node);
    return;
  }
  if (storageInfo != null) {
    storageInfo.addBlock(b.stored);
  }
  corruptReplicas.addToCorruptReplicasMap(b.corrupted,node,b.reason,b.reasonCode);
  NumberReplicas numberOfReplicas=countNodes(b.stored);
  boolean hasEnoughLiveReplicas=numberOfReplicas.liveReplicas() >= bc.getBlockReplication();
  boolean minReplicationSatisfied=numberOfReplicas.liveReplicas() >= minReplication;
  boolean hasMoreCorruptReplicas=minReplicationSatisfied && (numberOfReplicas.liveReplicas() + numberOfReplicas.corruptReplicas()) > bc.getBlockReplication();
  boolean corruptedDuringWrite=minReplicationSatisfied && (b.stored.getGenerationStamp() > b.corrupted.getGenerationStamp());
  if (hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite) {
    invalidateBlock(b,node);
  }
 else   if (namesystem.isPopulatingReplQueues()) {
    updateNeededReplications(b.stored,-1,0);
  }
}
