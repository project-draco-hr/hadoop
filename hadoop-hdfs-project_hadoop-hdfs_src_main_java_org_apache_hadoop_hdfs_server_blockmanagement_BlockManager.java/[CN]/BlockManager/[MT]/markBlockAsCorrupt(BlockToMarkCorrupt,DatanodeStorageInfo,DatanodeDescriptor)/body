{
  if (b.stored.isDeleted()) {
    blockLog.info("BLOCK markBlockAsCorrupt: {} cannot be marked as" + " corrupt as it does not belong to any file",b);
    addToInvalidates(b.corrupted,node);
    return;
  }
  short expectedReplicas=getExpectedReplicaNum(b.stored.getBlockCollection(),b.stored);
  if (storageInfo != null) {
    storageInfo.addBlock(b.stored,b.corrupted);
  }
  Block corrupted=new Block(b.corrupted);
  if (b.stored.isStriped()) {
    corrupted.setBlockId(b.stored.getBlockId());
  }
  corruptReplicas.addToCorruptReplicasMap(corrupted,node,b.reason,b.reasonCode);
  NumberReplicas numberOfReplicas=countNodes(b.stored);
  boolean hasEnoughLiveReplicas=numberOfReplicas.liveReplicas() >= expectedReplicas;
  boolean minReplicationSatisfied=hasMinStorage(b.stored,numberOfReplicas.liveReplicas());
  boolean hasMoreCorruptReplicas=minReplicationSatisfied && (numberOfReplicas.liveReplicas() + numberOfReplicas.corruptReplicas()) > expectedReplicas;
  boolean corruptedDuringWrite=minReplicationSatisfied && (b.stored.getGenerationStamp() > b.corrupted.getGenerationStamp());
  if (hasEnoughLiveReplicas || hasMoreCorruptReplicas || corruptedDuringWrite) {
    invalidateBlock(b,node,numberOfReplicas);
  }
 else   if (namesystem.isPopulatingReplQueues()) {
    updateNeededReplications(b.stored,-1,0);
  }
}
