{
  LOG.info("Starting ApplicationMaster");
  resourceManager=new AMRMClientImpl(appAttemptID);
  resourceManager.init(conf);
  resourceManager.start();
  try {
    RegisterApplicationMasterResponse response=resourceManager.registerApplicationMaster(appMasterHostname,appMasterRpcPort,appMasterTrackingUrl);
    int minMem=response.getMinimumResourceCapability().getMemory();
    int maxMem=response.getMaximumResourceCapability().getMemory();
    LOG.info("Min mem capabililty of resources in this cluster " + minMem);
    LOG.info("Max mem capabililty of resources in this cluster " + maxMem);
    if (containerMemory < minMem) {
      LOG.info("Container memory specified below min threshold of cluster." + " Using min value." + ", specified=" + containerMemory + ", min="+ minMem);
      containerMemory=minMem;
    }
 else     if (containerMemory > maxMem) {
      LOG.info("Container memory specified above max threshold of cluster." + " Using max value." + ", specified=" + containerMemory + ", max="+ maxMem);
      containerMemory=maxMem;
    }
    int loopCounter=-1;
    while (numCompletedContainers.get() < numTotalContainers && !appDone) {
      loopCounter++;
      LOG.info("Current application state: loop=" + loopCounter + ", appDone="+ appDone+ ", total="+ numTotalContainers+ ", requested="+ numRequestedContainers+ ", completed="+ numCompletedContainers+ ", failed="+ numFailedContainers+ ", currentAllocated="+ numAllocatedContainers);
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
        LOG.info("Sleep interrupted " + e.getMessage());
      }
      int askCount=numTotalContainers - numRequestedContainers.get();
      numRequestedContainers.addAndGet(askCount);
      if (askCount > 0) {
        ContainerRequest containerAsk=setupContainerAskForRM(askCount);
        resourceManager.addContainerRequest(containerAsk);
      }
      LOG.info("Asking RM for containers" + ", askCount=" + askCount);
      AMResponse amResp=sendContainerAskToRM();
      List<Container> allocatedContainers=amResp.getAllocatedContainers();
      LOG.info("Got response from RM for container ask, allocatedCnt=" + allocatedContainers.size());
      numAllocatedContainers.addAndGet(allocatedContainers.size());
      for (      Container allocatedContainer : allocatedContainers) {
        LOG.info("Launching shell command on a new container." + ", containerId=" + allocatedContainer.getId() + ", containerNode="+ allocatedContainer.getNodeId().getHost()+ ":"+ allocatedContainer.getNodeId().getPort()+ ", containerNodeURI="+ allocatedContainer.getNodeHttpAddress()+ ", containerState"+ allocatedContainer.getState()+ ", containerResourceMemory"+ allocatedContainer.getResource().getMemory());
        LaunchContainerRunnable runnableLaunchContainer=new LaunchContainerRunnable(allocatedContainer);
        Thread launchThread=new Thread(runnableLaunchContainer);
        launchThreads.add(launchThread);
        launchThread.start();
      }
      Resource availableResources=amResp.getAvailableResources();
      LOG.info("Current available resources in the cluster " + availableResources);
      List<ContainerStatus> completedContainers=amResp.getCompletedContainersStatuses();
      LOG.info("Got response from RM for container ask, completedCnt=" + completedContainers.size());
      for (      ContainerStatus containerStatus : completedContainers) {
        LOG.info("Got container status for containerID=" + containerStatus.getContainerId() + ", state="+ containerStatus.getState()+ ", exitStatus="+ containerStatus.getExitStatus()+ ", diagnostics="+ containerStatus.getDiagnostics());
        assert(containerStatus.getState() == ContainerState.COMPLETE);
        int exitStatus=containerStatus.getExitStatus();
        if (0 != exitStatus) {
          if (-100 != exitStatus) {
            numCompletedContainers.incrementAndGet();
            numFailedContainers.incrementAndGet();
          }
 else {
            numAllocatedContainers.decrementAndGet();
            numRequestedContainers.decrementAndGet();
          }
        }
 else {
          numCompletedContainers.incrementAndGet();
          LOG.info("Container completed successfully." + ", containerId=" + containerStatus.getContainerId());
        }
      }
      if (numCompletedContainers.get() == numTotalContainers) {
        appDone=true;
      }
      LOG.info("Current application state: loop=" + loopCounter + ", appDone="+ appDone+ ", total="+ numTotalContainers+ ", requested="+ numRequestedContainers+ ", completed="+ numCompletedContainers+ ", failed="+ numFailedContainers+ ", currentAllocated="+ numAllocatedContainers);
    }
    for (    Thread launchThread : launchThreads) {
      try {
        launchThread.join(10000);
      }
 catch (      InterruptedException e) {
        LOG.info("Exception thrown in thread join: " + e.getMessage());
        e.printStackTrace();
      }
    }
    LOG.info("Application completed. Signalling finish to RM");
    FinalApplicationStatus appStatus;
    String appMessage=null;
    boolean isSuccess=true;
    if (numFailedContainers.get() == 0) {
      appStatus=FinalApplicationStatus.SUCCEEDED;
    }
 else {
      appStatus=FinalApplicationStatus.FAILED;
      appMessage="Diagnostics." + ", total=" + numTotalContainers + ", completed="+ numCompletedContainers.get()+ ", allocated="+ numAllocatedContainers.get()+ ", failed="+ numFailedContainers.get();
      isSuccess=false;
    }
    resourceManager.unregisterApplicationMaster(appStatus,appMessage,null);
    return isSuccess;
  }
  finally {
    resourceManager.stop();
  }
}
