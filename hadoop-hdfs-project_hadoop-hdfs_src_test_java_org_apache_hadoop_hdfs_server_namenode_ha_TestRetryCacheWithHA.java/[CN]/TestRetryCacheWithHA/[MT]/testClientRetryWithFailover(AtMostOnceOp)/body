{
  final Map<String,Object> results=new HashMap<String,Object>();
  op.prepare();
  DummyRetryInvocationHandler.block.set(true);
  new Thread(){
    @Override public void run(){
      try {
        op.invoke();
        Object result=op.getResult();
        LOG.info("Operation " + op.name + " finished");
synchronized (TestRetryCacheWithHA.this) {
          results.put(op.name,result == null ? "SUCCESS" : result);
          TestRetryCacheWithHA.this.notifyAll();
        }
      }
 catch (      Exception e) {
        LOG.info("Got Exception while calling " + op.name,e);
      }
 finally {
        IOUtils.cleanup(null,op.client);
      }
    }
  }
.start();
  assertTrue("After waiting the operation " + op.name + " still has not taken effect on NN yet",op.checkNamenodeBeforeReturn());
  cluster.transitionToStandby(0);
  cluster.transitionToActive(1);
  LOG.info("Setting block to false");
  DummyRetryInvocationHandler.block.set(false);
synchronized (this) {
    while (!results.containsKey(op.name)) {
      this.wait();
    }
    LOG.info("Got the result of " + op.name + ": "+ results.get(op.name));
  }
  while (cluster.getNamesystem(1).isInStandbyState()) {
    Thread.sleep(10);
  }
  long hitNN0=cluster.getNamesystem(0).getRetryCache().getMetricsForTests().getCacheHit();
  long hitNN1=cluster.getNamesystem(1).getRetryCache().getMetricsForTests().getCacheHit();
  assertTrue("CacheHit: " + hitNN0 + ", "+ hitNN1,hitNN0 + hitNN1 > 0);
  long updatedNN0=cluster.getNamesystem(0).getRetryCache().getMetricsForTests().getCacheUpdated();
  long updatedNN1=cluster.getNamesystem(1).getRetryCache().getMetricsForTests().getCacheUpdated();
  assertTrue("CacheUpdated on NN0: " + updatedNN0,updatedNN0 > 0);
  assertTrue("CacheUpdated on NN1: " + updatedNN1,updatedNN1 > 0);
}
