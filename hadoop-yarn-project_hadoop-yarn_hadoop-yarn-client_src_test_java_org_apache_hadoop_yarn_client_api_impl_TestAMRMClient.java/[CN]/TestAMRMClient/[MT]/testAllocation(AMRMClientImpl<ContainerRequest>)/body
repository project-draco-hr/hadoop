{
  assertEquals(0,amClient.ask.size());
  assertEquals(0,amClient.release.size());
  amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  assertNumContainers(amClient,0,2,2,2,3,0);
  int containersRequestedAny=2;
  int allocatedContainerCount=0;
  int iterationsLeft=3;
  Set<ContainerId> releases=new TreeSet<ContainerId>();
  amClient.getNMTokenCache().clearCache();
  Assert.assertEquals(0,amClient.getNMTokenCache().numberOfTokensInCache());
  HashMap<String,Token> receivedNMTokens=new HashMap<String,Token>();
  while (allocatedContainerCount < containersRequestedAny && iterationsLeft-- > 0) {
    AllocateResponse allocResponse=amClient.allocate(0.1f);
    assertEquals(0,amClient.ask.size());
    assertEquals(0,amClient.release.size());
    assertEquals(nodeCount,amClient.getClusterNodeCount());
    allocatedContainerCount+=allocResponse.getAllocatedContainers().size();
    for (    Container container : allocResponse.getAllocatedContainers()) {
      ContainerId rejectContainerId=container.getId();
      releases.add(rejectContainerId);
      amClient.releaseAssignedContainer(rejectContainerId);
    }
    for (    NMToken token : allocResponse.getNMTokens()) {
      String nodeID=token.getNodeId().toString();
      if (receivedNMTokens.containsKey(nodeID)) {
        Assert.fail("Received token again for : " + nodeID);
      }
      receivedNMTokens.put(nodeID,token.getToken());
    }
    if (allocatedContainerCount < containersRequestedAny) {
      sleep(100);
    }
  }
  Assert.assertTrue(receivedNMTokens.size() > 0 && receivedNMTokens.size() <= nodeCount);
  assertEquals(allocatedContainerCount,containersRequestedAny);
  assertEquals(2,amClient.release.size());
  assertEquals(0,amClient.ask.size());
  amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  assertEquals(3,amClient.ask.size());
  ResourceRequest snoopRequest=amClient.ask.iterator().next();
  assertEquals(0,snoopRequest.getNumContainers());
  amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  snoopRequest=amClient.ask.iterator().next();
  assertEquals(2,snoopRequest.getNumContainers());
  ApplicationMasterProtocol realRM=amClient.rmClient;
  try {
    ApplicationMasterProtocol mockRM=mock(ApplicationMasterProtocol.class);
    when(mockRM.allocate(any(AllocateRequest.class))).thenAnswer(new Answer<AllocateResponse>(){
      public AllocateResponse answer(      InvocationOnMock invocation) throws Exception {
        amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
        amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
        throw new Exception();
      }
    }
);
    amClient.rmClient=mockRM;
    amClient.allocate(0.1f);
  }
 catch (  Exception ioe) {
  }
 finally {
    amClient.rmClient=realRM;
  }
  assertEquals(2,amClient.release.size());
  assertEquals(3,amClient.ask.size());
  snoopRequest=amClient.ask.iterator().next();
  assertEquals(0,snoopRequest.getNumContainers());
  waitForContainerCompletion(3,amClient,releases);
}
