{
  assertTrue(amClient.ask.size() == 0);
  assertTrue(amClient.release.size() == 0);
  amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  int containersRequestedNode=amClient.remoteRequestsTable.get(priority).get(node).get(capability).remoteRequest.getNumContainers();
  int containersRequestedRack=amClient.remoteRequestsTable.get(priority).get(rack).get(capability).remoteRequest.getNumContainers();
  int containersRequestedAny=amClient.remoteRequestsTable.get(priority).get(ResourceRequest.ANY).get(capability).remoteRequest.getNumContainers();
  assertTrue(containersRequestedNode == 2);
  assertTrue(containersRequestedRack == 2);
  assertTrue(containersRequestedAny == 2);
  assertTrue(amClient.ask.size() == 3);
  assertTrue(amClient.release.size() == 0);
  int allocatedContainerCount=0;
  int iterationsLeft=3;
  Set<ContainerId> releases=new TreeSet<ContainerId>();
  NMTokenCache.clearCache();
  Assert.assertEquals(0,NMTokenCache.numberOfNMTokensInCache());
  HashMap<String,Token> receivedNMTokens=new HashMap<String,Token>();
  while (allocatedContainerCount < containersRequestedAny && iterationsLeft-- > 0) {
    AllocateResponse allocResponse=amClient.allocate(0.1f);
    assertTrue(amClient.ask.size() == 0);
    assertTrue(amClient.release.size() == 0);
    assertTrue(nodeCount == amClient.getClusterNodeCount());
    allocatedContainerCount+=allocResponse.getAllocatedContainers().size();
    for (    Container container : allocResponse.getAllocatedContainers()) {
      ContainerId rejectContainerId=container.getId();
      releases.add(rejectContainerId);
      amClient.releaseAssignedContainer(rejectContainerId);
    }
    for (    NMToken token : allocResponse.getNMTokens()) {
      String nodeID=token.getNodeId().toString();
      if (receivedNMTokens.containsKey(nodeID)) {
        Assert.fail("Received token again for : " + nodeID);
      }
      receivedNMTokens.put(nodeID,token.getToken());
    }
    if (allocatedContainerCount < containersRequestedAny) {
      sleep(100);
    }
  }
  Assert.assertTrue(receivedNMTokens.size() > 0 && receivedNMTokens.size() <= nodeCount);
  assertTrue(allocatedContainerCount == containersRequestedAny);
  assertTrue(amClient.release.size() == 2);
  assertTrue(amClient.ask.size() == 0);
  amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  assertTrue(amClient.ask.size() == 3);
  ResourceRequest snoopRequest=amClient.ask.iterator().next();
  assertTrue(snoopRequest.getNumContainers() == 0);
  amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
  snoopRequest=amClient.ask.iterator().next();
  assertTrue(snoopRequest.getNumContainers() == 2);
  ApplicationMasterProtocol realRM=amClient.rmClient;
  try {
    ApplicationMasterProtocol mockRM=mock(ApplicationMasterProtocol.class);
    when(mockRM.allocate(any(AllocateRequest.class))).thenAnswer(new Answer<AllocateResponse>(){
      public AllocateResponse answer(      InvocationOnMock invocation) throws Exception {
        amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
        amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
        throw new Exception();
      }
    }
);
    amClient.rmClient=mockRM;
    amClient.allocate(0.1f);
  }
 catch (  Exception ioe) {
  }
 finally {
    amClient.rmClient=realRM;
  }
  assertTrue(amClient.release.size() == 2);
  assertTrue(amClient.ask.size() == 3);
  snoopRequest=amClient.ask.iterator().next();
  assertTrue(snoopRequest.getNumContainers() == 0);
  iterationsLeft=3;
  while (!releases.isEmpty() || iterationsLeft-- > 0) {
    AllocateResponse allocResponse=amClient.allocate(0.1f);
    assertTrue(allocResponse.getAllocatedContainers().size() == 0);
    if (allocResponse.getCompletedContainersStatuses().size() > 0) {
      for (      ContainerStatus cStatus : allocResponse.getCompletedContainersStatuses()) {
        if (releases.contains(cStatus.getContainerId())) {
          assertTrue(cStatus.getState() == ContainerState.COMPLETE);
          assertTrue(cStatus.getExitStatus() == -100);
          releases.remove(cStatus.getContainerId());
        }
      }
    }
    if (iterationsLeft > 0) {
      sleep(100);
    }
  }
  assertTrue(amClient.ask.size() == 0);
  assertTrue(amClient.release.size() == 0);
}
