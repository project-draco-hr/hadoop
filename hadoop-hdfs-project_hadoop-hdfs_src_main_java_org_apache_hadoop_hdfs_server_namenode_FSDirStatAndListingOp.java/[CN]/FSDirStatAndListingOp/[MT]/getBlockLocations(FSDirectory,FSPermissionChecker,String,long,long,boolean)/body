{
  Preconditions.checkArgument(offset >= 0,"Negative offset is not supported. File: " + src);
  Preconditions.checkArgument(length >= 0,"Negative length is not supported. File: " + src);
  CacheManager cm=fsd.getFSNamesystem().getCacheManager();
  BlockManager bm=fsd.getBlockManager();
  byte[][] pathComponents=FSDirectory.getPathComponentsForReservedPath(src);
  boolean isReservedName=FSDirectory.isReservedRawName(src);
  fsd.readLock();
  try {
    src=fsd.resolvePath(pc,src,pathComponents);
    final INodesInPath iip=fsd.getINodesInPath(src,true);
    final INodeFile inode=INodeFile.valueOf(iip.getLastINode(),src);
    if (fsd.isPermissionEnabled()) {
      fsd.checkPathAccess(pc,iip,FsAction.READ);
      fsd.checkUnreadableBySuperuser(pc,inode,iip.getPathSnapshotId());
    }
    final long fileSize=iip.isSnapshot() ? inode.computeFileSize(iip.getPathSnapshotId()) : inode.computeFileSizeNotIncludingLastUcBlock();
    boolean isUc=inode.isUnderConstruction();
    if (iip.isSnapshot()) {
      length=Math.min(length,fileSize - offset);
      isUc=false;
    }
    final FileEncryptionInfo feInfo=isReservedName ? null : fsd.getFileEncryptionInfo(inode,iip.getPathSnapshotId(),iip);
    final ErasureCodingPolicy ecPolicy=FSDirErasureCodingOp.getErasureCodingPolicy(fsd.getFSNamesystem(),iip);
    final LocatedBlocks blocks=bm.createLocatedBlocks(inode.getBlocks(iip.getPathSnapshotId()),fileSize,isUc,offset,length,needBlockToken,iip.isSnapshot(),feInfo,ecPolicy);
    for (    LocatedBlock lb : blocks.getLocatedBlocks()) {
      cm.setCachedLocations(lb);
    }
    final long now=now();
    boolean updateAccessTime=fsd.isAccessTimeSupported() && !iip.isSnapshot() && now > inode.getAccessTime() + fsd.getAccessTimePrecision();
    return new GetBlockLocationsResult(updateAccessTime,blocks);
  }
  finally {
    fsd.readUnlock();
  }
}
