{
  byte[][] pathComponents=FSDirectory.getPathComponentsForReservedPath(srcArg);
  final String startAfterString=new String(startAfter,StandardCharsets.UTF_8);
  String src=null;
  if (fsd.isPermissionEnabled()) {
    FSPermissionChecker pc=fsd.getPermissionChecker();
    src=fsd.resolvePath(pc,srcArg,pathComponents);
  }
 else {
    src=FSDirectory.resolvePath(srcArg,pathComponents,fsd);
  }
  if (FSDirectory.isReservedName(startAfterString)) {
    byte[][] startAfterComponents=FSDirectory.getPathComponentsForReservedPath(startAfterString);
    try {
      String tmp=FSDirectory.resolvePath(src,startAfterComponents,fsd);
      byte[][] regularPath=INode.getPathComponents(tmp);
      startAfter=regularPath[regularPath.length - 1];
    }
 catch (    IOException e) {
      throw new DirectoryListingStartAfterNotFoundException("Can't find startAfter " + startAfterString);
    }
  }
  final INodesInPath iip=fsd.getINodesInPath(src,true);
  boolean isSuperUser=true;
  if (fsd.isPermissionEnabled()) {
    FSPermissionChecker pc=fsd.getPermissionChecker();
    if (iip.getLastINode() != null && iip.getLastINode().isDirectory()) {
      fsd.checkPathAccess(pc,iip,FsAction.READ_EXECUTE);
    }
 else {
      fsd.checkTraverse(pc,iip);
    }
    isSuperUser=pc.isSuperUser();
  }
  return getListing(fsd,iip,src,startAfter,needLocation,isSuperUser);
}
