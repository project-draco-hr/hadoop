{
  Preconditions.checkState(fsd.hasReadLock());
  Preconditions.checkArgument(src.endsWith(HdfsConstants.SEPARATOR_DOT_SNAPSHOT_DIR),"%s does not end with %s",src,HdfsConstants.SEPARATOR_DOT_SNAPSHOT_DIR);
  final String dirPath=FSDirectory.normalizePath(src.substring(0,src.length() - HdfsConstants.DOT_SNAPSHOT_DIR.length()));
  final INode node=fsd.getINode(dirPath);
  final INodeDirectory dirNode=INodeDirectory.valueOf(node,dirPath);
  final DirectorySnapshottableFeature sf=dirNode.getDirectorySnapshottableFeature();
  if (sf == null) {
    throw new SnapshotException("Directory is not a snapshottable directory: " + dirPath);
  }
  final ReadOnlyList<Snapshot> snapshots=sf.getSnapshotList();
  int skipSize=ReadOnlyList.Util.binarySearch(snapshots,startAfter);
  skipSize=skipSize < 0 ? -skipSize - 1 : skipSize + 1;
  int numOfListing=Math.min(snapshots.size() - skipSize,fsd.getLsLimit());
  final HdfsFileStatus listing[]=new HdfsFileStatus[numOfListing];
  for (int i=0; i < numOfListing; i++) {
    Snapshot.Root sRoot=snapshots.get(i + skipSize).getRoot();
    listing[i]=createFileStatus(fsd,src,sRoot.getLocalNameBytes(),sRoot,HdfsConstantsClient.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED,Snapshot.CURRENT_STATE_ID,false,INodesInPath.fromINode(sRoot));
  }
  return new DirectoryListing(listing,snapshots.size() - skipSize - numOfListing);
}
