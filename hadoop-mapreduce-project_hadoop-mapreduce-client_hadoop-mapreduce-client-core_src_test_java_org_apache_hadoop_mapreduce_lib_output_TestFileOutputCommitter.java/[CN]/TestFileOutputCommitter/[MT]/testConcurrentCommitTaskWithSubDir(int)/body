{
  final Job job=Job.getInstance();
  FileOutputFormat.setOutputPath(job,outDir);
  final Configuration conf=job.getConfiguration();
  conf.set(MRJobConfig.TASK_ATTEMPT_ID,attempt);
  conf.setInt(FileOutputCommitter.FILEOUTPUTCOMMITTER_ALGORITHM_VERSION,version);
  conf.setClass("fs.file.impl",RLFS.class,FileSystem.class);
  FileSystem.closeAll();
  final JobContext jContext=new JobContextImpl(conf,taskID.getJobID());
  final FileOutputCommitter amCommitter=new FileOutputCommitter(outDir,jContext);
  amCommitter.setupJob(jContext);
  final TaskAttemptContext[] taCtx=new TaskAttemptContextImpl[2];
  taCtx[0]=new TaskAttemptContextImpl(conf,taskID);
  taCtx[1]=new TaskAttemptContextImpl(conf,taskID1);
  final TextOutputFormat[] tof=new TextOutputFormat[2];
  for (int i=0; i < tof.length; i++) {
    tof[i]=new TextOutputFormat(){
      @Override public Path getDefaultWorkFile(      TaskAttemptContext context,      String extension) throws IOException {
        final FileOutputCommitter foc=(FileOutputCommitter)getOutputCommitter(context);
        return new Path(new Path(foc.getWorkPath(),SUB_DIR),getUniqueFile(context,getOutputName(context),extension));
      }
    }
;
  }
  final ExecutorService executor=HadoopExecutors.newFixedThreadPool(2);
  try {
    for (int i=0; i < taCtx.length; i++) {
      final int taskIdx=i;
      executor.submit(new Callable<Void>(){
        @Override public Void call() throws IOException, InterruptedException {
          final OutputCommitter outputCommitter=tof[taskIdx].getOutputCommitter(taCtx[taskIdx]);
          outputCommitter.setupTask(taCtx[taskIdx]);
          final RecordWriter rw=tof[taskIdx].getRecordWriter(taCtx[taskIdx]);
          writeOutput(rw,taCtx[taskIdx]);
          outputCommitter.commitTask(taCtx[taskIdx]);
          return null;
        }
      }
);
    }
  }
  finally {
    executor.shutdown();
    while (!executor.awaitTermination(1,TimeUnit.SECONDS)) {
      LOG.info("Awaiting thread termination!");
    }
  }
  amCommitter.commitJob(jContext);
  final RawLocalFileSystem lfs=new RawLocalFileSystem();
  lfs.setConf(conf);
  assertFalse("Must not end up with sub_dir/sub_dir",lfs.exists(new Path(OUT_SUB_DIR,SUB_DIR)));
  validateContent(OUT_SUB_DIR);
  FileUtil.fullyDelete(new File(outDir.toString()));
}
