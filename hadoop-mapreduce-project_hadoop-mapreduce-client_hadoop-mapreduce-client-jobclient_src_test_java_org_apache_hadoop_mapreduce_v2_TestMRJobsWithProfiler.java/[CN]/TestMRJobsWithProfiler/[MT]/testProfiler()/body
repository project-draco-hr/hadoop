{
  if (!(new File(MiniMRYarnCluster.APPJAR)).exists()) {
    LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
    return;
  }
  final SleepJob sleepJob=new SleepJob();
  final JobConf sleepConf=new JobConf(mrCluster.getConfig());
  sleepConf.setProfileEnabled(true);
  sleepConf.setProfileTaskRange(true,"1");
  sleepConf.setProfileTaskRange(false,"1");
  sleepConf.set(MRJobConfig.TASK_MAP_PROFILE_PARAMS,"-agentlib:hprof=cpu=times,heap=sites,force=n,thread=y,verbose=n," + "file=%s");
  sleepConf.set(MRJobConfig.TASK_REDUCE_PROFILE_PARAMS,"-Xprof");
  sleepJob.setConf(sleepConf);
  final Job job=sleepJob.createJob(2,2,500,1,500,1);
  job.setJarByClass(SleepJob.class);
  job.addFileToClassPath(APP_JAR);
  job.waitForCompletion(true);
  final JobId jobId=TypeConverter.toYarn(job.getJobID());
  final ApplicationId appID=jobId.getAppId();
  int pollElapsed=0;
  while (true) {
    Thread.sleep(1000);
    pollElapsed+=1000;
    if (TERMINAL_RM_APP_STATES.contains(mrCluster.getResourceManager().getRMContext().getRMApps().get(appID).getState())) {
      break;
    }
    if (pollElapsed >= 60000) {
      LOG.warn("application did not reach terminal state within 60 seconds");
      break;
    }
  }
  Assert.assertEquals(RMAppState.FINISHED,mrCluster.getResourceManager().getRMContext().getRMApps().get(appID).getState());
  final Configuration nmConf=mrCluster.getNodeManager(0).getConfig();
  final String appIdStr=appID.toString();
  final String appIdSuffix=appIdStr.substring("application_".length(),appIdStr.length());
  final String containerGlob="container_" + appIdSuffix + "_*_*";
  final Map<TaskAttemptID,Path> taLogDirs=new HashMap<TaskAttemptID,Path>();
  final Pattern taskPattern=Pattern.compile(".*Task:(attempt_" + appIdSuffix + "_[rm]_"+ "[0-9]+_[0-9]+).*");
  for (  String logDir : nmConf.getTrimmedStrings(YarnConfiguration.NM_LOG_DIRS)) {
    for (    FileStatus fileStatus : localFs.globStatus(new Path(logDir + Path.SEPARATOR + appIdStr+ Path.SEPARATOR+ containerGlob+ Path.SEPARATOR+ TaskLog.LogName.SYSLOG))) {
      final BufferedReader br=new BufferedReader(new InputStreamReader(localFs.open(fileStatus.getPath())));
      String line;
      while ((line=br.readLine()) != null) {
        final Matcher m=taskPattern.matcher(line);
        if (m.matches()) {
          taLogDirs.put(TaskAttemptID.forName(m.group(1)),fileStatus.getPath().getParent());
          break;
        }
      }
      br.close();
    }
  }
  Assert.assertEquals(4,taLogDirs.size());
  for (  Map.Entry<TaskAttemptID,Path> dirEntry : taLogDirs.entrySet()) {
    final TaskAttemptID tid=dirEntry.getKey();
    final Path profilePath=new Path(dirEntry.getValue(),TaskLog.LogName.PROFILE.toString());
    final Path stdoutPath=new Path(dirEntry.getValue(),TaskLog.LogName.STDOUT.toString());
    if (tid.getTaskType() == TaskType.MAP) {
      if (tid.getTaskID().getId() == 1) {
        final BufferedReader br=new BufferedReader(new InputStreamReader(localFs.open(profilePath)));
        final String line=br.readLine();
        Assert.assertTrue("No hprof content found!",line != null && line.startsWith("JAVA PROFILE"));
        br.close();
        Assert.assertEquals(0L,localFs.getFileStatus(stdoutPath).getLen());
      }
 else {
        Assert.assertFalse("hprof file should not exist",localFs.exists(profilePath));
      }
    }
 else {
      Assert.assertFalse("hprof file should not exist",localFs.exists(profilePath));
      if (tid.getTaskID().getId() == 1) {
        final BufferedReader br=new BufferedReader(new InputStreamReader(localFs.open(stdoutPath)));
        boolean flatProfFound=false;
        String line;
        while ((line=br.readLine()) != null) {
          if (line.startsWith("Flat profile")) {
            flatProfFound=true;
            break;
          }
        }
        br.close();
        Assert.assertTrue("Xprof flat profile not found!",flatProfFound);
      }
 else {
        Assert.assertEquals(0L,localFs.getFileStatus(stdoutPath).getLen());
      }
    }
  }
}
