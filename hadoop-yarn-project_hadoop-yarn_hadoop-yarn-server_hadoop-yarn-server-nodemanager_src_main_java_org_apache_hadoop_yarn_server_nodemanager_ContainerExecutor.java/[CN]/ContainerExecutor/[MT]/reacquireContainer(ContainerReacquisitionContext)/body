{
  Container container=ctx.getContainer();
  String user=ctx.getUser();
  ContainerId containerId=ctx.getContainerId();
  Path pidPath=getPidFilePath(containerId);
  if (pidPath == null) {
    LOG.warn(containerId + " is not active, returning terminated error");
    return ExitCode.TERMINATED.getExitCode();
  }
  String pid=null;
  pid=ProcessIdFileReader.getProcessId(pidPath);
  if (pid == null) {
    throw new IOException("Unable to determine pid for " + containerId);
  }
  LOG.info("Reacquiring " + containerId + " with pid "+ pid);
  ContainerLivenessContext livenessContext=new ContainerLivenessContext.Builder().setContainer(container).setUser(user).setPid(pid).build();
  while (isContainerAlive(livenessContext)) {
    Thread.sleep(1000);
  }
  String exitCodeFile=ContainerLaunch.getExitCodeFile(pidPath.toString());
  File file=new File(exitCodeFile);
  final int sleepMsec=100;
  int msecLeft=2000;
  while (!file.exists() && msecLeft >= 0) {
    if (!isContainerActive(containerId)) {
      LOG.info(containerId + " was deactivated");
      return ExitCode.TERMINATED.getExitCode();
    }
    Thread.sleep(sleepMsec);
    msecLeft-=sleepMsec;
  }
  if (msecLeft < 0) {
    throw new IOException("Timeout while waiting for exit code from " + containerId);
  }
  try {
    return Integer.parseInt(FileUtils.readFileToString(file).trim());
  }
 catch (  NumberFormatException e) {
    throw new IOException("Error parsing exit code from pid " + pid,e);
  }
}
