{
  if (this.logAggregationDisabled) {
    return;
  }
  if (UserGroupInformation.isSecurityEnabled()) {
    Credentials systemCredentials=context.getSystemCredentialsForApps().get(appId);
    if (systemCredentials != null) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Adding new framework-token for " + appId + " for log-aggregation: "+ systemCredentials.getAllTokens()+ "; userUgi="+ userUgi);
      }
      userUgi.addCredentials(systemCredentials);
    }
  }
  Set<ContainerId> pendingContainerInThisCycle=new HashSet<ContainerId>();
  this.pendingContainers.drainTo(pendingContainerInThisCycle);
  Set<ContainerId> finishedContainers=new HashSet<ContainerId>(pendingContainerInThisCycle);
  if (this.context.getApplications().get(this.appId) != null) {
    for (    ContainerId container : this.context.getApplications().get(this.appId).getContainers().keySet()) {
      if (shouldUploadLogs(container,true)) {
        pendingContainerInThisCycle.add(container);
      }
    }
  }
  LogWriter writer=null;
  try {
    try {
      writer=new LogWriter(this.conf,this.remoteNodeTmpLogFileForApp,this.userUgi);
      writer.writeApplicationACLs(appAcls);
      writer.writeApplicationOwner(this.userUgi.getShortUserName());
    }
 catch (    IOException e1) {
      LOG.error("Cannot create writer for app " + this.applicationId + ". Skip log upload this time. ",e1);
      return;
    }
    boolean uploadedLogsInThisCycle=false;
    for (    ContainerId container : pendingContainerInThisCycle) {
      ContainerLogAggregator aggregator=null;
      if (containerLogAggregators.containsKey(container)) {
        aggregator=containerLogAggregators.get(container);
      }
 else {
        aggregator=new ContainerLogAggregator(container);
        containerLogAggregators.put(container,aggregator);
      }
      Set<Path> uploadedFilePathsInThisCycle=aggregator.doContainerLogAggregation(writer,appFinished);
      if (uploadedFilePathsInThisCycle.size() > 0) {
        uploadedLogsInThisCycle=true;
      }
      this.delService.delete(this.userUgi.getShortUserName(),null,uploadedFilePathsInThisCycle.toArray(new Path[uploadedFilePathsInThisCycle.size()]));
      if (finishedContainers.contains(container)) {
        containerLogAggregators.remove(container);
      }
    }
    if (uploadedLogsInThisCycle) {
      cleanOldLogs();
    }
    if (writer != null) {
      writer.close();
    }
    long currentTime=System.currentTimeMillis();
    final Path renamedPath=this.rollingMonitorInterval <= 0 ? remoteNodeLogFileForApp : new Path(remoteNodeLogFileForApp.getParent(),remoteNodeLogFileForApp.getName() + "_" + currentTime);
    String diagnosticMessage="";
    boolean logAggregationSucceedInThisCycle=true;
    final boolean rename=uploadedLogsInThisCycle;
    try {
      userUgi.doAs(new PrivilegedExceptionAction<Object>(){
        @Override public Object run() throws Exception {
          FileSystem remoteFS=remoteNodeLogFileForApp.getFileSystem(conf);
          if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {
            if (rename) {
              remoteFS.rename(remoteNodeTmpLogFileForApp,renamedPath);
            }
 else {
              remoteFS.delete(remoteNodeTmpLogFileForApp,false);
            }
          }
          return null;
        }
      }
);
      diagnosticMessage="Log uploaded successfully for Application: " + appId + " in NodeManager: "+ LogAggregationUtils.getNodeString(nodeId)+ " at "+ Times.format(currentTime)+ "\n";
    }
 catch (    Exception e) {
      LOG.error("Failed to move temporary log file to final location: [" + remoteNodeTmpLogFileForApp + "] to ["+ renamedPath+ "]",e);
      diagnosticMessage="Log uploaded failed for Application: " + appId + " in NodeManager: "+ LogAggregationUtils.getNodeString(nodeId)+ " at "+ Times.format(currentTime)+ "\n";
      renameTemporaryLogFileFailed=true;
      logAggregationSucceedInThisCycle=false;
    }
    LogAggregationReport report=Records.newRecord(LogAggregationReport.class);
    report.setApplicationId(appId);
    report.setDiagnosticMessage(diagnosticMessage);
    report.setLogAggregationStatus(logAggregationSucceedInThisCycle ? LogAggregationStatus.RUNNING : LogAggregationStatus.RUNNING_WITH_FAILURE);
    this.context.getLogAggregationStatusForApps().add(report);
    if (appFinished) {
      LogAggregationReport finalReport=Records.newRecord(LogAggregationReport.class);
      finalReport.setApplicationId(appId);
      finalReport.setLogAggregationStatus(renameTemporaryLogFileFailed ? LogAggregationStatus.FAILED : LogAggregationStatus.SUCCEEDED);
      this.context.getLogAggregationStatusForApps().add(finalReport);
    }
  }
  finally {
    if (writer != null) {
      writer.close();
    }
  }
}
