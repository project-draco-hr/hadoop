{
  final long startTime=Time.monotonicNow();
  this.blocksToReceive=2 * getScheduledSize();
  boolean isTimeUp=false;
  int noPendingMoveIteration=0;
  while (!isTimeUp && getScheduledSize() > 0 && (!srcBlocks.isEmpty() || blocksToReceive > 0)) {
    if (LOG.isTraceEnabled()) {
      LOG.trace(this + " blocksToReceive=" + blocksToReceive+ ", scheduledSize="+ getScheduledSize()+ ", srcBlocks#="+ srcBlocks.size());
    }
    if (Time.monotonicNow() - startTime > MAX_ITERATION_TIME) {
      LOG.info("Time up (max time=" + MAX_ITERATION_TIME / 1000 + " seconds).  Skipping " + this);
      isTimeUp=true;
      continue;
    }
    final PendingMove p=chooseNextMove();
    if (p != null) {
      noPendingMoveIteration=0;
      executePendingMove(p);
      continue;
    }
    removeMovedBlocks();
    if (shouldFetchMoreBlocks()) {
      try {
        final long received=getBlockList();
        if (received == 0) {
          return;
        }
        blocksToReceive-=received;
        continue;
      }
 catch (      IOException e) {
        LOG.warn("Exception while getting reportedBlock list",e);
        return;
      }
    }
 else {
      noPendingMoveIteration++;
      if (noPendingMoveIteration >= MAX_NO_PENDING_MOVE_ITERATIONS) {
        LOG.info("Failed to find a pending move " + noPendingMoveIteration + " times.  Skipping "+ this);
        resetScheduledSize();
      }
    }
    try {
synchronized (Dispatcher.this) {
        Dispatcher.this.wait(1000);
      }
    }
 catch (    InterruptedException ignored) {
    }
  }
}
