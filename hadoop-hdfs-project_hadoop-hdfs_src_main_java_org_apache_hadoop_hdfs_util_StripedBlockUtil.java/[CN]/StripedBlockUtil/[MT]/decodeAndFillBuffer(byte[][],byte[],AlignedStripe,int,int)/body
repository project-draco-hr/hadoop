{
  int[] decodeIndices=new int[parityBlkNum];
  int pos=0;
  for (int i=0; i < alignedStripe.chunks.length; i++) {
    if (alignedStripe.chunks[i].state != StripingChunk.FETCHED && alignedStripe.chunks[i].state != StripingChunk.ALLZERO) {
      decodeIndices[pos++]=i;
    }
  }
  byte[][] outputs=new byte[parityBlkNum][(int)alignedStripe.getSpanInBlock()];
  RSRawDecoder rsRawDecoder=new RSRawDecoder(dataBlkNum,parityBlkNum);
  rsRawDecoder.decode(decodeInputs,decodeIndices,outputs);
  for (int i=0; i < dataBlkNum + parityBlkNum; i++) {
    StripingChunk chunk=alignedStripe.chunks[i];
    if (chunk.state == StripingChunk.MISSING) {
      int srcPos=0;
      for (int j=0; j < chunk.offsetsInBuf.size(); j++) {
        Arrays.fill(buf,chunk.offsetsInBuf.get(j),chunk.offsetsInBuf.get(j) + chunk.lengthsInBuf.get(j),(byte)7);
        srcPos+=chunk.lengthsInBuf.get(j);
      }
    }
  }
}
