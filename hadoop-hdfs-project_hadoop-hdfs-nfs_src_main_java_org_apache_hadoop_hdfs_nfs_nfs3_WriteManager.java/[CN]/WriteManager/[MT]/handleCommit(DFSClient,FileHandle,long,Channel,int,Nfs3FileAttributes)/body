{
  int status;
  OpenFileCtx openFileCtx=fileContextCache.get(fileHandle);
  if (openFileCtx == null) {
    LOG.info("No opened stream for fileId:" + fileHandle.getFileId() + " commitOffset="+ commitOffset+ ". Return success in this case.");
    status=Nfs3Status.NFS3_OK;
  }
 else {
    COMMIT_STATUS ret=openFileCtx.checkCommit(dfsClient,commitOffset,channel,xid,preOpAttr,false);
switch (ret) {
case COMMIT_FINISHED:
case COMMIT_INACTIVE_CTX:
      status=Nfs3Status.NFS3_OK;
    break;
case COMMIT_INACTIVE_WITH_PENDING_WRITE:
case COMMIT_ERROR:
  status=Nfs3Status.NFS3ERR_IO;
break;
case COMMIT_WAIT:
return;
case COMMIT_SPECIAL_WAIT:
status=Nfs3Status.NFS3ERR_JUKEBOX;
break;
case COMMIT_SPECIAL_SUCCESS:
status=Nfs3Status.NFS3_OK;
break;
default :
LOG.error("Should not get commit return code:" + ret.name());
throw new RuntimeException("Should not get commit return code:" + ret.name());
}
}
Nfs3FileAttributes postOpAttr=null;
try {
postOpAttr=getFileAttr(dfsClient,new FileHandle(preOpAttr.getFileId()),iug);
}
 catch (IOException e1) {
LOG.info("Can't get postOpAttr for fileId: " + preOpAttr.getFileId(),e1);
}
WccData fileWcc=new WccData(Nfs3Utils.getWccAttr(preOpAttr),postOpAttr);
COMMIT3Response response=new COMMIT3Response(status,fileWcc,Nfs3Constant.WRITE_COMMIT_VERF);
Nfs3Utils.writeChannelCommit(channel,response.serialize(new XDR(),xid,new VerifierNone()),xid);
}
