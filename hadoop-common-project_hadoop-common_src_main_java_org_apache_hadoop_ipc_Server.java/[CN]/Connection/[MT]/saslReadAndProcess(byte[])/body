{
  if (!saslContextEstablished) {
    RpcSaslProto saslResponse;
    try {
      saslResponse=processSaslMessage(saslToken);
    }
 catch (    IOException e) {
      IOException sendToClient=e;
      Throwable cause=e;
      while (cause != null) {
        if (cause instanceof InvalidToken) {
          sendToClient=(InvalidToken)cause;
          break;
        }
        cause=cause.getCause();
      }
      rpcMetrics.incrAuthenticationFailures();
      String clientIP=this.toString();
      AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + ":"+ attemptingUser+ " ("+ e.getLocalizedMessage()+ ")");
      doSaslReply(sendToClient);
      throw e;
    }
    if (saslServer != null && saslServer.isComplete()) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("SASL server context established. Negotiated QoP is " + saslServer.getNegotiatedProperty(Sasl.QOP));
      }
      String qop=(String)saslServer.getNegotiatedProperty(Sasl.QOP);
      useWrap=qop != null && !"auth".equalsIgnoreCase(qop);
      user=getAuthorizedUgi(saslServer.getAuthorizationID());
      if (LOG.isDebugEnabled()) {
        LOG.debug("SASL server successfully authenticated client: " + user);
      }
      rpcMetrics.incrAuthenticationSuccesses();
      AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);
      saslContextEstablished=true;
    }
    doSaslReply(saslResponse);
  }
 else {
    if (LOG.isDebugEnabled())     LOG.debug("Have read input token of size " + saslToken.length + " for processing by saslServer.unwrap()");
    if (!useWrap) {
      processOneRpc(saslToken);
    }
 else {
      byte[] plaintextData=saslServer.unwrap(saslToken,0,saslToken.length);
      processUnwrappedData(plaintextData);
    }
  }
}
