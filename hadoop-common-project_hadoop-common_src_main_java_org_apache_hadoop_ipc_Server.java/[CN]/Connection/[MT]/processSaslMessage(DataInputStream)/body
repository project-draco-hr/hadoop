{
  final RpcSaslProto saslMessage=decodeProtobufFromStream(RpcSaslProto.newBuilder(),dis);
  RpcSaslProto saslResponse=null;
  final SaslState state=saslMessage.getState();
switch (state) {
case NEGOTIATE:
{
      if (sentNegotiate) {
        throw new AccessControlException("Client already attempted negotiation");
      }
      saslResponse=buildSaslNegotiateResponse();
      if (saslResponse.getState() == SaslState.SUCCESS) {
        switchToSimple();
      }
      break;
    }
case INITIATE:
{
    if (saslMessage.getAuthsCount() != 1) {
      throw new SaslException("Client mechanism is malformed");
    }
    SaslAuth clientSaslAuth=saslMessage.getAuths(0);
    if (!negotiateResponse.getAuthsList().contains(clientSaslAuth)) {
      if (sentNegotiate) {
        throw new AccessControlException(clientSaslAuth.getMethod() + " authentication is not enabled." + "  Available:"+ enabledAuthMethods);
      }
      saslResponse=buildSaslNegotiateResponse();
      break;
    }
    authMethod=AuthMethod.valueOf(clientSaslAuth.getMethod());
    if (authMethod == AuthMethod.SIMPLE) {
      switchToSimple();
      break;
    }
    if (saslServer == null || authMethod != AuthMethod.TOKEN) {
      saslServer=createSaslServer(authMethod);
    }
  }
case RESPONSE:
{
  if (!saslMessage.hasToken()) {
    throw new SaslException("Client did not send a token");
  }
  byte[] saslToken=saslMessage.getToken().toByteArray();
  if (LOG.isDebugEnabled()) {
    LOG.debug("Have read input token of size " + saslToken.length + " for processing by saslServer.evaluateResponse()");
  }
  saslToken=saslServer.evaluateResponse(saslToken);
  saslResponse=buildSaslResponse(saslServer.isComplete() ? SaslState.SUCCESS : SaslState.CHALLENGE,saslToken);
  break;
}
default :
throw new SaslException("Client sent unsupported state " + state);
}
return saslResponse;
}
