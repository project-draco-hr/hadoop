{
  LOG.debug(Thread.currentThread().getName() + ": starting");
  SERVER.set(Server.this);
  ByteArrayOutputStream buf=new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
  while (running) {
    TraceScope traceScope=null;
    try {
      final Call call=callQueue.take();
      if (LOG.isDebugEnabled()) {
        LOG.debug(Thread.currentThread().getName() + ": " + call+ " for RpcKind "+ call.rpcKind);
      }
      if (!call.connection.channel.isOpen()) {
        LOG.info(Thread.currentThread().getName() + ": skipped " + call);
        continue;
      }
      String errorClass=null;
      String error=null;
      RpcStatusProto returnStatus=RpcStatusProto.SUCCESS;
      RpcErrorCodeProto detailedErr=null;
      Writable value=null;
      CurCall.set(call);
      if (call.traceSpan != null) {
        traceScope=Trace.continueSpan(call.traceSpan);
      }
      try {
        if (call.connection.user == null) {
          value=call(call.rpcKind,call.connection.protocolName,call.rpcRequest,call.timestamp);
        }
 else {
          value=call.connection.user.doAs(new PrivilegedExceptionAction<Writable>(){
            @Override public Writable run() throws Exception {
              return call(call.rpcKind,call.connection.protocolName,call.rpcRequest,call.timestamp);
            }
          }
);
        }
      }
 catch (      Throwable e) {
        if (e instanceof UndeclaredThrowableException) {
          e=e.getCause();
        }
        String logMsg=Thread.currentThread().getName() + ", call " + call;
        if (exceptionsHandler.isTerse(e.getClass())) {
          LOG.info(logMsg + ": " + e);
        }
 else         if (e instanceof RuntimeException || e instanceof Error) {
          LOG.warn(logMsg,e);
        }
 else {
          LOG.info(logMsg,e);
        }
        if (e instanceof RpcServerException) {
          RpcServerException rse=((RpcServerException)e);
          returnStatus=rse.getRpcStatusProto();
          detailedErr=rse.getRpcErrorCodeProto();
        }
 else {
          returnStatus=RpcStatusProto.ERROR;
          detailedErr=RpcErrorCodeProto.ERROR_APPLICATION;
        }
        errorClass=e.getClass().getName();
        error=StringUtils.stringifyException(e);
        String exceptionHdr=errorClass + ": ";
        if (error.startsWith(exceptionHdr)) {
          error=error.substring(exceptionHdr.length());
        }
      }
      CurCall.set(null);
synchronized (call.connection.responseQueue) {
        setupResponse(buf,call,returnStatus,detailedErr,value,errorClass,error);
        if (buf.size() > maxRespSize) {
          LOG.warn("Large response size " + buf.size() + " for call "+ call.toString());
          buf=new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
        }
        responder.doRespond(call);
      }
    }
 catch (    InterruptedException e) {
      if (running) {
        LOG.info(Thread.currentThread().getName() + " unexpectedly interrupted",e);
        if (Trace.isTracing()) {
          traceScope.getSpan().addTimelineAnnotation("unexpectedly interrupted: " + StringUtils.stringifyException(e));
        }
      }
    }
catch (    Exception e) {
      LOG.info(Thread.currentThread().getName() + " caught an exception",e);
      if (Trace.isTracing()) {
        traceScope.getSpan().addTimelineAnnotation("Exception: " + StringUtils.stringifyException(e));
      }
    }
 finally {
      if (traceScope != null) {
        traceScope.close();
      }
      IOUtils.cleanup(LOG,traceScope);
    }
  }
  LOG.debug(Thread.currentThread().getName() + ": exiting");
}
