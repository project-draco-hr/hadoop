{
  while (true) {
    int count=-1;
    if (dataLengthBuffer.remaining() > 0) {
      count=channelRead(channel,dataLengthBuffer);
      if (count < 0 || dataLengthBuffer.remaining() > 0)       return count;
    }
    if (!connectionHeaderRead) {
      if (connectionHeaderBuf == null) {
        connectionHeaderBuf=ByteBuffer.allocate(3);
      }
      count=channelRead(channel,connectionHeaderBuf);
      if (count < 0 || connectionHeaderBuf.remaining() > 0) {
        return count;
      }
      int version=connectionHeaderBuf.get(0);
      byte[] method=new byte[]{connectionHeaderBuf.get(1)};
      authMethod=AuthMethod.read(new DataInputStream(new ByteArrayInputStream(method)));
      dataLengthBuffer.flip();
      if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {
        setupHttpRequestOnIpcPortResponse();
        return -1;
      }
      if (!HEADER.equals(dataLengthBuffer) || version != CURRENT_VERSION) {
        LOG.warn("Incorrect header or version mismatch from " + hostAddress + ":"+ remotePort+ " got version "+ version+ " expected version "+ CURRENT_VERSION);
        setupBadVersionResponse(version);
        return -1;
      }
      IpcSerializationType serializationType=IpcSerializationType.fromByte(connectionHeaderBuf.get(2));
      if (serializationType != IpcSerializationType.PROTOBUF) {
        respondUnsupportedSerialization(serializationType);
        return -1;
      }
      dataLengthBuffer.clear();
      if (authMethod == null) {
        throw new IOException("Unable to read authentication method");
      }
      boolean useSaslServer=isSecurityEnabled;
      final boolean clientUsingSasl;
switch (authMethod) {
case SIMPLE:
{
          clientUsingSasl=false;
          break;
        }
case DIGEST:
{
        useSaslServer|=(secretManager != null);
        clientUsingSasl=true;
        break;
      }
default :
{
      clientUsingSasl=true;
      break;
    }
}
if (useSaslServer) {
  saslServer=createSaslServer(authMethod);
}
 else if (clientUsingSasl) {
  doSaslReply(SaslStatus.SUCCESS,new IntWritable(SaslRpcServer.SWITCH_TO_SIMPLE_AUTH),null,null);
  authMethod=AuthMethod.SIMPLE;
  skipInitialSaslHandshake=true;
}
connectionHeaderBuf=null;
connectionHeaderRead=true;
continue;
}
if (data == null) {
dataLengthBuffer.flip();
dataLength=dataLengthBuffer.getInt();
if ((dataLength == Client.PING_CALL_ID) && (!useWrap)) {
  dataLengthBuffer.clear();
  return 0;
}
if (dataLength < 0) {
  LOG.warn("Unexpected data length " + dataLength + "!! from "+ getHostAddress());
}
data=ByteBuffer.allocate(dataLength);
}
count=channelRead(channel,data);
if (data.remaining() == 0) {
dataLengthBuffer.clear();
data.flip();
if (skipInitialSaslHandshake) {
  data=null;
  skipInitialSaslHandshake=false;
  continue;
}
boolean isHeaderRead=connectionContextRead;
if (saslServer != null) {
  saslReadAndProcess(data.array());
}
 else {
  processOneRpc(data.array());
}
data=null;
if (!isHeaderRead) {
  continue;
}
}
return count;
}
}
