{
  DataInputStream dis=new DataInputStream(new ByteArrayInputStream(buf));
  RpcRequestHeaderProto header=RpcRequestHeaderProto.parseDelimitedFrom(dis);
  if (LOG.isDebugEnabled())   LOG.debug(" got #" + header.getCallId());
  if (!header.hasRpcOp()) {
    throw new IOException(" IPC Server: No rpc op in rpcRequestHeader");
  }
  if (header.getRpcOp() != RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {
    throw new IOException("IPC Server does not implement operation" + header.getRpcOp());
  }
  if (!header.hasRpcKind()) {
    throw new IOException(" IPC Server: No rpc kind in rpcRequestHeader");
  }
  Class<? extends Writable> rpcRequestClass=getRpcRequestWrapper(header.getRpcKind());
  if (rpcRequestClass == null) {
    LOG.warn("Unknown rpc kind " + header.getRpcKind() + " from client "+ getHostAddress());
    final Call readParamsFailedCall=new Call(header.getCallId(),null,this);
    ByteArrayOutputStream responseBuffer=new ByteArrayOutputStream();
    setupResponse(responseBuffer,readParamsFailedCall,RpcStatusProto.FATAL,null,IOException.class.getName(),"Unknown rpc kind " + header.getRpcKind());
    responder.doRespond(readParamsFailedCall);
    return;
  }
  Writable rpcRequest;
  try {
    rpcRequest=ReflectionUtils.newInstance(rpcRequestClass,conf);
    rpcRequest.readFields(dis);
  }
 catch (  Throwable t) {
    LOG.warn("Unable to read call parameters for client " + getHostAddress() + "on connection protocol "+ this.protocolName+ " for rpcKind "+ header.getRpcKind(),t);
    final Call readParamsFailedCall=new Call(header.getCallId(),null,this);
    ByteArrayOutputStream responseBuffer=new ByteArrayOutputStream();
    setupResponse(responseBuffer,readParamsFailedCall,RpcStatusProto.FATAL,null,t.getClass().getName(),"IPC server unable to read call parameters: " + t.getMessage());
    responder.doRespond(readParamsFailedCall);
    return;
  }
  Call call=new Call(header.getCallId(),rpcRequest,this,ProtoUtil.convert(header.getRpcKind()));
  callQueue.put(call);
  incRpcCount();
}
