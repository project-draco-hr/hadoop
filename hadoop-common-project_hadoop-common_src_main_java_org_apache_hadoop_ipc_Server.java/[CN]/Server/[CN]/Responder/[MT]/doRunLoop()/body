{
  long lastPurgeTime=0;
  while (running) {
    try {
      waitPending();
      writeSelector.select(PURGE_INTERVAL);
      Iterator<SelectionKey> iter=writeSelector.selectedKeys().iterator();
      while (iter.hasNext()) {
        SelectionKey key=iter.next();
        iter.remove();
        try {
          if (key.isValid() && key.isWritable()) {
            doAsyncWrite(key);
          }
        }
 catch (        IOException e) {
          LOG.info(Thread.currentThread().getName() + ": doAsyncWrite threw exception " + e);
        }
      }
      long now=Time.now();
      if (now < lastPurgeTime + PURGE_INTERVAL) {
        continue;
      }
      lastPurgeTime=now;
      if (LOG.isDebugEnabled()) {
        LOG.debug("Checking for old call responses.");
      }
      ArrayList<RpcCall> calls;
synchronized (writeSelector.keys()) {
        calls=new ArrayList<RpcCall>(writeSelector.keys().size());
        iter=writeSelector.keys().iterator();
        while (iter.hasNext()) {
          SelectionKey key=iter.next();
          RpcCall call=(RpcCall)key.attachment();
          if (call != null && key.channel() == call.connection.channel) {
            calls.add(call);
          }
        }
      }
      for (      RpcCall call : calls) {
        doPurge(call,now);
      }
    }
 catch (    OutOfMemoryError e) {
      LOG.warn("Out of Memory in server select",e);
      try {
        Thread.sleep(60000);
      }
 catch (      Exception ie) {
      }
    }
catch (    Exception e) {
      LOG.warn("Exception in Responder",e);
    }
  }
}
