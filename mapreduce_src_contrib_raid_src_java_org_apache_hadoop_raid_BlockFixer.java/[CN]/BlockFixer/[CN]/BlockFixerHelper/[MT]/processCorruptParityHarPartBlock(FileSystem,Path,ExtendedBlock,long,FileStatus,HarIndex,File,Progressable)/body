{
  String partName=partFile.toUri().getPath();
  partName=partName.substring(1 + partName.lastIndexOf(Path.SEPARATOR));
  OutputStream out=new FileOutputStream(localBlockFile);
  try {
    final long corruptEnd=Math.min(corruptOffset + partFileStat.getBlockSize(),partFileStat.getLen());
    for (long offset=corruptOffset; offset < corruptEnd; ) {
      HarIndex.IndexEntry entry=harIndex.findEntry(partName,offset);
      if (entry == null) {
        String msg="Corrupt index file has no matching index entry for " + partName + ":"+ offset;
        LOG.warn(msg);
        throw new IOException(msg);
      }
      Path parityFile=new Path(entry.fileName);
      Encoder encoder;
      if (isXorParityFile(parityFile)) {
        encoder=xorEncoder;
      }
 else       if (isRsParityFile(parityFile)) {
        encoder=rsEncoder;
      }
 else {
        String msg="Could not figure out parity file correctly";
        LOG.warn(msg);
        throw new IOException(msg);
      }
      Path srcFile=sourcePathFromParityPath(parityFile);
      FileStatus srcStat=dfs.getFileStatus(srcFile);
      if (srcStat.getModificationTime() != entry.mtime) {
        String msg="Modification times of " + parityFile + " and "+ srcFile+ " do not match.";
        LOG.warn(msg);
        throw new IOException(msg);
      }
      long corruptOffsetInParity=offset - entry.startOffset;
      LOG.info(partFile + ":" + offset+ " maps to "+ parityFile+ ":"+ corruptOffsetInParity+ " and will be recovered from "+ srcFile);
      encoder.recoverParityBlockToStream(dfs,srcFile,srcStat.getLen(),srcStat.getBlockSize(),parityFile,corruptOffsetInParity,out);
      offset+=srcStat.getBlockSize();
      LOG.info("Recovered " + srcStat.getBlockSize() + " part file bytes ");
      if (offset > corruptEnd) {
        String msg="Recovered block spills across part file blocks. Cannot continue.";
        throw new IOException(msg);
      }
      progress.progress();
    }
  }
  finally {
    out.close();
  }
}
