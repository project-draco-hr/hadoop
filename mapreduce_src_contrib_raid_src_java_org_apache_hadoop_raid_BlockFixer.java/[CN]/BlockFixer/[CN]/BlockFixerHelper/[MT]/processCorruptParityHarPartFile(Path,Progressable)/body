{
  LOG.info("Processing corrupt file " + partFile);
  DistributedFileSystem dfs=getDFS(partFile);
  FileStatus partFileStat=dfs.getFileStatus(partFile);
  long partFileSize=partFileStat.getLen();
  long partFileBlockSize=partFileStat.getBlockSize();
  LOG.info(partFile + " has block size " + partFileBlockSize);
  String harDirectory=partFile.toUri().getPath();
  harDirectory=harDirectory.substring(0,harDirectory.lastIndexOf(Path.SEPARATOR));
  Path indexFile=new Path(harDirectory + "/" + HarIndex.indexFileName);
  FileStatus indexStat=dfs.getFileStatus(indexFile);
  HarIndex harIndex=new HarIndex(dfs.open(indexFile),indexStat.getLen());
  String uriPath=partFile.toUri().getPath();
  int numBlocksFixed=0;
  List<LocatedBlock> corrupt=RaidDFSUtil.corruptBlocksInFile(dfs,uriPath,0,partFileSize);
  if (corrupt.size() == 0) {
    return false;
  }
  for (  LocatedBlock lb : corrupt) {
    ExtendedBlock corruptBlock=lb.getBlock();
    long corruptOffset=lb.getStartOffset();
    File localBlockFile=File.createTempFile(corruptBlock.getBlockName(),".tmp");
    localBlockFile.deleteOnExit();
    processCorruptParityHarPartBlock(dfs,partFile,corruptBlock,corruptOffset,partFileStat,harIndex,localBlockFile,progress);
    try {
      DatanodeInfo datanode=chooseDatanode(lb.getLocations());
      computeMetadataAndSendFixedBlock(datanode,localBlockFile,lb,localBlockFile.length());
      numBlocksFixed++;
    }
  finally {
      localBlockFile.delete();
    }
    progress.progress();
  }
  LOG.info("Fixed " + numBlocksFixed + " blocks in "+ partFile);
  return true;
}
