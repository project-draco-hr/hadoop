{
  LOG.info("Processing corrupt file " + srcPath);
  DistributedFileSystem srcFs=getDFS(srcPath);
  FileStatus srcStat=srcFs.getFileStatus(srcPath);
  long blockSize=srcStat.getBlockSize();
  long srcFileSize=srcStat.getLen();
  String uriPath=srcPath.toUri().getPath();
  int numBlocksFixed=0;
  List<LocatedBlock> corrupt=RaidDFSUtil.corruptBlocksInFile(srcFs,uriPath,0,srcFileSize);
  if (corrupt.size() == 0) {
    return false;
  }
  for (  LocatedBlock lb : corrupt) {
    ExtendedBlock corruptBlock=lb.getBlock();
    long corruptOffset=lb.getStartOffset();
    LOG.info("Found corrupt block " + corruptBlock + ", offset "+ corruptOffset);
    final long blockContentsSize=Math.min(blockSize,srcFileSize - corruptOffset);
    File localBlockFile=File.createTempFile(corruptBlock.getBlockName(),".tmp");
    localBlockFile.deleteOnExit();
    try {
      decoder.recoverBlockToFile(srcFs,srcPath,parityPair.getFileSystem(),parityPair.getPath(),blockSize,corruptOffset,localBlockFile,blockContentsSize);
      DatanodeInfo datanode=chooseDatanode(lb.getLocations());
      computeMetadataAndSendFixedBlock(datanode,localBlockFile,lb,blockContentsSize);
      numBlocksFixed++;
    }
  finally {
      localBlockFile.delete();
    }
    progress.progress();
  }
  LOG.info("Fixed " + numBlocksFixed + " blocks in "+ srcPath);
  return true;
}
