{
  if (!blk.isComplete()) {
    final BlockInfoUnderConstruction uc=(BlockInfoUnderConstruction)blk;
    final DatanodeDescriptor[] locations=uc.getExpectedLocations();
    return namesystem.createLocatedBlock(uc,locations,pos,false);
  }
  final int numCorruptNodes=countNodes(blk).corruptReplicas();
  final int numCorruptReplicas=corruptReplicas.numCorruptReplicas(blk);
  if (numCorruptNodes != numCorruptReplicas) {
    FSNamesystem.LOG.warn("Inconsistent number of corrupt replicas for " + blk + " blockMap has "+ numCorruptNodes+ " but corrupt replicas map has "+ numCorruptReplicas);
  }
  final int numNodes=blocksMap.numNodes(blk);
  final boolean isCorrupt=numCorruptNodes == numNodes;
  final int numMachines=isCorrupt ? numNodes : numNodes - numCorruptNodes;
  final DatanodeDescriptor[] machines=new DatanodeDescriptor[numMachines];
  if (numMachines > 0) {
    int j=0;
    for (Iterator<DatanodeDescriptor> it=blocksMap.nodeIterator(blk); it.hasNext(); ) {
      final DatanodeDescriptor d=it.next();
      final boolean replicaCorrupt=corruptReplicas.isReplicaCorrupt(blk,d);
      if (isCorrupt || (!isCorrupt && !replicaCorrupt))       machines[j++]=d;
    }
  }
  return namesystem.createLocatedBlock(blk,machines,pos,isCorrupt);
}
