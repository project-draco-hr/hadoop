{
  int requiredReplication, numEffectiveReplicas;
  List<DatanodeDescriptor> containingNodes;
  DatanodeDescriptor srcNode;
  INodeFile fileINode=null;
  int additionalReplRequired;
  namesystem.writeLock();
  try {
synchronized (neededReplications) {
      fileINode=blocksMap.getINode(block);
      if (fileINode == null || fileINode.isUnderConstruction()) {
        neededReplications.remove(block,priority);
        replIndex--;
        return false;
      }
      requiredReplication=fileINode.getReplication();
      containingNodes=new ArrayList<DatanodeDescriptor>();
      NumberReplicas numReplicas=new NumberReplicas();
      srcNode=chooseSourceDatanode(block,containingNodes,numReplicas);
      if (srcNode == null)       return false;
      numEffectiveReplicas=numReplicas.liveReplicas() + pendingReplications.getNumReplicas(block);
      if (numEffectiveReplicas >= requiredReplication) {
        if ((pendingReplications.getNumReplicas(block) > 0) || (blockHasEnoughRacks(block))) {
          neededReplications.remove(block,priority);
          replIndex--;
          NameNode.stateChangeLog.info("BLOCK* " + "Removing block " + block + " from neededReplications as it has enough replicas.");
          return false;
        }
      }
      if (numReplicas.liveReplicas() < requiredReplication) {
        additionalReplRequired=requiredReplication - numEffectiveReplicas;
      }
 else {
        additionalReplRequired=1;
      }
    }
  }
  finally {
    namesystem.writeUnlock();
  }
  DatanodeDescriptor targets[]=replicator.chooseTarget(fileINode,additionalReplRequired,srcNode,containingNodes,block.getNumBytes());
  if (targets.length == 0)   return false;
  namesystem.writeLock();
  try {
synchronized (neededReplications) {
      fileINode=blocksMap.getINode(block);
      if (fileINode == null || fileINode.isUnderConstruction()) {
        neededReplications.remove(block,priority);
        replIndex--;
        return false;
      }
      requiredReplication=fileINode.getReplication();
      NumberReplicas numReplicas=countNodes(block);
      numEffectiveReplicas=numReplicas.liveReplicas() + pendingReplications.getNumReplicas(block);
      if (numEffectiveReplicas >= requiredReplication) {
        if ((pendingReplications.getNumReplicas(block) > 0) || (blockHasEnoughRacks(block))) {
          neededReplications.remove(block,priority);
          replIndex--;
          NameNode.stateChangeLog.info("BLOCK* " + "Removing block " + block + " from neededReplications as it has enough replicas.");
          return false;
        }
      }
      if ((numReplicas.liveReplicas() >= requiredReplication) && (!blockHasEnoughRacks(block))) {
        if (srcNode.getNetworkLocation().equals(targets[0].getNetworkLocation())) {
          return false;
        }
      }
      srcNode.addBlockToBeReplicated(block,targets);
      for (      DatanodeDescriptor dn : targets) {
        dn.incBlocksScheduled();
      }
      pendingReplications.add(block,targets.length);
      if (NameNode.stateChangeLog.isDebugEnabled()) {
        NameNode.stateChangeLog.debug("BLOCK* block " + block + " is moved from neededReplications to pendingReplications");
      }
      if (numEffectiveReplicas + targets.length >= requiredReplication) {
        neededReplications.remove(block,priority);
        replIndex--;
      }
      if (NameNode.stateChangeLog.isInfoEnabled()) {
        StringBuilder targetList=new StringBuilder("datanode(s)");
        for (int k=0; k < targets.length; k++) {
          targetList.append(' ');
          targetList.append(targets[k].getName());
        }
        NameNode.stateChangeLog.info("BLOCK* ask " + srcNode.getName() + " to replicate "+ block+ " to "+ targetList);
        if (NameNode.stateChangeLog.isDebugEnabled()) {
          NameNode.stateChangeLog.debug("BLOCK* neededReplications = " + neededReplications.size() + " pendingReplications = "+ pendingReplications.size());
        }
      }
    }
  }
  finally {
    namesystem.writeUnlock();
  }
  return true;
}
