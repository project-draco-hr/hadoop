{
synchronized (neededReplications) {
    out.println("Metasave: Blocks waiting for replication: " + neededReplications.size());
    for (    Block block : neededReplications) {
      List<DatanodeDescriptor> containingNodes=new ArrayList<DatanodeDescriptor>();
      NumberReplicas numReplicas=new NumberReplicas();
      chooseSourceDatanode(block,containingNodes,numReplicas);
      int usableReplicas=numReplicas.liveReplicas() + numReplicas.decommissionedReplicas();
      if (block instanceof BlockInfo) {
        String fileName=((BlockInfo)block).getINode().getFullPathName();
        out.print(fileName + ": ");
      }
      out.print(block + ((usableReplicas > 0) ? "" : " MISSING") + " (replicas:"+ " l: "+ numReplicas.liveReplicas()+ " d: "+ numReplicas.decommissionedReplicas()+ " c: "+ numReplicas.corruptReplicas()+ " e: "+ numReplicas.excessReplicas()+ ") ");
      Collection<DatanodeDescriptor> corruptNodes=corruptReplicas.getNodes(block);
      for (Iterator<DatanodeDescriptor> jt=blocksMap.nodeIterator(block); jt.hasNext(); ) {
        DatanodeDescriptor node=jt.next();
        String state="";
        if (corruptNodes != null && corruptNodes.contains(node)) {
          state="(corrupt)";
        }
 else         if (node.isDecommissioned() || node.isDecommissionInProgress()) {
          state="(decommissioned)";
        }
        out.print(" " + node + state+ " : ");
      }
      out.println("");
    }
  }
  pendingReplications.metaSave(out);
  dumpRecentInvalidateSets(out);
}
