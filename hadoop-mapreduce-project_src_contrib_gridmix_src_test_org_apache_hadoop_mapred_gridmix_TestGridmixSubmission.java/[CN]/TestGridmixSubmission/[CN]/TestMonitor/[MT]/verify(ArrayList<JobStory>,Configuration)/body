{
  final ArrayList<Job> succeeded=new ArrayList<Job>();
  assertEquals("Bad job count",expected,retiredJobs.drainTo(succeeded));
  final HashMap<String,JobStory> sub=new HashMap<String,JobStory>();
  final Path in=new Path("foo").makeQualified(GridmixTestUtils.dfs);
  final Path out=new Path(in,clientConf.get(Gridmix.GRIDMIX_OUT_DIR,"gridmix"));
  for (  JobStory spec : submitted) {
    sub.put(spec.getJobID().toString(),spec);
  }
  final JobClient client=new JobClient(GridmixTestUtils.mrCluster.createJobConf());
  for (  Job job : succeeded) {
    final String jobName=job.getJobName();
    Configuration conf=job.getConfiguration();
    if (GenerateData.JOB_NAME.equals(jobName)) {
      verifyQueue(conf,jobName);
      final ContentSummary generated=GridmixTestUtils.dfs.getContentSummary(in);
      assertTrue("Mismatched data gen",(GENDATA << 20) < generated.getLength() + GENSLOP || (GENDATA << 20) > generated.getLength() - GENSLOP);
      FileStatus[] outstat=GridmixTestUtils.dfs.listStatus(out);
      assertEquals("Mismatched job count",NJOBS,outstat.length);
      continue;
    }
 else     if (GenerateDistCacheData.JOB_NAME.equals(jobName)) {
      verifyQueue(conf,jobName);
      continue;
    }
    if (!conf.getBoolean(GridmixJob.GRIDMIX_USE_QUEUE_IN_TRACE,true)) {
      assertEquals(" Improper queue for  " + jobName + " ",conf.get(MRJobConfig.QUEUE_NAME),"q1");
    }
 else {
      assertEquals(" Improper queue for  " + jobName + " ",conf.get(MRJobConfig.QUEUE_NAME),sub.get(conf.get(Gridmix.ORIGINAL_JOB_ID)).getQueueName());
    }
    final String originalJobId=conf.get(Gridmix.ORIGINAL_JOB_ID);
    final JobStory spec=sub.get(originalJobId);
    assertNotNull("No spec for " + jobName,spec);
    assertNotNull("No counters for " + jobName,job.getCounters());
    final String originalJobName=spec.getName();
    System.out.println("originalJobName=" + originalJobName + ";GridmixJobName="+ jobName+ ";originalJobID="+ originalJobId);
    assertTrue("Original job name is wrong.",originalJobName.equals(conf.get(Gridmix.ORIGINAL_JOB_NAME)));
    int seqNumLength=6;
    String jobSeqNum=new DecimalFormat("000000").format(conf.getInt(GridmixJob.GRIDMIX_JOB_SEQ,-1));
    assertTrue(originalJobName.substring(originalJobName.length() - seqNumLength).equals(jobSeqNum));
    assertTrue("Gridmix job name is not in the expected format.",jobName.equals(GridmixJob.JOB_NAME_PREFIX + jobSeqNum));
    final FileStatus stat=GridmixTestUtils.dfs.getFileStatus(new Path(out,"" + Integer.valueOf(jobSeqNum)));
    assertEquals("Wrong owner for " + jobName,spec.getUser(),stat.getOwner());
    final int nMaps=spec.getNumberMaps();
    final int nReds=spec.getNumberReduces();
    if (true)     return;
    System.out.println(jobName + ": " + nMaps+ "/"+ nReds);
    final TaskReport[] mReports=client.getMapTaskReports(JobID.downgrade(job.getJobID()));
    assertEquals("Mismatched map count",nMaps,mReports.length);
    check(TaskType.MAP,job,spec,mReports,0,0,SLOPBYTES,nReds);
    final TaskReport[] rReports=client.getReduceTaskReports(JobID.downgrade(job.getJobID()));
    assertEquals("Mismatched reduce count",nReds,rReports.length);
    check(TaskType.REDUCE,job,spec,rReports,nMaps * SLOPBYTES,2 * nMaps,0,0);
  }
}
