{
  if (i >= values.size())   throw new IndexOutOfBoundsException("Index " + i + " greater than input size "+ values.size());
  if (validate && value != null) {
    Integer type=types.get(i);
switch (type) {
case Types.BIGINT:
      if (!(value instanceof Long) && !(value instanceof Integer) && !(value instanceof Short)&& !(value instanceof LongWritable)&& !(value instanceof VLongWritable)&& !(value instanceof VIntWritable))       throw new ClassCastException("Cannot cast " + value.getClass().getName() + " to Long");
    break;
case Types.INTEGER:
  if (!(value instanceof Integer) && !(value instanceof Short) && !(value instanceof VIntWritable))   throw new ClassCastException("Cannot cast " + value.getClass().getName() + " to Integer");
break;
case Types.TINYINT:
case Types.SMALLINT:
if (!(value instanceof Short)) throw new ClassCastException("Cannot cast " + value.getClass().getName() + " to Short");
break;
case Types.REAL:
case Types.DECIMAL:
case Types.NUMERIC:
if (!(value instanceof BigDecimal)) throw new ClassCastException("Cannot cast " + value.getClass().getName() + " to BigDecimal");
case Types.DOUBLE:
if (!(value instanceof Double) && !(value instanceof Float) && !(value instanceof DoubleWritable)&& !(value instanceof FloatWritable)) throw new ClassCastException("Cannot cast " + value.getClass().getName() + " to Double");
break;
case Types.FLOAT:
if (!(value instanceof Float) && !(value instanceof FloatWritable)) throw new ClassCastException("Cannot cast " + value.getClass().getName() + " to Float");
break;
case Types.BINARY:
case Types.LONGVARBINARY:
case Types.VARBINARY:
if (!(value instanceof byte[]) && !(value instanceof BytesWritable)) throw new ClassCastException("Cannot cast " + value.getClass().getName() + " to byte[]");
break;
case Types.BIT:
case Types.BOOLEAN:
if (!(value instanceof Boolean) && !(value instanceof BooleanWritable) && !(value instanceof ByteWritable)) throw new ClassCastException("Cannot cast " + value.getClass().getName() + " to Boolean");
break;
case Types.CHAR:
if (!(value instanceof Character) && !(value instanceof String)) throw new ClassCastException("Cannot cast " + value.getClass().getName() + " to Character");
break;
case Types.LONGNVARCHAR:
case Types.LONGVARCHAR:
case Types.NCHAR:
case Types.NVARCHAR:
case Types.VARCHAR:
if (!(value instanceof String) && !(value instanceof Text)) throw new ClassCastException("Cannot cast " + value.getClass().getName() + " to String");
break;
case Types.DATE:
if (!(value instanceof Date) && !(value instanceof java.util.Date)) throw new ClassCastException("Cannot cast " + value.getClass().getName() + " to Date");
break;
case Types.TIME:
if (!(value instanceof Time) && !(value instanceof java.util.Date)) throw new ClassCastException("Cannot cast " + value.getClass().getName() + " to Time");
break;
case Types.TIMESTAMP:
if (!(value instanceof Timestamp) && !(value instanceof java.util.Date)) throw new ClassCastException("Cannot cast " + value.getClass().getName() + " to Timestamp");
break;
default :
throw new RuntimeException("Unknown type value " + types.get(i));
}
}
values.set(i,value);
}
