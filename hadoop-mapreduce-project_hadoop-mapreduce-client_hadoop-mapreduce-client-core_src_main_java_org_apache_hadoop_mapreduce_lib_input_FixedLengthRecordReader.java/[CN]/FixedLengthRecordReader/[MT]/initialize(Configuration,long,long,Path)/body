{
  start=splitStart;
  end=start + splitLength;
  long partialRecordLength=start % recordLength;
  long numBytesToSkip=0;
  if (partialRecordLength != 0) {
    numBytesToSkip=recordLength - partialRecordLength;
  }
  final FileSystem fs=file.getFileSystem(job);
  fileIn=fs.open(file);
  CompressionCodec codec=new CompressionCodecFactory(job).getCodec(file);
  if (null != codec) {
    isCompressedInput=true;
    decompressor=CodecPool.getDecompressor(codec);
    CompressionInputStream cIn=codec.createInputStream(fileIn,decompressor);
    filePosition=cIn;
    inputStream=cIn;
    numRecordsRemainingInSplit=Long.MAX_VALUE;
    LOG.info("Compressed input; cannot compute number of records in the split");
  }
 else {
    fileIn.seek(start);
    filePosition=fileIn;
    inputStream=fileIn;
    long splitSize=end - start - numBytesToSkip;
    numRecordsRemainingInSplit=(splitSize + recordLength - 1) / recordLength;
    if (numRecordsRemainingInSplit < 0) {
      numRecordsRemainingInSplit=0;
    }
    LOG.info("Expecting " + numRecordsRemainingInSplit + " records each with a length of "+ recordLength+ " bytes in the split with an effective size of "+ splitSize+ " bytes");
  }
  if (numBytesToSkip != 0) {
    start+=inputStream.skip(numBytesToSkip);
  }
  this.pos=start;
}
