{
  if (killPos <= FLUSH_POS) {
    LOG.warn("killPos=" + killPos + " <= FLUSH_POS="+ FLUSH_POS+ ", length="+ length+ ", dnIndex="+ dnIndex);
    return;
  }
  Preconditions.checkArgument(length > killPos,"length=%s <= killPos=%s",length,killPos);
  cluster.startDataNodes(conf,1,true,null,null);
  cluster.waitActive();
  final Path p=new Path(dir,"dn" + dnIndex + "len"+ length+ "kill"+ killPos);
  final String fullPath=p.toString();
  LOG.info("fullPath=" + fullPath);
  if (tokenExpire) {
    final NameNode nn=cluster.getNameNode();
    final BlockManager bm=nn.getNamesystem().getBlockManager();
    final BlockTokenSecretManager sm=bm.getBlockTokenSecretManager();
    SecurityTestUtil.setBlockTokenLifetime(sm,1000L);
  }
  final AtomicInteger pos=new AtomicInteger();
  final FSDataOutputStream out=dfs.create(p);
  final DFSStripedOutputStream stripedOut=(DFSStripedOutputStream)out.getWrappedStream();
  long oldGS=-1;
  boolean killed=false;
  for (; pos.get() < length; ) {
    final int i=pos.getAndIncrement();
    if (i == killPos) {
      final long gs=getGenerationStamp(stripedOut);
      Assert.assertTrue(oldGS != -1);
      Assert.assertEquals(oldGS,gs);
      if (tokenExpire) {
        DFSTestUtil.flushInternal(stripedOut);
        waitTokenExpires(out);
      }
      killDatanode(cluster,stripedOut,dnIndex,pos);
      killed=true;
    }
    write(out,i);
    if (i == FLUSH_POS) {
      oldGS=getGenerationStamp(stripedOut);
    }
  }
  out.close();
  Assert.assertTrue(killed);
  final FileStatus status=dfs.getFileStatus(p);
  Assert.assertEquals(length,status.getLen());
  checkData(dfs,fullPath,length,dnIndex,oldGS);
}
