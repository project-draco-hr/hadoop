{
  if (numPendingReduces == 0) {
    return;
  }
  int headRoom=getAvailableResources() != null ? getAvailableResources().getMemory() : 0;
  LOG.info("Recalculating schedule, headroom=" + headRoom);
  if (!getIsReduceStarted()) {
    int completedMapsForReduceSlowstart=(int)Math.ceil(reduceSlowStart * totalMaps);
    if (completedMaps < completedMapsForReduceSlowstart) {
      LOG.info("Reduce slow start threshold not met. " + "completedMapsForReduceSlowstart " + completedMapsForReduceSlowstart);
      return;
    }
 else {
      LOG.info("Reduce slow start threshold reached. Scheduling reduces.");
      setIsReduceStarted(true);
    }
  }
  if (scheduledMaps == 0 && numPendingReduces > 0) {
    LOG.info("All maps assigned. " + "Ramping up all remaining reduces:" + numPendingReduces);
    scheduleAllReduces();
    return;
  }
  float completedMapPercent=0f;
  if (totalMaps != 0) {
    completedMapPercent=(float)completedMaps / totalMaps;
  }
 else {
    completedMapPercent=1;
  }
  int netScheduledMapMem=(scheduledMaps + assignedMaps) * mapResourceReqt;
  int netScheduledReduceMem=(scheduledReduces + assignedReduces) * reduceResourceReqt;
  int finalMapMemLimit=0;
  int finalReduceMemLimit=0;
  int totalMemLimit=getMemLimit();
  int idealReduceMemLimit=Math.min((int)(completedMapPercent * totalMemLimit),(int)(maxReduceRampupLimit * totalMemLimit));
  int idealMapMemLimit=totalMemLimit - idealReduceMemLimit;
  if (idealMapMemLimit > netScheduledMapMem) {
    int unusedMapMemLimit=idealMapMemLimit - netScheduledMapMem;
    finalReduceMemLimit=idealReduceMemLimit + unusedMapMemLimit;
    finalMapMemLimit=totalMemLimit - finalReduceMemLimit;
  }
 else {
    finalMapMemLimit=idealMapMemLimit;
    finalReduceMemLimit=idealReduceMemLimit;
  }
  LOG.info("completedMapPercent " + completedMapPercent + " totalMemLimit:"+ totalMemLimit+ " finalMapMemLimit:"+ finalMapMemLimit+ " finalReduceMemLimit:"+ finalReduceMemLimit+ " netScheduledMapMem:"+ netScheduledMapMem+ " netScheduledReduceMem:"+ netScheduledReduceMem);
  int rampUp=(finalReduceMemLimit - netScheduledReduceMem) / reduceResourceReqt;
  if (rampUp > 0) {
    rampUp=Math.min(rampUp,numPendingReduces);
    LOG.info("Ramping up " + rampUp);
    rampUpReduces(rampUp);
  }
 else   if (rampUp < 0) {
    int rampDown=-1 * rampUp;
    rampDown=Math.min(rampDown,scheduledReduces);
    LOG.info("Ramping down " + rampDown);
    rampDownReduces(rampDown);
  }
}
