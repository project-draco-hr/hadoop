{
  int stripeSize=10;
  int paritySize=4;
  ErasureCode ec=new ReedSolomonCode(stripeSize,paritySize);
  int symbolMax=(int)Math.pow(2,ec.symbolSize());
  byte[][] message=new byte[stripeSize][];
  int bufsize=1024 * 1024 * 10;
  for (int i=0; i < stripeSize; i++) {
    message[i]=new byte[bufsize];
    for (int j=0; j < bufsize; j++) {
      message[i][j]=(byte)RAND.nextInt(symbolMax);
    }
  }
  byte[][] parity=new byte[paritySize][];
  for (int i=0; i < paritySize; i++) {
    parity[i]=new byte[bufsize];
  }
  long encodeStart=System.currentTimeMillis();
  int[] tmpIn=new int[stripeSize];
  int[] tmpOut=new int[paritySize];
  for (int i=0; i < bufsize; i++) {
    for (int j=0; j < stripeSize; j++)     tmpIn[j]=0x000000FF & message[j][i];
    ec.encode(tmpIn,tmpOut);
    for (int j=0; j < paritySize; j++)     parity[j][i]=(byte)tmpOut[j];
  }
  long encodeEnd=System.currentTimeMillis();
  float encodeMSecs=(encodeEnd - encodeStart);
  System.out.println("Time to encode rs = " + encodeMSecs + "msec ("+ message[0].length / (1000 * encodeMSecs) + " MB/s)");
  int[] data=new int[paritySize + stripeSize];
  int[] erasedLocations=new int[]{4,1,5,7};
  int[] erasedValues=new int[erasedLocations.length];
  byte[] copy=new byte[bufsize];
  for (int j=0; j < bufsize; j++) {
    copy[j]=message[0][j];
    message[0][j]=0;
  }
  long decodeStart=System.currentTimeMillis();
  for (int i=0; i < bufsize; i++) {
    for (int j=0; j < paritySize; j++) {
      data[j]=0x000000FF & parity[j][i];
    }
    for (int j=1; j < stripeSize; j++) {
      data[j + paritySize]=0x000000FF & message[j][i];
    }
    ec.decode(data,erasedLocations,erasedValues);
    message[0][i]=(byte)erasedValues[0];
  }
  long decodeEnd=System.currentTimeMillis();
  float decodeMSecs=(decodeEnd - decodeStart);
  System.out.println("Time to decode = " + decodeMSecs + "msec ("+ message[0].length / (1000 * decodeMSecs) + " MB/s)");
  assertTrue("Decode failed",java.util.Arrays.equals(copy,message[0]));
}
