{
  while (true) {
    if (!keepRunning) {
      return;
    }
    try {
      AllocateResponse response;
      if (savedException != null) {
        LOG.error("Stopping callback due to: ",savedException);
        handler.onError(savedException);
        return;
      }
      try {
        response=responseQueue.take();
      }
 catch (      InterruptedException ex) {
        LOG.info("Interrupted while waiting for queue",ex);
        continue;
      }
      String collectorAddress=response.getCollectorAddr();
      TimelineClient timelineClient=client.getRegisteredTimelineClient();
      if (timelineClient != null && collectorAddress != null && !collectorAddress.isEmpty()) {
        if (collectorAddr == null || !collectorAddr.equals(collectorAddress)) {
          collectorAddr=collectorAddress;
          timelineClient.setTimelineServiceAddress(collectorAddress);
          LOG.info("collectorAddress " + collectorAddress);
        }
      }
      List<NodeReport> updatedNodes=response.getUpdatedNodes();
      if (!updatedNodes.isEmpty()) {
        handler.onNodesUpdated(updatedNodes);
      }
      List<ContainerStatus> completed=response.getCompletedContainersStatuses();
      if (!completed.isEmpty()) {
        handler.onContainersCompleted(completed);
      }
      if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {
        List<UpdatedContainer> changed=new ArrayList<>();
        changed.addAll(response.getUpdatedContainers());
        if (!changed.isEmpty()) {
          ((AMRMClientAsync.AbstractCallbackHandler)handler).onContainersUpdated(changed);
        }
      }
      List<Container> allocated=response.getAllocatedContainers();
      if (!allocated.isEmpty()) {
        handler.onContainersAllocated(allocated);
      }
      progress=handler.getProgress();
    }
 catch (    Throwable ex) {
      handler.onError(ex);
      throw new YarnRuntimeException(ex);
    }
  }
}
