{
  checkFormatted();
  checkRequest(reqInfo);
  long segmentTxId=segment.getStartTxId();
  Preconditions.checkArgument(segment.getEndTxId() > 0 && segment.getEndTxId() >= segmentTxId,"bad recovery state for segment %s: %s",segmentTxId,TextFormat.shortDebugString(segment));
  PersistedRecoveryPaxosData oldData=getPersistedPaxosData(segmentTxId);
  PersistedRecoveryPaxosData newData=PersistedRecoveryPaxosData.newBuilder().setAcceptedInEpoch(reqInfo.getEpoch()).setSegmentState(segment).build();
  if (oldData != null) {
    Preconditions.checkState(oldData.getAcceptedInEpoch() <= reqInfo.getEpoch(),"Bad paxos transition, out-of-order epochs.\nOld: %s\nNew: %s\n",oldData,newData);
  }
  SegmentStateProto currentSegment=getSegmentInfo(segmentTxId);
  if (currentSegment == null || currentSegment.getEndTxId() != segment.getEndTxId()) {
    if (currentSegment == null) {
      LOG.info("Synchronizing log " + TextFormat.shortDebugString(segment) + ": no current segment in place");
    }
 else {
      LOG.info("Synchronizing log " + TextFormat.shortDebugString(segment) + ": old segment "+ TextFormat.shortDebugString(currentSegment)+ " is not the right length");
      if (txnRange(currentSegment).contains(committedTxnId.get()) && !txnRange(segment).contains(committedTxnId.get())) {
        throw new AssertionError("Cannot replace segment " + TextFormat.shortDebugString(currentSegment) + " with new segment "+ TextFormat.shortDebugString(segment)+ ": would discard already-committed txn "+ committedTxnId.get());
      }
    }
    syncLog(reqInfo,segment,fromUrl);
  }
 else {
    LOG.info("Skipping download of log " + TextFormat.shortDebugString(segment) + ": already have up-to-date logs");
  }
  persistPaxosData(segmentTxId,newData);
  LOG.info("Accepted recovery for segment " + segmentTxId + ": "+ TextFormat.shortDebugString(newData));
}
