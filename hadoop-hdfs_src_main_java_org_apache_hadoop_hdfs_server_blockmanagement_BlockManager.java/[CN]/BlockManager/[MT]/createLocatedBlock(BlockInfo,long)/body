{
  if (blk instanceof BlockInfoUnderConstruction) {
    if (blk.isComplete()) {
      throw new IOException("blk instanceof BlockInfoUnderConstruction && blk.isComplete()" + ", blk=" + blk);
    }
    final BlockInfoUnderConstruction uc=(BlockInfoUnderConstruction)blk;
    final DatanodeDescriptor[] locations=uc.getExpectedLocations();
    final ExtendedBlock eb=new ExtendedBlock(namesystem.getBlockPoolId(),blk);
    return new LocatedBlock(eb,locations,pos,false);
  }
  final int numCorruptNodes=countNodes(blk).corruptReplicas();
  final int numCorruptReplicas=corruptReplicas.numCorruptReplicas(blk);
  if (numCorruptNodes != numCorruptReplicas) {
    LOG.warn("Inconsistent number of corrupt replicas for " + blk + " blockMap has "+ numCorruptNodes+ " but corrupt replicas map has "+ numCorruptReplicas);
  }
  final int numNodes=blocksMap.numNodes(blk);
  final boolean isCorrupt=numCorruptNodes == numNodes;
  final int numMachines=isCorrupt ? numNodes : numNodes - numCorruptNodes;
  final DatanodeDescriptor[] machines=new DatanodeDescriptor[numMachines];
  if (numMachines > 0) {
    int j=0;
    for (Iterator<DatanodeDescriptor> it=blocksMap.nodeIterator(blk); it.hasNext(); ) {
      final DatanodeDescriptor d=it.next();
      final boolean replicaCorrupt=corruptReplicas.isReplicaCorrupt(blk,d);
      if (isCorrupt || (!isCorrupt && !replicaCorrupt))       machines[j++]=d;
    }
  }
  final ExtendedBlock eb=new ExtendedBlock(namesystem.getBlockPoolId(),blk);
  return new LocatedBlock(eb,machines,pos,isCorrupt);
}
