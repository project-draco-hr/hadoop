{
  int numOfNodes;
  ArrayList<String> keyArray;
synchronized (recentInvalidateSets) {
    numOfNodes=recentInvalidateSets.size();
    keyArray=new ArrayList<String>(recentInvalidateSets.keySet());
  }
  nodesToProcess=Math.min(numOfNodes,nodesToProcess);
  int remainingNodes=numOfNodes - nodesToProcess;
  if (nodesToProcess < remainingNodes) {
    for (int i=0; i < nodesToProcess; i++) {
      int keyIndex=DFSUtil.getRandom().nextInt(numOfNodes - i) + i;
      Collections.swap(keyArray,keyIndex,i);
    }
  }
 else {
    for (int i=0; i < remainingNodes; i++) {
      int keyIndex=DFSUtil.getRandom().nextInt(numOfNodes - i);
      Collections.swap(keyArray,keyIndex,numOfNodes - i - 1);
    }
  }
  int blockCnt=0;
  for (int nodeCnt=0; nodeCnt < nodesToProcess; nodeCnt++) {
    blockCnt+=invalidateWorkForOneNode(keyArray.get(nodeCnt));
  }
  return blockCnt;
}
