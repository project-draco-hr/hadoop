{
  Priority priority=schedulerKey.getPriority();
  if (SchedulerAppUtils.isPlaceBlacklisted(application,node,LOG)) {
    application.updateAppSkipNodeDiagnostics(CSAMContainerLaunchDiagnosticsConstants.SKIP_AM_ALLOCATION_IN_BLACK_LISTED_NODE);
    ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(activitiesManager,node,application,priority,ActivityDiagnosticConstant.SKIP_BLACK_LISTED_NODE);
    return ContainerAllocation.APP_SKIPPED;
  }
  ResourceRequest anyRequest=application.getResourceRequest(schedulerKey,ResourceRequest.ANY);
  if (null == anyRequest) {
    ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(activitiesManager,node,application,priority,ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);
    return ContainerAllocation.PRIORITY_SKIPPED;
  }
  Resource required=anyRequest.getCapability();
  if (application.getTotalRequiredResources(schedulerKey) <= 0) {
    ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(activitiesManager,node,application,priority,ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);
    return ContainerAllocation.PRIORITY_SKIPPED;
  }
  if (schedulingMode == SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {
    if (application.isWaitingForAMContainer()) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Skip allocating AM container to app_attempt=" + application.getApplicationAttemptId() + ", don't allow to allocate AM container in non-exclusive mode");
      }
      application.updateAppSkipNodeDiagnostics("Skipping assigning to Node in Ignore Exclusivity mode. ");
      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(activitiesManager,node,application,priority,ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);
      return ContainerAllocation.APP_SKIPPED;
    }
  }
  if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(anyRequest.getNodeLabelExpression(),node.getPartition(),schedulingMode)) {
    ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(activitiesManager,node,application,priority,ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);
    return ContainerAllocation.PRIORITY_SKIPPED;
  }
  if (!application.getCSLeafQueue().getReservationContinueLooking()) {
    if (!shouldAllocOrReserveNewContainer(schedulerKey,required)) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("doesn't need containers based on reservation algo!");
      }
      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(activitiesManager,node,application,priority,ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);
      return ContainerAllocation.PRIORITY_SKIPPED;
    }
  }
  if (!checkHeadroom(clusterResource,resourceLimits,required,node)) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("cannot allocate required resource=" + required + " because of headroom");
    }
    ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(activitiesManager,node,application,priority,ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);
    return ContainerAllocation.QUEUE_SKIPPED;
  }
  application.addSchedulingOpportunity(schedulerKey);
  int missedNonPartitionedRequestSchedulingOpportunity=0;
  if (anyRequest.getNodeLabelExpression().equals(RMNodeLabelsManager.NO_LABEL)) {
    missedNonPartitionedRequestSchedulingOpportunity=application.addMissedNonPartitionedRequestSchedulingOpportunity(schedulerKey);
  }
  if (schedulingMode == SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {
    if (missedNonPartitionedRequestSchedulingOpportunity < rmContext.getScheduler().getNumClusterNodes()) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Skip app_attempt=" + application.getApplicationAttemptId() + " priority="+ schedulerKey.getPriority()+ " because missed-non-partitioned-resource-request"+ " opportunity under requred:"+ " Now="+ missedNonPartitionedRequestSchedulingOpportunity+ " required="+ rmContext.getScheduler().getNumClusterNodes());
      }
      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(activitiesManager,node,application,priority,ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);
      return ContainerAllocation.APP_SKIPPED;
    }
  }
  return null;
}
