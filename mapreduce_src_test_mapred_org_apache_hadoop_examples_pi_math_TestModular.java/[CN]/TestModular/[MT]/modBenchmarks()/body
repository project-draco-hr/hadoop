{
  final Timer t=new Timer(false);
  t.tick("modBenchmarks()");
  final long[][][] en=generateEN(10000,10);
  t.tick("generateEN");
  for (int i=0; i < en.length; i++) {
    final long n=en[i][0][0];
    for (int j=1; j < en[i].length; j++) {
      final long e=en[i][j][0];
      final long answer=en[i][j][1];
      final long s=Modular.mod(e,n);
      if (s != answer)       assertEquals("e=" + e + ", n="+ n+ ", answer="+ answer+ " but s="+ s,answer,s);
    }
  }
  t.tick("Modular.mod");
  final Montgomery2 m2=new Montgomery2();
  for (int i=0; i < en.length; i++) {
    final long n=en[i][0][0];
    m2.set(n);
    for (int j=1; j < en[i].length; j++) {
      final long e=en[i][j][0];
      final long answer=en[i][j][1];
      final long s=m2.mod(e);
      if (s != answer)       assertEquals("e=" + e + ", n="+ n+ ", answer="+ answer+ " but s="+ s,answer,s);
    }
  }
  t.tick("montgomery.mod");
  for (int i=0; i < en.length; i++) {
    final long n=en[i][0][0];
    m2.set(n);
    for (int j=1; j < en[i].length; j++) {
      final long e=en[i][j][0];
      final long answer=en[i][j][1];
      final long s=m2.mod2(e);
      if (s != answer)       assertEquals("e=" + e + ", n="+ n+ ", answer="+ answer+ " but s="+ s,answer,s);
    }
  }
  t.tick("montgomery.mod2");
  for (int i=0; i < en.length; i++) {
    final long n=en[i][0][0];
    final BigInteger N=BigInteger.valueOf(n);
    for (int j=1; j < en[i].length; j++) {
      final long e=en[i][j][0];
      final long answer=en[i][j][1];
      final long s=TWO.modPow(BigInteger.valueOf(e),N).longValue();
      if (s != answer)       assertEquals("e=" + e + ", n="+ n+ ", answer="+ answer+ " but s="+ s,answer,s);
    }
  }
  t.tick("BigInteger.modPow(e, n)");
}
