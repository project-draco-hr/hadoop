{
  if (NativeCrc32.isAvailable()) {
    NativeCrc32.verifyChunkedSumsByteArray(bytesPerChecksum,type.id,checksums,checksumsOff,data,dataOff,dataLen,fileName,basePos);
    return;
  }
  int remaining=dataLen;
  int dataPos=0;
  while (remaining > 0) {
    int n=Math.min(remaining,bytesPerChecksum);
    summer.reset();
    summer.update(data,dataOff + dataPos,n);
    dataPos+=n;
    remaining-=n;
    int calculated=(int)summer.getValue();
    int stored=(checksums[checksumsOff] << 24 & 0xff000000) | (checksums[checksumsOff + 1] << 16 & 0xff0000) | (checksums[checksumsOff + 2] << 8 & 0xff00)| checksums[checksumsOff + 3] & 0xff;
    checksumsOff+=4;
    if (calculated != stored) {
      long errPos=basePos + dataPos - n;
      throw new ChecksumException("Checksum error: " + fileName + " at "+ errPos+ " exp: "+ stored+ " got: "+ calculated,errPos);
    }
  }
}
