{
  if (type.size == 0)   return;
  if (data.hasArray() && checksums.hasArray()) {
    verifyChunkedSums(data.array(),data.arrayOffset() + data.position(),data.remaining(),checksums.array(),checksums.arrayOffset() + checksums.position(),fileName,basePos);
    return;
  }
  if (NativeCrc32.isAvailable()) {
    NativeCrc32.verifyChunkedSums(bytesPerChecksum,type.id,checksums,data,fileName,basePos);
    return;
  }
  int startDataPos=data.position();
  data.mark();
  checksums.mark();
  try {
    byte[] buf=new byte[bytesPerChecksum];
    byte[] sum=new byte[type.size];
    while (data.remaining() > 0) {
      int n=Math.min(data.remaining(),bytesPerChecksum);
      checksums.get(sum);
      data.get(buf,0,n);
      summer.reset();
      summer.update(buf,0,n);
      int calculated=(int)summer.getValue();
      int stored=(sum[0] << 24 & 0xff000000) | (sum[1] << 16 & 0xff0000) | (sum[2] << 8 & 0xff00)| sum[3] & 0xff;
      if (calculated != stored) {
        long errPos=basePos + data.position() - startDataPos - n;
        throw new ChecksumException("Checksum error: " + fileName + " at "+ errPos+ " exp: "+ stored+ " got: "+ calculated,errPos);
      }
    }
  }
  finally {
    data.reset();
    checksums.reset();
  }
}
