{
  Reducer<INKEY,INVALUE,OUTKEY,OUTVALUE> reducer=ReflectionUtils.newInstance(job.getReducerClass(),job);
  String finalName=getOutputName(getPartition());
  FileSystem fs=FileSystem.get(job);
  final RecordWriter<OUTKEY,OUTVALUE> out=job.getOutputFormat().getRecordWriter(fs,job,finalName,reporter);
  OutputCollector<OUTKEY,OUTVALUE> collector=new OutputCollector<OUTKEY,OUTVALUE>(){
    public void collect(    OUTKEY key,    OUTVALUE value) throws IOException {
      out.write(key,value);
      reduceOutputCounter.increment(1);
      reporter.progress();
    }
  }
;
  try {
    boolean incrProcCount=SkipBadRecords.getReducerMaxSkipGroups(job) > 0 && SkipBadRecords.getAutoIncrReducerProcCount(job);
    ReduceValuesIterator<INKEY,INVALUE> values=isSkipping() ? new SkippingReduceValuesIterator<INKEY,INVALUE>(rIter,comparator,keyClass,valueClass,job,reporter,umbilical) : new ReduceValuesIterator<INKEY,INVALUE>(rIter,job.getOutputValueGroupingComparator(),keyClass,valueClass,job,reporter);
    values.informReduceProgress();
    while (values.more()) {
      reduceInputKeyCounter.increment(1);
      reducer.reduce(values.getKey(),values,collector,reporter);
      if (incrProcCount) {
        reporter.incrCounter(SkipBadRecords.COUNTER_GROUP,SkipBadRecords.COUNTER_REDUCE_PROCESSED_GROUPS,1);
      }
      values.nextKey();
      values.informReduceProgress();
    }
    reducer.close();
    out.close(reporter);
  }
 catch (  IOException ioe) {
    try {
      reducer.close();
    }
 catch (    IOException ignored) {
    }
    try {
      out.close(reporter);
    }
 catch (    IOException ignored) {
    }
    throw ioe;
  }
}
