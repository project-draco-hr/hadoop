{
  FileInputStream fis[]=fileInputStreamCache.get(chosenNode,block);
  if (fis != null) {
    if (DFSClient.LOG.isDebugEnabled()) {
      DFSClient.LOG.debug("got FileInputStreams for " + block + " from "+ "the FileInputStreamCache.");
    }
    return new BlockReaderLocal.Builder(dfsClient.getConf()).setFilename(file).setBlock(block).setStartOffset(startOffset).setStreams(fis).setDatanodeID(chosenNode).setVerifyChecksum(verifyChecksum).setBlockMetadataHeader(BlockMetadataHeader.preadHeader(fis[1].getChannel())).setFileInputStreamCache(fileInputStreamCache).setCachingStrategy(curCachingStrategy).build();
  }
  if ((dfsClient.useLegacyBlockReaderLocal()) && DFSClient.isLocalAddress(dnAddr) && (!shortCircuitForbidden())) {
    try {
      return BlockReaderFactory.getLegacyBlockReaderLocal(dfsClient,clientName,block,blockToken,chosenNode,startOffset);
    }
 catch (    IOException e) {
      DFSClient.LOG.warn("error creating legacy BlockReaderLocal.  " + "Disabling legacy local reads.",e);
      dfsClient.disableLegacyBlockReaderLocal();
    }
  }
  int cacheTries=0;
  DomainSocketFactory dsFactory=dfsClient.getDomainSocketFactory();
  BlockReader reader=null;
  final int nCachedConnRetry=dfsClient.getConf().nCachedConnRetry;
  for (; cacheTries < nCachedConnRetry; ++cacheTries) {
    Peer peer=peerCache.get(chosenNode,true);
    if (peer == null)     break;
    try {
      boolean allowShortCircuitLocalReads=dfsClient.getConf().shortCircuitLocalReads && (!shortCircuitForbidden());
      reader=BlockReaderFactory.newBlockReader(dfsClient.getConf(),file,block,blockToken,startOffset,len,verifyChecksum,clientName,peer,chosenNode,dsFactory,peerCache,fileInputStreamCache,allowShortCircuitLocalReads,curCachingStrategy);
      return reader;
    }
 catch (    IOException ex) {
      DFSClient.LOG.debug("Error making BlockReader with DomainSocket. " + "Closing stale " + peer,ex);
    }
 finally {
      if (reader == null) {
        IOUtils.closeQuietly(peer);
      }
    }
  }
  DomainSocket domSock=dsFactory.create(dnAddr,this);
  if (domSock != null) {
    Peer peer=new DomainPeer(domSock);
    try {
      boolean allowShortCircuitLocalReads=dfsClient.getConf().shortCircuitLocalReads && (!shortCircuitForbidden());
      reader=BlockReaderFactory.newBlockReader(dfsClient.getConf(),file,block,blockToken,startOffset,len,verifyChecksum,clientName,peer,chosenNode,dsFactory,peerCache,fileInputStreamCache,allowShortCircuitLocalReads,curCachingStrategy);
      return reader;
    }
 catch (    IOException e) {
      DFSClient.LOG.warn("failed to connect to " + domSock,e);
    }
 finally {
      if (reader == null) {
        dsFactory.disableDomainSocketPath(domSock.getPath());
        IOUtils.closeQuietly(peer);
      }
    }
  }
  for (; cacheTries < nCachedConnRetry; ++cacheTries) {
    Peer peer=peerCache.get(chosenNode,false);
    if (peer == null)     break;
    try {
      reader=BlockReaderFactory.newBlockReader(dfsClient.getConf(),file,block,blockToken,startOffset,len,verifyChecksum,clientName,peer,chosenNode,dsFactory,peerCache,fileInputStreamCache,false,curCachingStrategy);
      return reader;
    }
 catch (    IOException ex) {
      DFSClient.LOG.debug("Error making BlockReader. Closing stale " + peer,ex);
    }
 finally {
      if (reader == null) {
        IOUtils.closeQuietly(peer);
      }
    }
  }
  if (tcpReadsDisabledForTesting) {
    throw new IOException("TCP reads are disabled.");
  }
  Peer peer=newTcpPeer(dnAddr);
  try {
    reader=BlockReaderFactory.newBlockReader(dfsClient.getConf(),file,block,blockToken,startOffset,len,verifyChecksum,clientName,peer,chosenNode,dsFactory,peerCache,fileInputStreamCache,false,curCachingStrategy);
    return reader;
  }
 catch (  IOException ex) {
    DFSClient.LOG.debug("Exception while getting block reader, closing stale " + peer,ex);
    throw ex;
  }
 finally {
    if (reader == null) {
      IOUtils.closeQuietly(peer);
    }
  }
}
