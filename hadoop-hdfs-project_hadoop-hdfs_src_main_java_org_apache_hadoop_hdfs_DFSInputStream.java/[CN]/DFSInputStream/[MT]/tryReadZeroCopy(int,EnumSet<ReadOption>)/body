{
  long blockEnd32=Math.min(Integer.MAX_VALUE,blockEnd);
  long curPos=pos;
  long blockLeft=blockEnd32 - curPos + 1;
  if (blockLeft <= 0) {
    if (DFSClient.LOG.isDebugEnabled()) {
      DFSClient.LOG.debug("unable to perform a zero-copy read from offset " + curPos + " of "+ src+ "; blockLeft = "+ blockLeft+ "; blockEnd32 = "+ blockEnd32+ ", blockEnd = "+ blockEnd+ "; maxLength = "+ maxLength);
    }
    return null;
  }
  int length=Math.min((int)blockLeft,maxLength);
  long blockStartInFile=currentLocatedBlock.getStartOffset();
  long blockPos=curPos - blockStartInFile;
  long limit=blockPos + length;
  ClientMmap clientMmap=blockReader.getClientMmap(opts);
  if (clientMmap == null) {
    if (DFSClient.LOG.isDebugEnabled()) {
      DFSClient.LOG.debug("unable to perform a zero-copy read from offset " + curPos + " of "+ src+ "; BlockReader#getClientMmap returned "+ "null.");
    }
    return null;
  }
  boolean success=false;
  ByteBuffer buffer;
  try {
    seek(pos + length);
    buffer=clientMmap.getMappedByteBuffer().asReadOnlyBuffer();
    buffer.position((int)blockPos);
    buffer.limit((int)limit);
    extendedReadBuffers.put(buffer,clientMmap);
    readStatistics.addZeroCopyBytes(length);
    if (DFSClient.LOG.isDebugEnabled()) {
      DFSClient.LOG.debug("readZeroCopy read " + maxLength + " bytes from "+ "offset "+ curPos+ " via the zero-copy read path.  "+ "blockEnd = "+ blockEnd);
    }
    success=true;
  }
  finally {
    if (!success) {
      IOUtils.closeQuietly(clientMmap);
    }
  }
  return buffer;
}
