{
  Server server;
  final TestRpcService proxy;
  boolean succeeded=false;
  final int numClients=1;
  final int queueSizePerHandler=3;
  GenericTestUtils.setLogLevel(DecayRpcScheduler.LOG,Level.DEBUG);
  GenericTestUtils.setLogLevel(RPC.LOG,Level.DEBUG);
  final List<Future<Void>> res=new ArrayList<Future<Void>>();
  final ExecutorService executorService=Executors.newFixedThreadPool(numClients);
  conf.setInt(CommonConfigurationKeys.IPC_CLIENT_CONNECT_MAX_RETRIES_KEY,0);
  final String ns=CommonConfigurationKeys.IPC_NAMESPACE + ".0.";
  conf.setBoolean(ns + CommonConfigurationKeys.IPC_BACKOFF_ENABLE,true);
  conf.setStrings(ns + CommonConfigurationKeys.IPC_CALLQUEUE_IMPL_KEY,"org.apache.hadoop.ipc.FairCallQueue");
  conf.setStrings(ns + CommonConfigurationKeys.IPC_SCHEDULER_IMPL_KEY,"org.apache.hadoop.ipc.DecayRpcScheduler");
  conf.setInt(ns + CommonConfigurationKeys.IPC_SCHEDULER_PRIORITY_LEVELS_KEY,2);
  conf.setBoolean(ns + DecayRpcScheduler.IPC_DECAYSCHEDULER_BACKOFF_RESPONSETIME_ENABLE_KEY,true);
  conf.set(ns + DecayRpcScheduler.IPC_DECAYSCHEDULER_BACKOFF_RESPONSETIME_THRESHOLDS_KEY,"2s, 4s");
  RPC.Builder builder=newServerBuilder(conf).setQueueSizePerHandler(queueSizePerHandler).setNumHandlers(1).setVerbose(true);
  server=setupTestServer(builder);
  @SuppressWarnings("unchecked") CallQueueManager<Call> spy=spy((CallQueueManager<Call>)Whitebox.getInternalState(server,"callQueue"));
  Whitebox.setInternalState(server,"callQueue",spy);
  Exception lastException=null;
  proxy=getClient(addr,conf);
  try {
    for (int i=0; i < numClients; i++) {
      res.add(executorService.submit(new Callable<Void>(){
        @Override public Void call() throws ServiceException, InterruptedException {
          proxy.sleep(null,newSleepRequest(3000));
          return null;
        }
      }
));
      verify(spy,timeout(500).times(i + 1)).offer(Mockito.<Call>anyObject());
    }
    try {
      Thread.sleep(5500);
      proxy.sleep(null,newSleepRequest(100));
    }
 catch (    ServiceException e) {
      RemoteException re=(RemoteException)e.getCause();
      IOException unwrapExeption=re.unwrapRemoteException();
      if (unwrapExeption instanceof RetriableException) {
        succeeded=true;
      }
 else {
        lastException=unwrapExeption;
      }
    }
  }
  finally {
    executorService.shutdown();
    stop(server,proxy);
  }
  if (lastException != null) {
    LOG.error("Last received non-RetriableException:",lastException);
  }
  assertTrue("RetriableException not received",succeeded);
}
