{
  Server server;
  final TestRpcService proxy;
  boolean succeeded=false;
  final int numClients=2;
  final List<Future<Void>> res=new ArrayList<Future<Void>>();
  final ExecutorService executorService=Executors.newFixedThreadPool(numClients);
  conf.setInt(CommonConfigurationKeys.IPC_CLIENT_CONNECT_MAX_RETRIES_KEY,0);
  conf.setBoolean(CommonConfigurationKeys.IPC_CALLQUEUE_NAMESPACE + ".0." + CommonConfigurationKeys.IPC_BACKOFF_ENABLE,true);
  RPC.Builder builder=newServerBuilder(conf).setQueueSizePerHandler(1).setNumHandlers(1).setVerbose(true);
  server=setupTestServer(builder);
  @SuppressWarnings("unchecked") CallQueueManager<Call> spy=spy((CallQueueManager<Call>)Whitebox.getInternalState(server,"callQueue"));
  Whitebox.setInternalState(server,"callQueue",spy);
  Exception lastException=null;
  proxy=getClient(addr,conf);
  try {
    for (int i=0; i < numClients; i++) {
      res.add(executorService.submit(new Callable<Void>(){
        @Override public Void call() throws ServiceException, InterruptedException {
          proxy.sleep(null,newSleepRequest(100000));
          return null;
        }
      }
));
      verify(spy,timeout(500).times(i + 1)).offer(Mockito.<Call>anyObject());
    }
    try {
      proxy.sleep(null,newSleepRequest(100));
    }
 catch (    ServiceException e) {
      RemoteException re=(RemoteException)e.getCause();
      IOException unwrapExeption=re.unwrapRemoteException();
      if (unwrapExeption instanceof RetriableException) {
        succeeded=true;
      }
 else {
        lastException=unwrapExeption;
      }
    }
  }
  finally {
    executorService.shutdown();
    stop(server,proxy);
  }
  if (lastException != null) {
    LOG.error("Last received non-RetriableException:",lastException);
  }
  assertTrue("RetriableException not received",succeeded);
}
