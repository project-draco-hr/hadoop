{
  final int width=findWidth(startSize + numModifications);
  System.out.println("\nstartSize=" + startSize + ", numModifications="+ numModifications+ ", width="+ width);
  final List<INode> previous=new ArrayList<INode>();
  int n=0;
  for (; n < startSize; n++) {
    previous.add(newINode(n,width));
  }
  final List<INode> current=new ArrayList<INode>(previous);
  final Diff[] diffs=new Diff[5];
  for (int j=0; j < diffs.length; j++) {
    diffs[j]=new Diff();
  }
  for (int m=0; m < numModifications; m++) {
    final int j=m * diffs.length / numModifications;
    final int nextOperation=current.isEmpty() ? 1 : RANDOM.nextInt(3) + 1;
switch (nextOperation) {
case 1:
{
        final INode i=newINode(n++,width);
        create(i,current,diffs[j]);
        break;
      }
case 2:
{
      final INode i=current.get(RANDOM.nextInt(current.size()));
      delete(i,current,diffs[j]);
      break;
    }
case 3:
{
    final INode i=current.get(RANDOM.nextInt(current.size()));
    modify(i,current,diffs[j]);
    break;
  }
}
}
{
List<INode> c=previous;
for (int i=0; i < diffs.length; i++) {
c=diffs[i].apply2Previous(c);
}
if (!hasIdenticalElements(current,c)) {
System.out.println("previous = " + Diff.toString(previous));
System.out.println();
System.out.println("current  = " + Diff.toString(current));
System.out.println("c        = " + Diff.toString(c));
throw new AssertionError("current and c are not identical.");
}
List<INode> p=current;
for (int i=diffs.length - 1; i >= 0; i--) {
p=diffs[i].apply2Current(p);
}
if (!hasIdenticalElements(previous,p)) {
System.out.println("previous = " + Diff.toString(previous));
System.out.println("p        = " + Diff.toString(p));
System.out.println();
System.out.println("current  = " + Diff.toString(current));
throw new AssertionError("previous and p are not identical.");
}
}
final Diff combined=diffs[0];
for (int i=1; i < diffs.length; i++) {
combined.combinePostDiff(diffs[i],null,false);
}
{
final List<INode> c=combined.apply2Previous(previous);
if (!hasIdenticalElements(current,c)) {
System.out.println("previous = " + Diff.toString(previous));
System.out.println();
System.out.println("current  = " + Diff.toString(current));
System.out.println("c        = " + Diff.toString(c));
throw new AssertionError("current and c are not identical.");
}
final List<INode> p=combined.apply2Current(current);
if (!hasIdenticalElements(previous,p)) {
System.out.println("previous = " + Diff.toString(previous));
System.out.println("p        = " + Diff.toString(p));
System.out.println();
System.out.println("current  = " + Diff.toString(current));
throw new AssertionError("previous and p are not identical.");
}
}
{
for (int m=0; m < n; m++) {
final INode inode=newINode(m,width);
{
  final INode[] array=combined.accessPrevious(inode.getLocalNameBytes());
  final INode computed;
  if (array != null) {
    computed=array[0];
  }
 else {
    final int i=Diff.search(current,inode);
    computed=i < 0 ? null : current.get(i);
  }
  final int j=Diff.search(previous,inode);
  final INode expected=j < 0 ? null : previous.get(j);
  Assert.assertTrue(computed == expected);
}
{
  final INode[] array=combined.accessCurrent(inode.getLocalNameBytes());
  final INode computed;
  if (array != null) {
    computed=array[0];
  }
 else {
    final int i=Diff.search(previous,inode);
    computed=i < 0 ? null : previous.get(i);
  }
  final int j=Diff.search(current,inode);
  final INode expected=j < 0 ? null : current.get(j);
  Assert.assertTrue(computed == expected);
}
}
}
}
