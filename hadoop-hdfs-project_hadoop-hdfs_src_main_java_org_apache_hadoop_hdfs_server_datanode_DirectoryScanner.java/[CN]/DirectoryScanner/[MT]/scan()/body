{
  clear();
  Map<String,ScanInfo[]> diskReport=getDiskReport();
  try (AutoCloseableLock lock=dataset.acquireDatasetLock()){
    for (    Entry<String,ScanInfo[]> entry : diskReport.entrySet()) {
      String bpid=entry.getKey();
      ScanInfo[] blockpoolReport=entry.getValue();
      Stats statsRecord=new Stats(bpid);
      stats.put(bpid,statsRecord);
      LinkedList<ScanInfo> diffRecord=new LinkedList<ScanInfo>();
      diffs.put(bpid,diffRecord);
      statsRecord.totalBlocks=blockpoolReport.length;
      List<ReplicaInfo> bl=dataset.getFinalizedBlocks(bpid);
      ReplicaInfo[] memReport=bl.toArray(new ReplicaInfo[bl.size()]);
      Arrays.sort(memReport);
      int d=0;
      int m=0;
      while (m < memReport.length && d < blockpoolReport.length) {
        ReplicaInfo memBlock=memReport[m];
        ScanInfo info=blockpoolReport[d];
        if (info.getBlockId() < memBlock.getBlockId()) {
          if (!dataset.isDeletingBlock(bpid,info.getBlockId())) {
            statsRecord.missingMemoryBlocks++;
            addDifference(diffRecord,statsRecord,info);
          }
          d++;
          continue;
        }
        if (info.getBlockId() > memBlock.getBlockId()) {
          addDifference(diffRecord,statsRecord,memBlock.getBlockId(),info.getVolume());
          m++;
          continue;
        }
        if (info.getBlockFile() == null) {
          addDifference(diffRecord,statsRecord,info);
        }
 else         if (info.getGenStamp() != memBlock.getGenerationStamp() || info.getBlockFileLength() != memBlock.getNumBytes()) {
          statsRecord.mismatchBlocks++;
          addDifference(diffRecord,statsRecord,info);
        }
 else         if (memBlock.compareWith(info) != 0) {
          statsRecord.duplicateBlocks++;
          addDifference(diffRecord,statsRecord,info);
        }
        d++;
        if (d < blockpoolReport.length) {
          ScanInfo nextInfo=blockpoolReport[Math.min(d,blockpoolReport.length - 1)];
          if (nextInfo.getBlockId() != info.blockId) {
            ++m;
          }
        }
 else {
          ++m;
        }
      }
      while (m < memReport.length) {
        ReplicaInfo current=memReport[m++];
        addDifference(diffRecord,statsRecord,current.getBlockId(),current.getVolume());
      }
      while (d < blockpoolReport.length) {
        if (!dataset.isDeletingBlock(bpid,blockpoolReport[d].getBlockId())) {
          statsRecord.missingMemoryBlocks++;
          addDifference(diffRecord,statsRecord,blockpoolReport[d]);
        }
        d++;
      }
      LOG.info(statsRecord.toString());
    }
  }
 }
