{
  this.conf=conf;
  this.appMasterMainClass=appMasterMainClass;
  yarnClient=YarnClient.createYarnClient();
  yarnClient.init(conf);
  opts=new Options();
  opts.addOption("appname",true,"Application Name. Default value - DistributedShell");
  opts.addOption("priority",true,"Application Priority. Default 0");
  opts.addOption("queue",true,"RM Queue in which this application is to be submitted");
  opts.addOption("timeout",true,"Application timeout in milliseconds");
  opts.addOption("master_memory",true,"Amount of memory in MB to be requested to run the application master");
  opts.addOption("master_vcores",true,"Amount of virtual cores to be requested to run the application master");
  opts.addOption("jar",true,"Jar file containing the application master");
  opts.addOption("shell_command",true,"Shell command to be executed by " + "the Application Master. Can only specify either --shell_command " + "or --shell_script");
  opts.addOption("shell_script",true,"Location of the shell script to be " + "executed. Can only specify either --shell_command or --shell_script");
  opts.addOption("shell_args",true,"Command line args for the shell script." + "Multiple args can be separated by empty space.");
  opts.getOption("shell_args").setArgs(Option.UNLIMITED_VALUES);
  opts.addOption("shell_env",true,"Environment for shell script. Specified as env_key=env_val pairs");
  opts.addOption("shell_cmd_priority",true,"Priority for the shell command containers");
  opts.addOption("container_memory",true,"Amount of memory in MB to be requested to run the shell command");
  opts.addOption("container_vcores",true,"Amount of virtual cores to be requested to run the shell command");
  opts.addOption("num_containers",true,"No. of containers on which the shell command needs to be executed");
  opts.addOption("log_properties",true,"log4j.properties file");
  opts.addOption("timeline_service_version",true,"Version for timeline service");
  opts.addOption("keep_containers_across_application_attempts",false,"Flag to indicate whether to keep containers across application attempts." + " If the flag is true, running containers will not be killed when" + " application attempt fails and these containers will be retrieved by"+ " the new application attempt ");
  opts.addOption("attempt_failures_validity_interval",true,"when attempt_failures_validity_interval in milliseconds is set to > 0," + "the failure number will not take failures which happen out of " + "the validityInterval into failure count. "+ "If failure count reaches to maxAppAttempts, "+ "the application will be failed.");
  opts.addOption("debug",false,"Dump out debug information");
  opts.addOption("domain",true,"ID of the timeline domain where the " + "timeline entities will be put");
  opts.addOption("view_acls",true,"Users and groups that allowed to " + "view the timeline entities in the given domain");
  opts.addOption("modify_acls",true,"Users and groups that allowed to " + "modify the timeline entities in the given domain");
  opts.addOption("create",false,"Flag to indicate whether to create the " + "domain specified with -domain.");
  opts.addOption("help",false,"Print usage");
  opts.addOption("node_label_expression",true,"Node label expression to determine the nodes" + " where all the containers of this application" + " will be allocated, \"\" means containers"+ " can be allocated anywhere, if you don't specify the option,"+ " default node_label_expression of queue will be used.");
  opts.addOption("container_retry_policy",true,"Retry policy when container fails to run, " + "0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, " + "2: RETRY_ON_SPECIFIC_ERROR_CODES");
  opts.addOption("container_retry_error_codes",true,"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error " + "codes is specified with this option, " + "e.g. --container_retry_error_codes 1,2,3");
  opts.addOption("container_max_retries",true,"If container could retry, it specifies max retires");
  opts.addOption("container_retry_interval",true,"Interval between each retry, unit is milliseconds");
}
