{
  FSImage spyImage1=NameNodeAdapter.spyOnFsImage(nns[1]);
  DelayAnswer answerer=new DelayAnswer(LOG);
  Mockito.doAnswer(answerer).when(spyImage1).saveNamespace(Mockito.any(FSNamesystem.class),Mockito.any(NameNodeFile.class),Mockito.any(Canceler.class));
  doEdits(0,1000);
  nns[0].getRpcServer().rollEditLog();
  answerer.waitForCall();
  assertTrue("SBN is not performing checkpoint but it should be.",answerer.getFireCount() == 1 && answerer.getResultCount() == 0);
  ThreadUtil.sleepAtLeastIgnoreInterrupts(1000);
  Thread t=new Thread(){
    @Override public void run(){
      try {
        nns[1].getRpcServer().restoreFailedStorage("false");
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
;
  t.start();
  ThreadUtil.sleepAtLeastIgnoreInterrupts(1000);
  assertFalse(nns[1].getNamesystem().getFsLockForTests().hasQueuedThreads());
  assertFalse(nns[1].getNamesystem().getFsLockForTests().isWriteLocked());
  assertTrue(nns[1].getNamesystem().getCpLockForTests().hasQueuedThreads());
  String pageContents=DFSTestUtil.urlGet(new URL("http://" + nns[1].getHttpAddress().getHostName() + ":"+ nns[1].getHttpAddress().getPort()+ "/jmx"));
  assertTrue(pageContents.contains("NumLiveDataNodes"));
  assertTrue("SBN should have still been checkpointing.",answerer.getFireCount() == 1 && answerer.getResultCount() == 0);
  answerer.proceed();
  answerer.waitForResult();
  assertTrue("SBN should have finished checkpointing.",answerer.getFireCount() == 1 && answerer.getResultCount() == 1);
  t.join();
}
