{
  if (!this.initialized) {
    this.conf=new FairSchedulerConfiguration(conf);
    this.rootMetrics=QueueMetrics.forQueue("root",null,true,conf);
    this.containerTokenSecretManager=containerTokenSecretManager;
    this.rmContext=rmContext;
    this.clock=new SystemClock();
    this.eventLog=new FairSchedulerEventLog();
    eventLog.init(this.conf);
    minimumAllocation=this.conf.getMinimumMemoryAllocation();
    maximumAllocation=this.conf.getMaximumMemoryAllocation();
    userAsDefaultQueue=this.conf.getUserAsDefaultQueue();
    nodeLocalityThreshold=this.conf.getLocalityThresholdNode();
    rackLocalityThreshold=this.conf.getLocalityThresholdRack();
    preemptionEnabled=this.conf.getPreemptionEnabled();
    assignMultiple=this.conf.getAssignMultiple();
    maxAssign=this.conf.getMaxAssign();
    Thread updateThread=new Thread(new UpdateThread());
    updateThread.start();
    initialized=true;
    sizeBasedWeight=this.conf.getSizeBasedWeight();
    queueMgr=new QueueManager(this);
    try {
      queueMgr.initialize();
    }
 catch (    Exception e) {
      throw new IOException("Failed to start FairScheduler",e);
    }
  }
 else {
    this.conf=new FairSchedulerConfiguration(conf);
    userAsDefaultQueue=this.conf.getUserAsDefaultQueue();
    nodeLocalityThreshold=this.conf.getLocalityThresholdNode();
    rackLocalityThreshold=this.conf.getLocalityThresholdRack();
    preemptionEnabled=this.conf.getPreemptionEnabled();
    try {
      queueMgr.reloadAllocs();
    }
 catch (    Exception e) {
      throw new IOException("Failed to initialize FairScheduler",e);
    }
  }
}
