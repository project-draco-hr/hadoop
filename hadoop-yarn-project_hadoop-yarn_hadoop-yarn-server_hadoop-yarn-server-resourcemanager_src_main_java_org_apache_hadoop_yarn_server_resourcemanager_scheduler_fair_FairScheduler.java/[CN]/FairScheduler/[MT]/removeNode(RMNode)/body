{
  FSSchedulerNode node=getFSSchedulerNode(rmNode.getNodeID());
  if (node == null) {
    return;
  }
  Resources.subtractFrom(clusterResource,rmNode.getTotalCapability());
  updateRootQueueMetrics();
  triggerUpdate();
  List<RMContainer> runningContainers=node.getRunningContainers();
  for (  RMContainer container : runningContainers) {
    completedContainer(container,SchedulerUtils.createAbnormalContainerStatus(container.getContainerId(),SchedulerUtils.LOST_CONTAINER),RMContainerEventType.KILL);
  }
  RMContainer reservedContainer=node.getReservedContainer();
  if (reservedContainer != null) {
    completedContainer(reservedContainer,SchedulerUtils.createAbnormalContainerStatus(reservedContainer.getContainerId(),SchedulerUtils.LOST_CONTAINER),RMContainerEventType.KILL);
  }
  nodes.remove(rmNode.getNodeID());
  String rackName=node.getRackName() == null ? "NULL" : node.getRackName();
  if (nodesPerRack.containsKey(rackName) && (nodesPerRack.get(rackName) > 0)) {
    nodesPerRack.put(rackName,nodesPerRack.get(rackName) - 1);
  }
 else {
    LOG.error("Node [" + rmNode.getNodeAddress() + "] being removed from"+ " unknown rack ["+ rackName+ "] !!");
  }
  queueMgr.getRootQueue().setSteadyFairShare(clusterResource);
  queueMgr.getRootQueue().recomputeSteadyShares();
  updateMaximumAllocation(node,false);
  LOG.info("Removed node " + rmNode.getNodeAddress() + " cluster capacity: "+ clusterResource);
}
