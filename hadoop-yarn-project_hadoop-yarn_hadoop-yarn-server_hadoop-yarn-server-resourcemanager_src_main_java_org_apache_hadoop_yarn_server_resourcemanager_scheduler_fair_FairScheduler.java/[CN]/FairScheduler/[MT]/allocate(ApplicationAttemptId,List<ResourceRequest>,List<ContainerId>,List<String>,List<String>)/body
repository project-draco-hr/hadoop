{
  FSSchedulerApp application=getSchedulerApp(appAttemptId);
  if (application == null) {
    LOG.info("Calling allocate on removed " + "or non existant application " + appAttemptId);
    return EMPTY_ALLOCATION;
  }
  SchedulerUtils.normalizeRequests(ask,new DominantResourceCalculator(),clusterCapacity,minimumAllocation,maximumAllocation,incrAllocation);
  for (  ContainerId releasedContainerId : release) {
    RMContainer rmContainer=getRMContainer(releasedContainerId);
    if (rmContainer == null) {
      RMAuditLogger.logFailure(application.getUser(),AuditConstants.RELEASE_CONTAINER,"Unauthorized access or invalid container","FairScheduler","Trying to release container not owned by app or with invalid id",application.getApplicationId(),releasedContainerId);
    }
    completedContainer(rmContainer,SchedulerUtils.createAbnormalContainerStatus(releasedContainerId,SchedulerUtils.RELEASED_CONTAINER),RMContainerEventType.RELEASED);
  }
synchronized (application) {
    if (!ask.isEmpty()) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("allocate: pre-update" + " applicationAttemptId=" + appAttemptId + " application="+ application.getApplicationId());
      }
      application.showRequests();
      application.updateResourceRequests(ask);
      LOG.debug("allocate: post-update");
      application.showRequests();
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("allocate:" + " applicationAttemptId=" + appAttemptId + " #ask="+ ask.size());
      LOG.debug("Preempting " + application.getPreemptionContainers().size() + " container(s)");
    }
    Set<ContainerId> preemptionContainerIds=new HashSet<ContainerId>();
    for (    RMContainer container : application.getPreemptionContainers()) {
      preemptionContainerIds.add(container.getContainerId());
    }
    application.updateBlacklist(blacklistAdditions,blacklistRemovals);
    return new Allocation(application.pullNewlyAllocatedContainers(),application.getHeadroom(),preemptionContainerIds);
  }
}
