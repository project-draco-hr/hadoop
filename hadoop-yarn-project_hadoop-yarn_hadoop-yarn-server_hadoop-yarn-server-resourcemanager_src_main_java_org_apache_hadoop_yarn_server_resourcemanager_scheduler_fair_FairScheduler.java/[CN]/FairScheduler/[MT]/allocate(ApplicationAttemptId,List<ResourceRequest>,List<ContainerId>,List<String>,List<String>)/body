{
  FSAppAttempt application=getSchedulerApp(appAttemptId);
  if (application == null) {
    LOG.info("Calling allocate on removed " + "or non existant application " + appAttemptId);
    return EMPTY_ALLOCATION;
  }
  SchedulerUtils.normalizeRequests(ask,new DominantResourceCalculator(),clusterResource,minimumAllocation,maximumAllocation,incrAllocation);
  if (!application.getUnmanagedAM() && ask.size() == 1 && application.getLiveContainers().isEmpty()) {
    application.setAMResource(ask.get(0).getCapability());
  }
  releaseContainers(release,application);
synchronized (application) {
    if (!ask.isEmpty()) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("allocate: pre-update" + " applicationAttemptId=" + appAttemptId + " application="+ application.getApplicationId());
      }
      application.showRequests();
      application.updateResourceRequests(ask);
      application.showRequests();
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("allocate: post-update" + " applicationAttemptId=" + appAttemptId + " #ask="+ ask.size()+ " reservation= "+ application.getCurrentReservation());
      LOG.debug("Preempting " + application.getPreemptionContainers().size() + " container(s)");
    }
    Set<ContainerId> preemptionContainerIds=new HashSet<ContainerId>();
    for (    RMContainer container : application.getPreemptionContainers()) {
      preemptionContainerIds.add(container.getContainerId());
    }
    application.updateBlacklist(blacklistAdditions,blacklistRemovals);
    ContainersAndNMTokensAllocation allocation=application.pullNewlyAllocatedContainersAndNMTokens();
    return new Allocation(allocation.getContainerList(),application.getHeadroom(),preemptionContainerIds,null,null,allocation.getNMTokenList());
  }
}
