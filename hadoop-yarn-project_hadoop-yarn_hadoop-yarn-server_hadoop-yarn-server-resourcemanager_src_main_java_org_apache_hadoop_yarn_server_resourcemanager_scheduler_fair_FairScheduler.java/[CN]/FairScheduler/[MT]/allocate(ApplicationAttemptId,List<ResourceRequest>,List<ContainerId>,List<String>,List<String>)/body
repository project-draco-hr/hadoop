{
  FSAppAttempt application=getSchedulerApp(appAttemptId);
  if (application == null) {
    LOG.info("Calling allocate on removed " + "or non existant application " + appAttemptId);
    return EMPTY_ALLOCATION;
  }
  SchedulerUtils.normalizeRequests(ask,DOMINANT_RESOURCE_CALCULATOR,clusterResource,minimumAllocation,getMaximumResourceCapability(),incrAllocation);
  application.recordContainerRequestTime(getClock().getTime());
  releaseContainers(release,application);
synchronized (application) {
    if (!ask.isEmpty()) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("allocate: pre-update" + " applicationAttemptId=" + appAttemptId + " application="+ application.getApplicationId());
      }
      application.showRequests();
      application.updateResourceRequests(ask);
      application.showRequests();
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("allocate: post-update" + " applicationAttemptId=" + appAttemptId + " #ask="+ ask.size()+ " reservation= "+ application.getCurrentReservation());
      LOG.debug("Preempting " + application.getPreemptionContainers().size() + " container(s)");
    }
    Set<ContainerId> preemptionContainerIds=new HashSet<ContainerId>();
    for (    RMContainer container : application.getPreemptionContainers()) {
      preemptionContainerIds.add(container.getContainerId());
    }
    application.updateBlacklist(blacklistAdditions,blacklistRemovals);
    ContainersAndNMTokensAllocation allocation=application.pullNewlyAllocatedContainersAndNMTokens();
    if (!(allocation.getContainerList().isEmpty())) {
      application.recordContainerAllocationTime(getClock().getTime());
    }
    Resource headroom=application.getHeadroom();
    application.setApplicationHeadroomForMetrics(headroom);
    return new Allocation(allocation.getContainerList(),headroom,preemptionContainerIds,null,null,allocation.getNMTokenList());
  }
}
