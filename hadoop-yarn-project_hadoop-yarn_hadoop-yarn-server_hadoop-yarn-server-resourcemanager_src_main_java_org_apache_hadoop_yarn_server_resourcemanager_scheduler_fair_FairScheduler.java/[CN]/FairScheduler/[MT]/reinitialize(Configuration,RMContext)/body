{
  if (!initialized) {
    this.conf=new FairSchedulerConfiguration(conf);
    rootMetrics=QueueMetrics.forQueue("root",null,true,conf);
    this.rmContext=rmContext;
    this.eventLog=new FairSchedulerEventLog();
    eventLog.init(this.conf);
    minimumAllocation=this.conf.getMinimumMemoryAllocation();
    maximumAllocation=this.conf.getMaximumMemoryAllocation();
    userAsDefaultQueue=this.conf.getUserAsDefaultQueue();
    nodeLocalityThreshold=this.conf.getLocalityThresholdNode();
    rackLocalityThreshold=this.conf.getLocalityThresholdRack();
    preemptionEnabled=this.conf.getPreemptionEnabled();
    assignMultiple=this.conf.getAssignMultiple();
    maxAssign=this.conf.getMaxAssign();
    initialized=true;
    sizeBasedWeight=this.conf.getSizeBasedWeight();
    try {
      queueMgr.initialize();
    }
 catch (    Exception e) {
      throw new IOException("Failed to start FairScheduler",e);
    }
    Thread updateThread=new Thread(new UpdateThread());
    updateThread.setName("FairSchedulerUpdateThread");
    updateThread.setDaemon(true);
    updateThread.start();
  }
 else {
    this.conf=new FairSchedulerConfiguration(conf);
    userAsDefaultQueue=this.conf.getUserAsDefaultQueue();
    nodeLocalityThreshold=this.conf.getLocalityThresholdNode();
    rackLocalityThreshold=this.conf.getLocalityThresholdRack();
    preemptionEnabled=this.conf.getPreemptionEnabled();
    try {
      queueMgr.reloadAllocs();
    }
 catch (    Exception e) {
      throw new IOException("Failed to initialize FairScheduler",e);
    }
  }
}
