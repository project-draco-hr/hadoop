{
  this.conf=new FairSchedulerConfiguration(conf);
  validateConf(this.conf);
  minimumAllocation=this.conf.getMinimumAllocation();
  maximumAllocation=this.conf.getMaximumAllocation();
  userAsDefaultQueue=this.conf.getUserAsDefaultQueue();
  nodeLocalityThreshold=this.conf.getLocalityThresholdNode();
  rackLocalityThreshold=this.conf.getLocalityThresholdRack();
  preemptionEnabled=this.conf.getPreemptionEnabled();
  assignMultiple=this.conf.getAssignMultiple();
  maxAssign=this.conf.getMaxAssign();
  sizeBasedWeight=this.conf.getSizeBasedWeight();
  preemptionInterval=this.conf.getPreemptionInterval();
  waitTimeBeforeKill=this.conf.getWaitTimeBeforeKill();
  if (!initialized) {
    rootMetrics=QueueMetrics.forQueue("root",null,true,conf);
    this.rmContext=rmContext;
    this.eventLog=new FairSchedulerEventLog();
    eventLog.init(this.conf);
    initialized=true;
    try {
      queueMgr.initialize();
    }
 catch (    Exception e) {
      throw new IOException("Failed to start FairScheduler",e);
    }
    Thread updateThread=new Thread(new UpdateThread());
    updateThread.setName("FairSchedulerUpdateThread");
    updateThread.setDaemon(true);
    updateThread.start();
  }
 else {
    try {
      queueMgr.reloadAllocs();
    }
 catch (    Exception e) {
      throw new IOException("Failed to initialize FairScheduler",e);
    }
  }
}
