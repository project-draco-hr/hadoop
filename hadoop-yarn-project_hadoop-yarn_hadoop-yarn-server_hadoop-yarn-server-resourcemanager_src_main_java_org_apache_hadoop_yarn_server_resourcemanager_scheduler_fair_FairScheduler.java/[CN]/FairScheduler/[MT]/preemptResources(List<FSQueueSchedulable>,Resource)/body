{
  if (scheds.isEmpty() || Resources.equals(toPreempt,Resources.none())) {
    return;
  }
  Map<RMContainer,FSSchedulerApp> apps=new HashMap<RMContainer,FSSchedulerApp>();
  Map<RMContainer,FSQueueSchedulable> queues=new HashMap<RMContainer,FSQueueSchedulable>();
  List<RMContainer> runningContainers=new ArrayList<RMContainer>();
  for (  FSQueueSchedulable sched : scheds) {
    if (Resources.greaterThan(sched.getResourceUsage(),sched.getFairShare())) {
      for (      AppSchedulable as : sched.getAppSchedulables()) {
        for (        RMContainer c : as.getApp().getLiveContainers()) {
          runningContainers.add(c);
          apps.put(c,as.getApp());
          queues.put(c,sched);
        }
      }
    }
  }
  Collections.sort(runningContainers,new Comparator<RMContainer>(){
    public int compare(    RMContainer c1,    RMContainer c2){
      return c2.getContainer().getPriority().compareTo(c1.getContainer().getPriority());
    }
  }
);
  for (  RMContainer container : runningContainers) {
    FSQueueSchedulable sched=queues.get(container);
    if (Resources.greaterThan(sched.getResourceUsage(),sched.getFairShare())) {
      LOG.info("Preempting container (prio=" + container.getContainer().getPriority() + "res="+ container.getContainer().getResource()+ ") from queue "+ sched.getQueue().getName());
      ContainerStatus status=SchedulerUtils.createAbnormalContainerStatus(container.getContainerId(),SchedulerUtils.PREEMPTED_CONTAINER);
      completedContainer(container,status,RMContainerEventType.KILL);
      toPreempt=Resources.subtract(toPreempt,container.getContainer().getResource());
      if (Resources.equals(toPreempt,Resources.none())) {
        break;
      }
    }
  }
}
