{
  this.conf=new FairSchedulerConfiguration(conf);
  validateConf(this.conf);
  minimumAllocation=this.conf.getMinimumAllocation();
  maximumAllocation=this.conf.getMaximumAllocation();
  incrAllocation=this.conf.getIncrementAllocation();
  continuousSchedulingEnabled=this.conf.isContinuousSchedulingEnabled();
  continuousSchedulingSleepMs=this.conf.getContinuousSchedulingSleepMs();
  nodeLocalityThreshold=this.conf.getLocalityThresholdNode();
  rackLocalityThreshold=this.conf.getLocalityThresholdRack();
  nodeLocalityDelayMs=this.conf.getLocalityDelayNodeMs();
  rackLocalityDelayMs=this.conf.getLocalityDelayRackMs();
  preemptionEnabled=this.conf.getPreemptionEnabled();
  preemptionUtilizationThreshold=this.conf.getPreemptionUtilizationThreshold();
  assignMultiple=this.conf.getAssignMultiple();
  maxAssign=this.conf.getMaxAssign();
  sizeBasedWeight=this.conf.getSizeBasedWeight();
  preemptionInterval=this.conf.getPreemptionInterval();
  waitTimeBeforeKill=this.conf.getWaitTimeBeforeKill();
  usePortForNodeName=this.conf.getUsePortForNodeName();
  updateInterval=this.conf.getUpdateInterval();
  if (updateInterval < 0) {
    updateInterval=FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;
    LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS + " is invalid, so using default value " + +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS+ " ms instead");
  }
  rootMetrics=FSQueueMetrics.forQueue("root",null,true,conf);
  this.applications=new ConcurrentHashMap<ApplicationId,SchedulerApplication<FSSchedulerApp>>();
  this.eventLog=new FairSchedulerEventLog();
  eventLog.init(this.conf);
  allocConf=new AllocationConfiguration(conf);
  try {
    queueMgr.initialize(conf);
  }
 catch (  Exception e) {
    throw new IOException("Failed to start FairScheduler",e);
  }
  updateThread=new Thread(new UpdateThread());
  updateThread.setName("FairSchedulerUpdateThread");
  updateThread.setDaemon(true);
  if (continuousSchedulingEnabled) {
    schedulingThread=new Thread(new Runnable(){
      @Override public void run(){
        while (!Thread.currentThread().isInterrupted()) {
          try {
            continuousSchedulingAttempt();
            Thread.sleep(getContinuousSchedulingSleepMs());
          }
 catch (          InterruptedException e) {
            LOG.error("Continuous scheduling thread interrupted. Exiting. ",e);
            return;
          }
        }
      }
    }
);
    schedulingThread.setName("ContinuousScheduling");
    schedulingThread.setDaemon(true);
  }
  allocsLoader.init(conf);
  allocsLoader.setReloadListener(new AllocationReloadListener());
  try {
    allocsLoader.reloadAllocations();
  }
 catch (  Exception e) {
    throw new IOException("Failed to initialize FairScheduler",e);
  }
}
