{
  while (true) {
    int count=-1;
    if (dataLengthBuffer.remaining() > 0) {
      count=channelRead(channel,dataLengthBuffer);
      if (count < 0 || dataLengthBuffer.remaining() > 0)       return count;
    }
    if (!rpcHeaderRead) {
      if (rpcHeaderBuffer == null) {
        rpcHeaderBuffer=ByteBuffer.allocate(2);
      }
      count=channelRead(channel,rpcHeaderBuffer);
      if (count < 0 || rpcHeaderBuffer.remaining() > 0) {
        return count;
      }
      int version=rpcHeaderBuffer.get(0);
      byte[] method=new byte[]{rpcHeaderBuffer.get(1)};
      authMethod=AuthMethod.read(new DataInputStream(new ByteArrayInputStream(method)));
      if (authMethod == null) {
        throw new IOException("Unable to read authentication method");
      }
      if (isSecurityEnabled && authMethod == AuthMethod.SIMPLE) {
        AccessControlException ae=new AccessControlException("Authentication is required");
        setupResponse(authFailedResponse,authFailedCall,Status.FATAL,null,ae.getClass().getName(),ae.getMessage());
        responder.doRespond(authFailedCall);
        throw ae;
      }
      if (!isSecurityEnabled && authMethod != AuthMethod.SIMPLE) {
        doSaslReply(SaslStatus.SUCCESS,new IntWritable(SaslRpcServer.SWITCH_TO_SIMPLE_AUTH),null,null);
        authMethod=AuthMethod.SIMPLE;
        skipInitialSaslHandshake=true;
      }
      if (authMethod != AuthMethod.SIMPLE) {
        useSasl=true;
      }
      dataLengthBuffer.flip();
      if (!HEADER.equals(dataLengthBuffer) || version != CURRENT_VERSION) {
        LOG.warn("Incorrect header or version mismatch from " + hostAddress + ":"+ remotePort+ " got version "+ version+ " expected version "+ CURRENT_VERSION);
        return -1;
      }
      dataLengthBuffer.clear();
      rpcHeaderBuffer=null;
      rpcHeaderRead=true;
      continue;
    }
    if (data == null) {
      dataLengthBuffer.flip();
      dataLength=dataLengthBuffer.getInt();
      if (!useSasl && dataLength == Client.PING_CALL_ID) {
        dataLengthBuffer.clear();
        return 0;
      }
      data=ByteBuffer.allocate(dataLength);
    }
    count=channelRead(channel,data);
    if (data.remaining() == 0) {
      dataLengthBuffer.clear();
      data.flip();
      if (skipInitialSaslHandshake) {
        data=null;
        skipInitialSaslHandshake=false;
        continue;
      }
      boolean isHeaderRead=headerRead;
      if (useSasl) {
        saslReadAndProcess(data.array());
      }
 else {
        processOneRpc(data.array());
      }
      data=null;
      if (!isHeaderRead) {
        continue;
      }
    }
    return count;
  }
}
