{
  String error="ERROR";
  String errorWithNewLines="ERROR\nERROR";
  String expectedErrorReport="ERROR:ERROR";
  Collection<BlackListInfo> blackListedTrackerInfo=jobTracker.getBlackListedTrackers();
  assertTrue("The blacklisted tracker nodes is not empty.",blackListedTrackerInfo.isEmpty());
  TaskTrackerHealthStatus status=getUnhealthyNodeStatus(errorWithNewLines);
  sendHeartBeat(status,false);
  assertEquals("All trackers not blacklisted",3,jobTracker.getBlacklistedTrackerCount());
  blackListedTrackerInfo=jobTracker.getBlackListedTrackers();
  assertEquals("Blacklist tracker info does not contain all trackers",3,blackListedTrackerInfo.size());
  for (  BlackListInfo bi : blackListedTrackerInfo) {
    assertEquals("Tracker not blacklisted for health reason",ReasonForBlackListing.NODE_UNHEALTHY.toString().trim(),bi.getReasonForBlackListing().trim());
    assertTrue("Tracker blacklist report does not match",bi.toString().endsWith(expectedErrorReport));
  }
  sendHeartBeat(null,false);
  runBlackListingJob(jobTracker,trackers);
  sendHeartBeat(status,false);
  blackListedTrackerInfo=jobTracker.getBlackListedTrackers();
  for (  BlackListInfo bi : blackListedTrackerInfo) {
    if (bi.getTrackerName().equals(trackers[0])) {
      assertTrue("Reason for blacklisting of tracker 1 does not contain Unhealthy reasons",bi.getReasonForBlackListing().contains(ReasonForBlackListing.NODE_UNHEALTHY.toString().trim()));
      assertTrue("Reason for blacklisting of tracker 1 does not contain Unhealthy reasons",bi.getReasonForBlackListing().contains(ReasonForBlackListing.EXCEEDING_FAILURES.toString().trim()));
      assertTrue("Blacklist failure does not contain failure report string",bi.getBlackListReport().contains("failures on the tracker"));
    }
 else {
      assertEquals("Tracker not blacklisted for health reason",ReasonForBlackListing.NODE_UNHEALTHY.toString().trim(),bi.getReasonForBlackListing().trim());
    }
    assertTrue("Tracker blacklist report does not match",bi.getBlackListReport().trim().contains(error));
  }
  clock.jumpADay=true;
  sendHeartBeat(null,false);
}
