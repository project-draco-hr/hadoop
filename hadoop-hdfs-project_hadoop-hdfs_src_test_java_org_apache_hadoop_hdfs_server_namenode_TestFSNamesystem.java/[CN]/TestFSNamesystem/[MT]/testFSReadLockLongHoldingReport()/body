{
  final long readLockReportingThreshold=100L;
  final String readLockLogStmt="FSNamesystem read lock held for ";
  Configuration conf=new Configuration();
  conf.setLong(DFSConfigKeys.DFS_NAMENODE_READ_LOCK_REPORTING_THRESHOLD_MS_KEY,readLockReportingThreshold);
  FSImage fsImage=Mockito.mock(FSImage.class);
  FSEditLog fsEditLog=Mockito.mock(FSEditLog.class);
  Mockito.when(fsImage.getEditLog()).thenReturn(fsEditLog);
  FSNamesystem fsn=new FSNamesystem(conf,fsImage);
  LogCapturer logs=LogCapturer.captureLogs(FSNamesystem.LOG);
  GenericTestUtils.setLogLevel(FSNamesystem.LOG,Level.INFO);
  fsn.readLock();
  Thread.sleep(readLockReportingThreshold / 2);
  fsn.readUnlock();
  assertFalse(logs.getOutput().contains(GenericTestUtils.getMethodName()) && logs.getOutput().contains(readLockLogStmt));
  fsn.readLock();
  Thread.sleep(readLockReportingThreshold + 10);
  logs.clearOutput();
  fsn.readUnlock();
  assertTrue(logs.getOutput().contains(GenericTestUtils.getMethodName()) && logs.getOutput().contains(readLockLogStmt));
  fsn.readLock();
  Thread.sleep(readLockReportingThreshold / 2 + 1);
  fsn.readLock();
  Thread.sleep(readLockReportingThreshold / 2 + 1);
  logs.clearOutput();
  fsn.readUnlock();
  assertFalse(logs.getOutput().contains(GenericTestUtils.getMethodName()) || logs.getOutput().contains(readLockLogStmt));
  logs.clearOutput();
  fsn.readUnlock();
  assertTrue(logs.getOutput().contains(GenericTestUtils.getMethodName()) && logs.getOutput().contains(readLockLogStmt));
  logs.clearOutput();
  CountDownLatch barrier=new CountDownLatch(1);
  CountDownLatch barrier2=new CountDownLatch(1);
  Thread t1=new Thread(){
    @Override public void run(){
      try {
        fsn.readLock();
        Thread.sleep(readLockReportingThreshold + 1);
        barrier.countDown();
        barrier2.await();
        fsn.readUnlock();
      }
 catch (      InterruptedException e) {
        fail("Interrupted during testing");
      }
    }
  }
;
  Thread t2=new Thread(){
    @Override public void run(){
      try {
        barrier.await();
        fsn.readLock();
        barrier2.countDown();
        fsn.readUnlock();
      }
 catch (      InterruptedException e) {
        fail("Interrupted during testing");
      }
    }
  }
;
  t1.start();
  t2.start();
  t1.join();
  t2.join();
  Pattern t1Pattern=Pattern.compile(String.format("\\Q%s\\E.+%s",t1.getName(),readLockLogStmt));
  assertTrue(t1Pattern.matcher(logs.getOutput()).find());
  Pattern t2Pattern=Pattern.compile(String.format("\\Q%s\\E.+%s",t2.getName(),readLockLogStmt));
  assertFalse(t2Pattern.matcher(logs.getOutput()).find());
  logs.clearOutput();
  final int threadCount=50;
  List<Thread> threads=new ArrayList<>(threadCount);
  for (int i=0; i < threadCount; i++) {
    threads.add(new Thread(){
      @Override public void run(){
        try {
          long sleepTime;
          if (this.getName().hashCode() % 2 == 0) {
            sleepTime=readLockReportingThreshold + 10;
          }
 else {
            sleepTime=readLockReportingThreshold / 2;
          }
          fsn.readLock();
          Thread.sleep(sleepTime);
          fsn.readUnlock();
        }
 catch (        InterruptedException e) {
          fail("Interrupted during testing");
        }
      }
    }
);
  }
  for (  Thread t : threads) {
    t.start();
  }
  for (  Thread t : threads) {
    t.join();
  }
  for (  Thread t : threads) {
    Pattern p=Pattern.compile(String.format("\\Q%s\\E.+%s",t.getName(),readLockLogStmt));
    boolean foundLog=p.matcher(logs.getOutput()).find();
    if (t.getName().hashCode() % 2 == 0) {
      assertTrue(foundLog);
    }
 else {
      assertFalse(foundLog);
    }
  }
}
