{
  long syncStart=0;
  long mytxid=myTransactionId.get().txid;
  boolean sync=false;
  try {
    EditLogOutputStream logStream=null;
synchronized (this) {
      try {
        printStatistics(false);
        while (mytxid > synctxid && isSyncRunning) {
          try {
            wait(1000);
          }
 catch (          InterruptedException ie) {
          }
        }
        if (mytxid <= synctxid) {
          numTransactionsBatchedInSync++;
          if (metrics != null) {
            metrics.incrTransactionsBatchedInSync();
          }
          return;
        }
        syncStart=txid;
        isSyncRunning=true;
        sync=true;
        try {
          if (journalSet.isEmpty()) {
            throw new IOException("No journals available to flush");
          }
          editLogStream.setReadyToFlush();
        }
 catch (        IOException e) {
          LOG.fatal("Could not sync enough journals to persistent storage. " + "Unsynced transactions: " + (txid - synctxid),new Exception());
          runtime.exit(1);
        }
      }
  finally {
        doneWithAutoSyncScheduling();
      }
      logStream=editLogStream;
    }
    long start=now();
    try {
      if (logStream != null) {
        logStream.flush();
      }
    }
 catch (    IOException ex) {
synchronized (this) {
        LOG.fatal("Could not sync enough journals to persistent storage. " + "Unsynced transactions: " + (txid - synctxid),new Exception());
        runtime.exit(1);
      }
    }
    long elapsed=now() - start;
    if (metrics != null) {
      metrics.addSync(elapsed);
    }
  }
  finally {
synchronized (this) {
      if (sync) {
        synctxid=syncStart;
        isSyncRunning=false;
      }
      this.notifyAll();
    }
  }
}
