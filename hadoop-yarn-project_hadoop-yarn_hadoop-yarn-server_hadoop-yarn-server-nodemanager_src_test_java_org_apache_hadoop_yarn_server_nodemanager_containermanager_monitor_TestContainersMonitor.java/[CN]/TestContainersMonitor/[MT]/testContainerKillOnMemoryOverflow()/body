{
  if (!ProcfsBasedProcessTree.isAvailable()) {
    return;
  }
  containerManager.start();
  File scriptFile=new File(tmpDir,"scriptFile.sh");
  PrintWriter fileWriter=new PrintWriter(scriptFile);
  File processStartFile=new File(tmpDir,"start_file.txt").getAbsoluteFile();
  fileWriter.write("\numask 0");
  fileWriter.write("\necho Hello World! > " + processStartFile);
  fileWriter.write("\necho $$ >> " + processStartFile);
  fileWriter.write("\nsleep 15");
  fileWriter.close();
  ContainerLaunchContext containerLaunchContext=recordFactory.newRecordInstance(ContainerLaunchContext.class);
  ApplicationId appId=ApplicationId.newInstance(0,0);
  ApplicationAttemptId appAttemptId=ApplicationAttemptId.newInstance(appId,1);
  ContainerId cId=ContainerId.newInstance(appAttemptId,0);
  int port=12345;
  URL resource_alpha=ConverterUtils.getYarnUrlFromPath(localFS.makeQualified(new Path(scriptFile.getAbsolutePath())));
  LocalResource rsrc_alpha=recordFactory.newRecordInstance(LocalResource.class);
  rsrc_alpha.setResource(resource_alpha);
  rsrc_alpha.setSize(-1);
  rsrc_alpha.setVisibility(LocalResourceVisibility.APPLICATION);
  rsrc_alpha.setType(LocalResourceType.FILE);
  rsrc_alpha.setTimestamp(scriptFile.lastModified());
  String destinationFile="dest_file";
  Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
  localResources.put(destinationFile,rsrc_alpha);
  containerLaunchContext.setLocalResources(localResources);
  List<String> commands=new ArrayList<String>();
  commands.add("/bin/bash");
  commands.add(scriptFile.getAbsolutePath());
  containerLaunchContext.setCommands(commands);
  Resource r=BuilderUtils.newResource(8 * 1024 * 1024,1);
  StartContainerRequest startRequest=recordFactory.newRecordInstance(StartContainerRequest.class);
  startRequest.setContainerLaunchContext(containerLaunchContext);
  ContainerToken containerToken=BuilderUtils.newContainerToken(cId,context.getNodeId().getHost(),port,user,r,System.currentTimeMillis() + 10000L,123,"password".getBytes(),super.DUMMY_RM_IDENTIFIER);
  startRequest.setContainerToken(containerToken);
  containerManager.startContainer(startRequest);
  int timeoutSecs=0;
  while (!processStartFile.exists() && timeoutSecs++ < 20) {
    Thread.sleep(1000);
    LOG.info("Waiting for process start-file to be created");
  }
  Assert.assertTrue("ProcessStartFile doesn't exist!",processStartFile.exists());
  BufferedReader reader=new BufferedReader(new FileReader(processStartFile));
  Assert.assertEquals("Hello World!",reader.readLine());
  String pid=reader.readLine().trim();
  Assert.assertEquals(null,reader.readLine());
  BaseContainerManagerTest.waitForContainerState(containerManager,cId,ContainerState.COMPLETE,60);
  GetContainerStatusRequest gcsRequest=recordFactory.newRecordInstance(GetContainerStatusRequest.class);
  gcsRequest.setContainerId(cId);
  ContainerStatus containerStatus=containerManager.getContainerStatus(gcsRequest).getStatus();
  Assert.assertEquals(ExitCode.TERMINATED.getExitCode(),containerStatus.getExitStatus());
  String expectedMsgPattern="Container \\[pid=" + pid + ",containerID="+ cId+ "\\] is running beyond virtual memory limits. Current usage: "+ "[0-9.]+ ?[KMGTPE]?B of [0-9.]+ ?[KMGTPE]?B physical memory used; "+ "[0-9.]+ ?[KMGTPE]?B of [0-9.]+ ?[KMGTPE]?B virtual memory used. "+ "Killing container.\nDump of the process-tree for "+ cId+ " :\n";
  Pattern pat=Pattern.compile(expectedMsgPattern);
  Assert.assertEquals("Expected message pattern is: " + expectedMsgPattern + "\n\nObserved message is: "+ containerStatus.getDiagnostics(),true,pat.matcher(containerStatus.getDiagnostics()).find());
  Assert.assertFalse("Process is still alive!",exec.signalContainer(user,pid,Signal.NULL));
}
