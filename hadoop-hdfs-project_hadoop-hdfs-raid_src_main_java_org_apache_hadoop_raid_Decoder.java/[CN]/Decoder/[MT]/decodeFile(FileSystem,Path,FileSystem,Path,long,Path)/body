{
  LOG.info("Create " + decodedFile + " for error at "+ srcFile+ ":"+ errorOffset);
  FileStatus srcStat=fs.getFileStatus(srcFile);
  long blockSize=srcStat.getBlockSize();
  configureBuffers(blockSize);
  errorOffset=(errorOffset / blockSize) * blockSize;
  FSDataOutputStream out=fs.create(decodedFile,false,conf.getInt("io.file.buffer.size",64 * 1024),srcStat.getReplication(),srcStat.getBlockSize());
  FSDataInputStream in=fs.open(srcFile,conf.getInt("io.file.buffer.size",64 * 1024));
  for (long offset=0; offset < srcStat.getLen(); offset+=blockSize) {
    long limit=Math.min(blockSize,srcStat.getLen() - offset);
    long bytesAlreadyCopied=0;
    if (offset != errorOffset) {
      try {
        in=fs.open(srcFile,conf.getInt("io.file.buffer.size",64 * 1024));
        in.seek(offset);
        RaidUtils.copyBytes(in,out,readBufs[0],limit);
        assert(out.getPos() == offset + limit);
        LOG.info("Copied till " + out.getPos() + " from "+ srcFile);
        continue;
      }
 catch (      BlockMissingException e) {
        LOG.warn("Encountered BME at " + srcFile + ":"+ offset);
        bytesAlreadyCopied=out.getPos() - offset;
      }
catch (      ChecksumException e) {
        LOG.warn("Encountered CE at " + srcFile + ":"+ offset);
        bytesAlreadyCopied=out.getPos() - offset;
      }
    }
    fixErasedBlock(fs,srcFile,parityFs,parityFile,blockSize,offset,bytesAlreadyCopied,limit,out);
  }
  out.close();
  try {
    fs.setOwner(decodedFile,srcStat.getOwner(),srcStat.getGroup());
    fs.setPermission(decodedFile,srcStat.getPermission());
    fs.setTimes(decodedFile,srcStat.getModificationTime(),srcStat.getAccessTime());
  }
 catch (  Exception exc) {
    LOG.warn("Didn't manage to copy meta information because of " + exc + " Ignoring...");
  }
}
