{
  Stopwatch sw=new Stopwatch().start();
  long minSize=Math.max(getFormatMinSplitSize(),getMinSplitSize(job));
  long maxSize=getMaxSplitSize(job);
  List<InputSplit> splits=new ArrayList<InputSplit>();
  List<FileStatus> files=listStatus(job);
  for (  FileStatus file : files) {
    Path path=file.getPath();
    long length=file.getLen();
    if (length != 0) {
      BlockLocation[] blkLocations;
      if (file instanceof LocatedFileStatus) {
        blkLocations=((LocatedFileStatus)file).getBlockLocations();
      }
 else {
        FileSystem fs=path.getFileSystem(job.getConfiguration());
        blkLocations=fs.getFileBlockLocations(file,0,length);
      }
      if (isSplitable(job,path)) {
        long blockSize=file.getBlockSize();
        long splitSize=computeSplitSize(blockSize,minSize,maxSize);
        long bytesRemaining=length;
        while (((double)bytesRemaining) / splitSize > SPLIT_SLOP) {
          int blkIndex=getBlockIndex(blkLocations,length - bytesRemaining);
          splits.add(makeSplit(path,length - bytesRemaining,splitSize,blkLocations[blkIndex].getHosts()));
          bytesRemaining-=splitSize;
        }
        if (bytesRemaining != 0) {
          int blkIndex=getBlockIndex(blkLocations,length - bytesRemaining);
          splits.add(makeSplit(path,length - bytesRemaining,bytesRemaining,blkLocations[blkIndex].getHosts()));
        }
      }
 else {
        splits.add(makeSplit(path,0,length,blkLocations[0].getHosts()));
      }
    }
 else {
      splits.add(makeSplit(path,0,length,new String[0]));
    }
  }
  job.getConfiguration().setLong(NUM_INPUT_FILES,files.size());
  sw.stop();
  if (LOG.isDebugEnabled()) {
    LOG.debug("Total # of splits generated by getSplits: " + splits.size() + ", TimeTaken: "+ sw.elapsedMillis());
  }
  return splits;
}
