{
  long minSize=Math.max(getFormatMinSplitSize(),getMinSplitSize(job));
  long maxSize=getMaxSplitSize(job);
  List<InputSplit> splits=new ArrayList<InputSplit>();
  List<FileStatus> files=listStatus(job);
  for (  FileStatus file : files) {
    Path path=file.getPath();
    long length=file.getLen();
    if (length != 0) {
      FileSystem fs=path.getFileSystem(job.getConfiguration());
      BlockLocation[] blkLocations=fs.getFileBlockLocations(file,0,length);
      if (isSplitable(job,path)) {
        long blockSize=file.getBlockSize();
        long splitSize=computeSplitSize(blockSize,minSize,maxSize);
        long bytesRemaining=length;
        while (((double)bytesRemaining) / splitSize > SPLIT_SLOP) {
          int blkIndex=getBlockIndex(blkLocations,length - bytesRemaining);
          splits.add(makeSplit(path,length - bytesRemaining,splitSize,blkLocations[blkIndex].getHosts()));
          bytesRemaining-=splitSize;
        }
        if (bytesRemaining != 0) {
          int blkIndex=getBlockIndex(blkLocations,length - bytesRemaining);
          splits.add(makeSplit(path,length - bytesRemaining,bytesRemaining,blkLocations[blkIndex].getHosts()));
        }
      }
 else {
        splits.add(makeSplit(path,0,length,blkLocations[0].getHosts()));
      }
    }
 else {
      splits.add(makeSplit(path,0,length,new String[0]));
    }
  }
  job.getConfiguration().setLong(NUM_INPUT_FILES,files.size());
  LOG.debug("Total # of splits: " + splits.size());
  return splits;
}
