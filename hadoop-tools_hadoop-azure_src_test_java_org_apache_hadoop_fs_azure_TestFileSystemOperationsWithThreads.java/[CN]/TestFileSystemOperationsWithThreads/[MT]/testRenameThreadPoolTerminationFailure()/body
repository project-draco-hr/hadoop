{
  NativeAzureFileSystem mockFs=Mockito.spy((NativeAzureFileSystem)fs);
  String path=mockFs.pathToKey(mockFs.makeAbsolute(new Path("root")));
  AzureFileSystemThreadPoolExecutor mockThreadPoolExecutor=Mockito.spy(mockFs.getThreadPoolExecutor(renameThreads,"AzureBlobRenameThread","Rename",path,NativeAzureFileSystem.AZURE_RENAME_THREADS));
  Mockito.when(mockFs.getThreadPoolExecutor(renameThreads,"AzureBlobRenameThread","Rename",path,NativeAzureFileSystem.AZURE_RENAME_THREADS)).thenReturn(mockThreadPoolExecutor);
  ThreadPoolExecutor mockThreadExecutor=Mockito.mock(ThreadPoolExecutor.class);
  Mockito.doNothing().when(mockThreadExecutor).execute(Mockito.any(Runnable.class));
  Mockito.when(mockThreadExecutor.awaitTermination(Long.MAX_VALUE,TimeUnit.DAYS)).thenThrow(new InterruptedException());
  Mockito.when(mockThreadPoolExecutor.getThreadPool(7)).thenReturn(mockThreadExecutor);
  createFolder(mockFs,"root");
  Path sourceFolder=new Path("root");
  Path destFolder=new Path("rootnew");
  boolean exception=false;
  try {
    mockFs.rename(sourceFolder,destFolder);
  }
 catch (  IOException e) {
    exception=true;
  }
  assertTrue(exception);
  assertTrue(mockFs.exists(sourceFolder));
  String content=logs.getOutput();
  assertTrue(content.contains("Using thread pool for Rename operation with threads"));
  assertTrue(content.contains("Threads got interrupted Rename blob operation"));
  assertTrue(content.contains("Rename failed as operation on subfolders and files failed."));
}
