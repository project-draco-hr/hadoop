{
  ((Log4JLogger)Server.LOG).getLogger().setLevel(Level.DEBUG);
  final int maxIdle=1000;
  final int cleanupInterval=maxIdle * 3 / 4;
  final int killMax=3;
  final int clients=1 + killMax * 2;
  conf.setInt(CommonConfigurationKeysPublic.IPC_CLIENT_CONNECTION_MAXIDLETIME_KEY,maxIdle);
  conf.setInt(CommonConfigurationKeysPublic.IPC_CLIENT_IDLETHRESHOLD_KEY,0);
  conf.setInt(CommonConfigurationKeysPublic.IPC_CLIENT_KILL_MAX_KEY,killMax);
  conf.setInt(CommonConfigurationKeys.IPC_CLIENT_CONNECTION_IDLESCANINTERVAL_KEY,cleanupInterval);
  final CyclicBarrier firstCallBarrier=new CyclicBarrier(2);
  final CyclicBarrier callBarrier=new CyclicBarrier(clients);
  final CountDownLatch allCallLatch=new CountDownLatch(clients);
  final AtomicBoolean error=new AtomicBoolean();
  final TestServer server=new TestServer(clients,false);
  Thread[] threads=new Thread[clients];
  try {
    server.callListener=new Runnable(){
      AtomicBoolean first=new AtomicBoolean(true);
      @Override public void run(){
        try {
          allCallLatch.countDown();
          if (first.compareAndSet(true,false)) {
            firstCallBarrier.await();
          }
 else {
            callBarrier.await();
          }
        }
 catch (        Throwable t) {
          LOG.error(t);
          error.set(true);
        }
      }
    }
;
    server.start();
    final CountDownLatch callReturned=new CountDownLatch(clients - 1);
    final InetSocketAddress addr=NetUtils.getConnectAddress(server);
    final Configuration clientConf=new Configuration();
    clientConf.setInt(CommonConfigurationKeysPublic.IPC_CLIENT_CONNECTION_MAXIDLETIME_KEY,10000);
    for (int i=0; i < clients; i++) {
      threads[i]=new Thread(new Runnable(){
        @Override public void run(){
          Client client=new Client(LongWritable.class,clientConf);
          try {
            client.call(new LongWritable(Thread.currentThread().getId()),addr,null,null,0,clientConf);
            callReturned.countDown();
            Thread.sleep(10000);
          }
 catch (          IOException e) {
            LOG.error(e);
          }
catch (          InterruptedException e) {
          }
        }
      }
);
      threads[i].start();
    }
    allCallLatch.await();
    assertFalse(error.get());
    assertEquals(clients,server.getNumOpenConnections());
    callBarrier.await();
    callReturned.await();
    assertEquals(clients,server.getNumOpenConnections());
    Thread.sleep(maxIdle * 2 - cleanupInterval);
    for (int i=clients; i > 1; i-=killMax) {
      Thread.sleep(cleanupInterval);
      assertFalse(error.get());
      assertEquals(i,server.getNumOpenConnections());
    }
    Thread.sleep(cleanupInterval);
    assertFalse(error.get());
    assertEquals(1,server.getNumOpenConnections());
    firstCallBarrier.await();
    Thread.sleep(maxIdle * 2);
    assertFalse(error.get());
    assertEquals(0,server.getNumOpenConnections());
  }
  finally {
    for (    Thread t : threads) {
      if (t != null) {
        t.interrupt();
        t.join();
      }
      server.stop();
    }
  }
}
