{
  int handlers=1;
  final Configuration conf=new Configuration();
  conf.setInt(CommonConfigurationKeys.IPC_SERVER_RPC_READ_CONNECTION_QUEUE_SIZE_KEY,readerQ);
  final int initialClients=readers + callQ + handlers;
  final int maxAccept=initialClients + readers * readerQ + 1;
  int clients=maxAccept * 2;
  final AtomicInteger failures=new AtomicInteger(0);
  final CountDownLatch callFinishedLatch=new CountDownLatch(clients);
  final TestServerQueue server=new TestServerQueue(clients,readers,callQ,handlers,conf);
  CallQueueManager<Call> spy=spy((CallQueueManager<Call>)Whitebox.getInternalState(server,"callQueue"));
  Whitebox.setInternalState(server,"callQueue",spy);
  final InetSocketAddress addr=NetUtils.getConnectAddress(server);
  server.start();
  Client.setConnectTimeout(conf,10000);
  Thread[] threads=new Thread[clients];
  for (int i=0; i < clients; i++) {
    threads[i]=new Thread(new Runnable(){
      @Override public void run(){
        Client client=new Client(LongWritable.class,conf);
        try {
          call(client,new LongWritable(Thread.currentThread().getId()),addr,60000,conf);
        }
 catch (        Throwable e) {
          LOG.error(e);
          failures.incrementAndGet();
          return;
        }
 finally {
          callFinishedLatch.countDown();
          client.stop();
        }
      }
    }
);
  }
  for (int i=0; i < initialClients; i++) {
    threads[i].start();
    if (i == 0) {
      server.firstCallLatch.await();
    }
    verify(spy,timeout(100).times(i + 1)).put(Mockito.<Call>anyObject());
  }
  try {
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        return server.getNumOpenConnections() >= initialClients;
      }
    }
,100,3000);
  }
 catch (  TimeoutException e) {
    fail("timed out while waiting for connections to open.");
  }
  LOG.info("(initial clients) need:" + initialClients + " connections have:"+ server.getNumOpenConnections());
  LOG.info("ipc layer should be blocked");
  assertEquals(callQ,server.getCallQueueLen());
  assertEquals(initialClients,server.getNumOpenConnections());
  for (int i=initialClients; i < clients; i++) {
    threads[i].start();
  }
  Thread.sleep(10);
  try {
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        return server.getNumOpenConnections() >= maxAccept;
      }
    }
,100,3000);
  }
 catch (  TimeoutException e) {
    fail("timed out while waiting for connections to open until maxAccept.");
  }
  LOG.info("(max clients) need:" + maxAccept + " connections have:"+ server.getNumOpenConnections());
  for (int i=0; i < 4; i++) {
    assertEquals(maxAccept,server.getNumOpenConnections());
    Thread.sleep(100);
  }
  assertEquals(clients,callFinishedLatch.getCount());
  LOG.info("releasing the calls");
  server.callBlockLatch.countDown();
  callFinishedLatch.await();
  for (  Thread t : threads) {
    t.join();
  }
  assertEquals(0,failures.get());
  server.stop();
}
