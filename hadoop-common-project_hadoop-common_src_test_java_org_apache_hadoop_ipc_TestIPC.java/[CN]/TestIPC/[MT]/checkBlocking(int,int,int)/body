{
  int handlers=1;
  final Configuration conf=new Configuration();
  conf.setInt(CommonConfigurationKeys.IPC_SERVER_RPC_READ_CONNECTION_QUEUE_SIZE_KEY,readerQ);
  int initialClients=readers + callQ + handlers;
  int maxAccept=initialClients + readers * readerQ + 1;
  int clients=maxAccept * 2;
  final AtomicInteger failures=new AtomicInteger(0);
  final CountDownLatch callFinishedLatch=new CountDownLatch(clients);
  final TestServerQueue server=new TestServerQueue(clients,readers,callQ,handlers,conf);
  final InetSocketAddress addr=NetUtils.getConnectAddress(server);
  server.start();
  Client.setConnectTimeout(conf,10000);
  Thread[] threads=new Thread[clients];
  for (int i=0; i < clients; i++) {
    threads[i]=new Thread(new Runnable(){
      @Override public void run(){
        Client client=new Client(LongWritable.class,conf);
        try {
          client.call(new LongWritable(Thread.currentThread().getId()),addr,null,null,60000,conf);
        }
 catch (        Throwable e) {
          LOG.error(e);
          failures.incrementAndGet();
          return;
        }
 finally {
          callFinishedLatch.countDown();
          client.stop();
        }
      }
    }
);
  }
  for (int i=0; i < initialClients; i++) {
    threads[i].start();
    if (i == 0) {
      server.firstCallLatch.await();
    }
 else     if (i <= callQ) {
      while (server.getCallQueueLen() != i) {
        Thread.sleep(1);
      }
    }
  }
  Thread.sleep(10);
  if (server.getNumOpenConnections() < initialClients) {
    LOG.info("(initial clients) need:" + initialClients + " connections have:"+ server.getNumOpenConnections());
    Thread.sleep(100);
  }
  LOG.info("ipc layer should be blocked");
  assertEquals(callQ,server.getCallQueueLen());
  assertEquals(initialClients,server.getNumOpenConnections());
  for (int i=initialClients; i < clients; i++) {
    threads[i].start();
  }
  Thread.sleep(10);
  if (server.getNumOpenConnections() < maxAccept) {
    LOG.info("(max clients) need:" + maxAccept + " connections have:"+ server.getNumOpenConnections());
    Thread.sleep(100);
  }
  for (int i=0; i < 4; i++) {
    assertEquals(maxAccept,server.getNumOpenConnections());
    Thread.sleep(100);
  }
  assertEquals(clients,callFinishedLatch.getCount());
  LOG.info("releasing the calls");
  server.callBlockLatch.countDown();
  callFinishedLatch.await();
  for (  Thread t : threads) {
    t.join();
  }
  assertEquals(0,failures.get());
  server.stop();
}
