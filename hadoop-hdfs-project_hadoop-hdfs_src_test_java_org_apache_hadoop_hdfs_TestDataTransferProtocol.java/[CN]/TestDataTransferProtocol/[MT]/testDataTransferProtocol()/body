{
  Random random=new Random();
  int oneMil=1024 * 1024;
  Path file=new Path("dataprotocol.dat");
  int numDataNodes=1;
  Configuration conf=new HdfsConfiguration();
  conf.setInt(DFSConfigKeys.DFS_REPLICATION_KEY,numDataNodes);
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(numDataNodes).build();
  try {
    cluster.waitActive();
    DFSClient dfsClient=new DFSClient(new InetSocketAddress("localhost",cluster.getNameNodePort()),conf);
    datanode=dfsClient.datanodeReport(DatanodeReportType.LIVE)[0];
    dnAddr=NetUtils.createSocketAddr(datanode.getXferAddr());
    FileSystem fileSys=cluster.getFileSystem();
    int fileLen=Math.min(conf.getInt(DFSConfigKeys.DFS_BLOCK_SIZE_KEY,4096),4096);
    DFSTestUtil.createFile(fileSys,file,fileLen,fileLen,fileSys.getDefaultBlockSize(file),fileSys.getDefaultReplication(file),0L);
    final ExtendedBlock firstBlock=DFSTestUtil.getFirstBlock(fileSys,file);
    final String poolId=firstBlock.getBlockPoolId();
    long newBlockId=firstBlock.getBlockId() + 1;
    recvBuf.reset();
    sendBuf.reset();
    recvOut.writeShort((short)(DataTransferProtocol.DATA_TRANSFER_VERSION - 1));
    sendOut.writeShort((short)(DataTransferProtocol.DATA_TRANSFER_VERSION - 1));
    sendRecvData("Wrong Version",true);
    sendBuf.reset();
    sendOut.writeShort((short)DataTransferProtocol.DATA_TRANSFER_VERSION);
    sendOut.writeByte(Op.WRITE_BLOCK.code - 1);
    sendRecvData("Wrong Op Code",true);
    sendBuf.reset();
    DataChecksum badChecksum=Mockito.spy(DEFAULT_CHECKSUM);
    Mockito.doReturn(-1).when(badChecksum).getBytesPerChecksum();
    sender.writeBlock(new ExtendedBlock(poolId,newBlockId),BlockTokenSecretManager.DUMMY_TOKEN,"cl",new DatanodeInfo[1],null,BlockConstructionStage.PIPELINE_SETUP_CREATE,0,0L,0L,0L,badChecksum,CachingStrategy.newDefaultStrategy());
    recvBuf.reset();
    sendResponse(Status.ERROR,null,null,recvOut);
    sendRecvData("wrong bytesPerChecksum while writing",true);
    sendBuf.reset();
    recvBuf.reset();
    sender.writeBlock(new ExtendedBlock(poolId,++newBlockId),BlockTokenSecretManager.DUMMY_TOKEN,"cl",new DatanodeInfo[1],null,BlockConstructionStage.PIPELINE_SETUP_CREATE,0,0L,0L,0L,DEFAULT_CHECKSUM,CachingStrategy.newDefaultStrategy());
    PacketHeader hdr=new PacketHeader(4,0,100,false,-1 - random.nextInt(oneMil),false);
    hdr.write(sendOut);
    sendResponse(Status.SUCCESS,"",null,recvOut);
    new PipelineAck(100,new Status[]{Status.ERROR}).write(recvOut);
    sendRecvData("negative DATA_CHUNK len while writing block " + newBlockId,true);
    sendBuf.reset();
    recvBuf.reset();
    sender.writeBlock(new ExtendedBlock(poolId,++newBlockId),BlockTokenSecretManager.DUMMY_TOKEN,"cl",new DatanodeInfo[1],null,BlockConstructionStage.PIPELINE_SETUP_CREATE,0,0L,0L,0L,DEFAULT_CHECKSUM,CachingStrategy.newDefaultStrategy());
    hdr=new PacketHeader(8,0,100,true,0,false);
    hdr.write(sendOut);
    sendOut.writeInt(0);
    sendOut.flush();
    sendResponse(Status.SUCCESS,"",null,recvOut);
    new PipelineAck(100,new Status[]{Status.SUCCESS}).write(recvOut);
    sendRecvData("Writing a zero len block blockid " + newBlockId,false);
    String bpid=cluster.getNamesystem().getBlockPoolId();
    ExtendedBlock blk=new ExtendedBlock(bpid,firstBlock.getLocalBlock());
    long blkid=blk.getBlockId();
    sendBuf.reset();
    recvBuf.reset();
    blk.setBlockId(blkid - 1);
    sender.readBlock(blk,BlockTokenSecretManager.DUMMY_TOKEN,"cl",0L,fileLen,true,CachingStrategy.newDefaultStrategy());
    sendRecvData("Wrong block ID " + newBlockId + " for read",false);
    sendBuf.reset();
    blk.setBlockId(blkid);
    sender.readBlock(blk,BlockTokenSecretManager.DUMMY_TOKEN,"cl",-1L,fileLen,true,CachingStrategy.newDefaultStrategy());
    sendRecvData("Negative start-offset for read for block " + firstBlock.getBlockId(),false);
    sendBuf.reset();
    sender.readBlock(blk,BlockTokenSecretManager.DUMMY_TOKEN,"cl",fileLen,fileLen,true,CachingStrategy.newDefaultStrategy());
    sendRecvData("Wrong start-offset for reading block " + firstBlock.getBlockId(),false);
    recvBuf.reset();
    BlockOpResponseProto.newBuilder().setStatus(Status.SUCCESS).setReadOpChecksumInfo(ReadOpChecksumInfoProto.newBuilder().setChecksum(DataTransferProtoUtil.toProto(DEFAULT_CHECKSUM)).setChunkOffset(0L)).build().writeDelimitedTo(recvOut);
    sendBuf.reset();
    sender.readBlock(blk,BlockTokenSecretManager.DUMMY_TOKEN,"cl",0L,-1L - random.nextInt(oneMil),true,CachingStrategy.newDefaultStrategy());
    sendRecvData("Negative length for reading block " + firstBlock.getBlockId(),false);
    recvBuf.reset();
    sendResponse(Status.ERROR,null,"opReadBlock " + firstBlock + " received exception java.io.IOException:  "+ "Offset 0 and length 4097 don't match block "+ firstBlock+ " ( blockLen 4096 )",recvOut);
    sendBuf.reset();
    sender.readBlock(blk,BlockTokenSecretManager.DUMMY_TOKEN,"cl",0L,fileLen + 1,true,CachingStrategy.newDefaultStrategy());
    sendRecvData("Wrong length for reading block " + firstBlock.getBlockId(),false);
    sendBuf.reset();
    sender.readBlock(blk,BlockTokenSecretManager.DUMMY_TOKEN,"cl",0L,fileLen,true,CachingStrategy.newDefaultStrategy());
    readFile(fileSys,file,fileLen);
  }
  finally {
    cluster.shutdown();
  }
}
