{
  LOG.info("Need to write " + (limit - skipBytes) + " bytes for erased location index "+ erasedLocationToFix);
  int[] tmp=new int[inputs.length];
  int[] decoded=new int[erasedLocations.length];
  long toDiscard=skipBytes;
  for (long written=0; skipBytes + written < limit; ) {
    erasedLocations=readFromInputs(inputs,erasedLocations,limit);
    if (decoded.length != erasedLocations.length) {
      decoded=new int[erasedLocations.length];
    }
    int toWrite=(int)Math.min((long)bufSize,limit - (skipBytes + written));
    if (toDiscard >= toWrite) {
      toDiscard-=toWrite;
      continue;
    }
    for (int i=0; i < bufSize; i++) {
      performDecode(readBufs,writeBufs,i,tmp,erasedLocations,decoded);
    }
    for (int i=0; i < erasedLocations.length; i++) {
      if (erasedLocations[i] == erasedLocationToFix) {
        toWrite-=toDiscard;
        out.write(writeBufs[i],(int)toDiscard,toWrite);
        toDiscard=0;
        written+=toWrite;
        LOG.debug("Wrote " + toWrite + " bytes for erased location index "+ erasedLocationToFix);
        break;
      }
    }
  }
}
