{
  Status pipelineStatus=SUCCESS;
  String firstBadLink="";
  if (DFSClient.LOG.isDebugEnabled()) {
    for (int i=0; i < nodes.length; i++) {
      DFSClient.LOG.debug("pipeline = " + nodes[i].getName());
    }
  }
  persistBlocks.set(true);
  boolean result=false;
  try {
    s=createSocketForPipeline(nodes[0],nodes.length,dfsClient);
    long writeTimeout=dfsClient.getDatanodeWriteTimeout(nodes.length);
    DataOutputStream out=new DataOutputStream(new BufferedOutputStream(NetUtils.getOutputStream(s,writeTimeout),FSConstants.SMALL_BUFFER_SIZE));
    blockReplyStream=new DataInputStream(NetUtils.getInputStream(s));
    new Sender(out).writeBlock(block,accessToken,dfsClient.clientName,nodes,null,recoveryFlag ? stage.getRecoveryStage() : stage,nodes.length,block.getNumBytes(),bytesSent,newGS);
    checksum.writeHeader(out);
    out.flush();
    BlockOpResponseProto resp=BlockOpResponseProto.parseFrom(HdfsProtoUtil.vintPrefixed(blockReplyStream));
    pipelineStatus=resp.getStatus();
    firstBadLink=resp.getFirstBadLink();
    if (pipelineStatus != SUCCESS) {
      if (pipelineStatus == Status.ERROR_ACCESS_TOKEN) {
        throw new InvalidBlockTokenException("Got access token error for connect ack with firstBadLink as " + firstBadLink);
      }
 else {
        throw new IOException("Bad connect ack with firstBadLink as " + firstBadLink);
      }
    }
    blockStream=out;
    result=true;
  }
 catch (  IOException ie) {
    DFSClient.LOG.info("Exception in createBlockOutputStream " + ie);
    if (firstBadLink.length() != 0) {
      for (int i=0; i < nodes.length; i++) {
        if (nodes[i].getName().equals(firstBadLink)) {
          errorIndex=i;
          break;
        }
      }
    }
 else {
      errorIndex=0;
    }
    hasError=true;
    setLastException(ie);
    blockReplyStream=null;
    result=false;
  }
 finally {
    if (!result) {
      IOUtils.closeSocket(s);
      s=null;
    }
  }
  return result;
}
