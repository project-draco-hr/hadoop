{
  HdfsConfiguration conf=createCachingConf();
  FileSystemTestHelper helper=new FileSystemTestHelper();
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_DATANODES).build();
  try {
    cluster.waitActive();
    DistributedFileSystem dfs=cluster.getFileSystem();
    final NameNode namenode=cluster.getNameNode();
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        return ((namenode.getNamesystem().getCacheCapacity() == (NUM_DATANODES * CACHE_CAPACITY)) && (namenode.getNamesystem().getCacheUsed() == 0));
      }
    }
,500,60000);
    NamenodeProtocols nnRpc=namenode.getRpcServer();
    Path rootDir=helper.getDefaultWorkingDirectory(dfs);
    final String pool="friendlyPool";
    nnRpc.addCachePool(new CachePoolInfo("friendlyPool"));
    final int numFiles=2;
    final int numBlocksPerFile=2;
    final List<String> paths=new ArrayList<String>(numFiles);
    for (int i=0; i < numFiles; i++) {
      Path p=new Path(rootDir,"testCachePaths-" + i);
      FileSystemTestHelper.createFile(dfs,p,numBlocksPerFile,(int)BLOCK_SIZE);
      paths.add(p.toUri().getPath());
    }
    waitForCachedBlocks(namenode,0,0,"testWaitForCachedReplicas:0");
    int expected=0;
    for (int i=0; i < numFiles; i++) {
      CacheDirectiveInfo directive=new CacheDirectiveInfo.Builder().setPath(new Path(paths.get(i))).setPool(pool).build();
      nnRpc.addCacheDirective(directive);
      expected+=numBlocksPerFile;
      waitForCachedBlocks(namenode,expected,expected,"testWaitForCachedReplicas:1");
    }
    RemoteIterator<CacheDirectiveEntry> entries=new CacheDirectiveIterator(nnRpc,null);
    for (int i=0; i < numFiles; i++) {
      CacheDirectiveEntry entry=entries.next();
      nnRpc.removeCacheDirective(entry.getInfo().getId());
      expected-=numBlocksPerFile;
      waitForCachedBlocks(namenode,expected,expected,"testWaitForCachedReplicas:2");
    }
  }
  finally {
    cluster.shutdown();
  }
}
