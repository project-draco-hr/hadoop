{
  NodeStatus remoteNodeStatus=request.getNodeStatus();
  NodeId nodeId=remoteNodeStatus.getNodeId();
  RMNode rmNode=this.rmContext.getRMNodes().get(nodeId);
  if (rmNode == null) {
    String message="Node not found rebooting " + remoteNodeStatus.getNodeId();
    LOG.info(message);
    resync.setDiagnosticsMessage(message);
    return resync;
  }
  this.nmLivelinessMonitor.receivedPing(nodeId);
  if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {
    String message="Disallowed NodeManager nodeId: " + nodeId + " hostname: "+ rmNode.getNodeAddress();
    LOG.info(message);
    shutDown.setDiagnosticsMessage(message);
    this.rmContext.getDispatcher().getEventHandler().handle(new RMNodeEvent(nodeId,RMNodeEventType.DECOMMISSION));
    return shutDown;
  }
  NodeHeartbeatResponse lastNodeHeartbeatResponse=rmNode.getLastNodeHeartBeatResponse();
  if (remoteNodeStatus.getResponseId() + 1 == lastNodeHeartbeatResponse.getResponseId()) {
    LOG.info("Received duplicate heartbeat from node " + rmNode.getNodeAddress());
    return lastNodeHeartbeatResponse;
  }
 else   if (remoteNodeStatus.getResponseId() + 1 < lastNodeHeartbeatResponse.getResponseId()) {
    String message="Too far behind rm response id:" + lastNodeHeartbeatResponse.getResponseId() + " nm response id:"+ remoteNodeStatus.getResponseId();
    LOG.info(message);
    resync.setDiagnosticsMessage(message);
    this.rmContext.getDispatcher().getEventHandler().handle(new RMNodeEvent(nodeId,RMNodeEventType.REBOOTING));
    return resync;
  }
  NodeHeartbeatResponse nodeHeartBeatResponse=YarnServerBuilderUtils.newNodeHeartbeatResponse(lastNodeHeartbeatResponse.getResponseId() + 1,NodeAction.NORMAL,null,null,null,nextHeartBeatInterval);
  rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);
  if (isSecurityEnabled()) {
    boolean shouldSendMasterKey=false;
    MasterKey nextMasterKeyForNode=this.containerTokenSecretManager.getNextKey();
    if (nextMasterKeyForNode != null) {
      MasterKey nodeKnownMasterKey=request.getLastKnownMasterKey();
      if (nodeKnownMasterKey.getKeyId() != nextMasterKeyForNode.getKeyId()) {
        shouldSendMasterKey=true;
      }
    }
    if (shouldSendMasterKey) {
      nodeHeartBeatResponse.setMasterKey(nextMasterKeyForNode);
    }
  }
  this.rmContext.getDispatcher().getEventHandler().handle(new RMNodeStatusEvent(nodeId,remoteNodeStatus.getNodeHealthStatus(),remoteNodeStatus.getContainersStatuses(),remoteNodeStatus.getKeepAliveApplications(),nodeHeartBeatResponse));
  return nodeHeartBeatResponse;
}
