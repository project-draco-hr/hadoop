{
  RMNodeStatusEvent statusEvent=(RMNodeStatusEvent)event;
  rmNode.latestHeartBeatResponse=statusEvent.getLatestResponse();
  NodeHealthStatus remoteNodeHealthStatus=statusEvent.getNodeHealthStatus();
  rmNode.setNodeHealthStatus(remoteNodeHealthStatus);
  if (!remoteNodeHealthStatus.getIsNodeHealthy()) {
    rmNode.context.getDispatcher().getEventHandler().handle(new NodeRemovedSchedulerEvent(rmNode));
    rmNode.updateMetricsForDeactivatedNode(RMNodeState.UNHEALTHY);
    return RMNodeState.UNHEALTHY;
  }
  List<ContainerStatus> newlyLaunchedContainers=new ArrayList<ContainerStatus>();
  List<ContainerStatus> completedContainers=new ArrayList<ContainerStatus>();
  for (  ContainerStatus remoteContainer : statusEvent.getContainers()) {
    ContainerId containerId=remoteContainer.getContainerId();
    if (rmNode.containersToClean.contains(containerId)) {
      LOG.info("Container " + containerId + " already scheduled for "+ "cleanup, no further processing");
      continue;
    }
    if (rmNode.finishedApplications.contains(containerId.getApplicationAttemptId().getApplicationId())) {
      LOG.info("Container " + containerId + " belongs to an application that is already killed,"+ " no further processing");
      continue;
    }
    if (remoteContainer.getState() == ContainerState.RUNNING) {
      if (!rmNode.justLaunchedContainers.containsKey(containerId)) {
        rmNode.justLaunchedContainers.put(containerId,remoteContainer);
        newlyLaunchedContainers.add(remoteContainer);
      }
    }
 else {
      rmNode.justLaunchedContainers.remove(containerId);
      completedContainers.add(remoteContainer);
    }
  }
  rmNode.context.getDispatcher().getEventHandler().handle(new NodeUpdateSchedulerEvent(rmNode,newlyLaunchedContainers,completedContainers));
  rmNode.context.getDelegationTokenRenewer().updateKeepAliveApplications(statusEvent.getKeepAliveAppIds());
  rmNode.containersToClean.clear();
  rmNode.finishedApplications.clear();
  return RMNodeState.RUNNING;
}
