{
  DataInputStream inStream=new DataInputStream(new BufferedInputStream(inS));
  DataOutputStream outStream=new DataOutputStream(new BufferedOutputStream(outS));
  authMethod=AuthMethod.SIMPLE;
  sendSaslMessage(outStream,negotiateRequest);
  boolean done=false;
  do {
    int totalLen=inStream.readInt();
    RpcResponseMessageWrapper responseWrapper=new RpcResponseMessageWrapper();
    responseWrapper.readFields(inStream);
    RpcResponseHeaderProto header=responseWrapper.getMessageHeader();
switch (header.getStatus()) {
case ERROR:
case FATAL:
      throw new RemoteException(header.getExceptionClassName(),header.getErrorMsg());
default :
    break;
}
if (totalLen != responseWrapper.getLength()) {
  throw new SaslException("Received malformed response length");
}
if (header.getCallId() != AuthProtocol.SASL.callId) {
  throw new SaslException("Non-SASL response during negotiation");
}
RpcSaslProto saslMessage=RpcSaslProto.parseFrom(responseWrapper.getMessageBytes());
if (LOG.isDebugEnabled()) {
  LOG.debug("Received SASL message " + saslMessage);
}
RpcSaslProto.Builder response=null;
switch (saslMessage.getState()) {
case NEGOTIATE:
{
    SaslAuth saslAuthType=selectSaslClient(saslMessage.getAuthsList());
    authMethod=AuthMethod.valueOf(saslAuthType.getMethod());
    byte[] responseToken=null;
    if (authMethod == AuthMethod.SIMPLE) {
      done=true;
    }
 else {
      byte[] challengeToken=null;
      if (saslAuthType.hasChallenge()) {
        challengeToken=saslAuthType.getChallenge().toByteArray();
        saslAuthType=SaslAuth.newBuilder(saslAuthType).clearChallenge().build();
      }
 else       if (saslClient.hasInitialResponse()) {
        challengeToken=new byte[0];
      }
      responseToken=(challengeToken != null) ? saslClient.evaluateChallenge(challengeToken) : new byte[0];
    }
    response=createSaslReply(SaslState.INITIATE,responseToken);
    response.addAuths(saslAuthType);
    break;
  }
case CHALLENGE:
{
  if (saslClient == null) {
    throw new SaslException("Server sent unsolicited challenge");
  }
  byte[] responseToken=saslEvaluateToken(saslMessage,false);
  response=createSaslReply(SaslState.RESPONSE,responseToken);
  break;
}
case SUCCESS:
{
if (saslClient == null) {
  authMethod=AuthMethod.SIMPLE;
}
 else {
  saslEvaluateToken(saslMessage,true);
}
done=true;
break;
}
default :
{
throw new SaslException("RPC client doesn't support SASL " + saslMessage.getState());
}
}
if (response != null) {
sendSaslMessage(outStream,response.build());
}
}
 while (!done);
return authMethod;
}
