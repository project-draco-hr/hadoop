{
  LOG.debug("Node offered to queue: " + this.getName() + " reserved: "+ reserved);
  if (Resources.greaterThan(this.getResourceUsage(),queueMgr.getMaxResources(queue.getName()))) {
    return Resources.none();
  }
  if (reserved) {
    for (    AppSchedulable sched : appScheds) {
      if (sched.getApp().getApplicationAttemptId() == node.getReservedContainer().getApplicationAttemptId()) {
        return sched.assignContainer(node,reserved);
      }
    }
    return Resources.none();
  }
 else {
    SchedulingMode mode=queue.getSchedulingMode();
    Comparator<Schedulable> comparator;
    if (mode == SchedulingMode.FIFO) {
      comparator=new SchedulingAlgorithms.FifoComparator();
    }
 else     if (mode == SchedulingMode.FAIR) {
      comparator=new SchedulingAlgorithms.FairShareComparator();
    }
 else {
      throw new RuntimeException("Unsupported queue scheduling mode " + mode);
    }
    Collections.sort(appScheds,comparator);
    for (    AppSchedulable sched : appScheds) {
      return sched.assignContainer(node,reserved);
    }
    return Resources.none();
  }
}
