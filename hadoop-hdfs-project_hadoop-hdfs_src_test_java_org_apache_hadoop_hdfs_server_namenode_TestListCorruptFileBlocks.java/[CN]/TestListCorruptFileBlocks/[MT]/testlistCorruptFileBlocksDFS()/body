{
  Configuration conf=new Configuration();
  conf.setLong(DFSConfigKeys.DFS_BLOCKREPORT_INTERVAL_MSEC_KEY,1000);
  conf.setInt(DFSConfigKeys.DFS_DATANODE_DIRECTORYSCAN_INTERVAL_KEY,1);
  FileSystem fs=null;
  MiniDFSCluster cluster=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    DistributedFileSystem dfs=(DistributedFileSystem)fs;
    DFSTestUtil util=new DFSTestUtil.Builder().setName("testGetCorruptFiles").setNumFiles(3).setMaxLevels(1).setMaxSize(1024).build();
    util.createFiles(fs,"/corruptData");
    RemoteIterator<Path> corruptFileBlocks=dfs.listCorruptFileBlocks(new Path("/corruptData"));
    int numCorrupt=countPaths(corruptFileBlocks);
    assertTrue(numCorrupt == 0);
    String bpid=cluster.getNamesystem().getBlockPoolId();
    for (int i=0; i < 2; i++) {
      File storageDir=cluster.getInstanceStorageDir(0,i);
      File data_dir=MiniDFSCluster.getFinalizedDir(storageDir,bpid);
      File[] blocks=data_dir.listFiles();
      if (blocks == null)       continue;
      for (int idx=0; idx < blocks.length; idx++) {
        if (!blocks[idx].getName().startsWith("blk_")) {
          continue;
        }
        LOG.info("Deliberately removing file " + blocks[idx].getName());
        assertTrue("Cannot remove file.",blocks[idx].delete());
      }
    }
    int count=0;
    corruptFileBlocks=dfs.listCorruptFileBlocks(new Path("/corruptData"));
    numCorrupt=countPaths(corruptFileBlocks);
    while (numCorrupt < 3) {
      Thread.sleep(1000);
      corruptFileBlocks=dfs.listCorruptFileBlocks(new Path("/corruptData"));
      numCorrupt=countPaths(corruptFileBlocks);
      count++;
      if (count > 30)       break;
    }
    LOG.info("Namenode has bad files. " + numCorrupt);
    assertTrue(numCorrupt == 3);
    util.cleanup(fs,"/corruptData");
    util.cleanup(fs,"/goodData");
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}
