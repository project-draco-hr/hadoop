{
  final int FETCHER=7;
  Path p=new Path("file:///tmp/foo");
  Path pTmp=OnDiskMapOutput.getTempPath(p,FETCHER);
  FileSystem mFs=mock(FileSystem.class,RETURNS_DEEP_STUBS);
  MapOutputFile mof=mock(MapOutputFile.class);
  when(mof.getInputFileForWrite(any(TaskID.class),anyLong())).thenReturn(p);
  OnDiskMapOutput<Text,Text> odmo=spy(new OnDiskMapOutput<Text,Text>(map1ID,id,mm,100L,job,mof,FETCHER,true,mFs,p));
  when(mm.reserve(any(TaskAttemptID.class),anyLong(),anyInt())).thenReturn(odmo);
  doNothing().when(mm).waitForResource();
  when(ss.getHost()).thenReturn(host);
  String replyHash=SecureShuffleUtils.generateHash(encHash.getBytes(),key);
  when(connection.getResponseCode()).thenReturn(200);
  when(connection.getHeaderField(SecureShuffleUtils.HTTP_HEADER_REPLY_URL_HASH)).thenReturn(replyHash);
  ShuffleHeader header=new ShuffleHeader(map1ID.toString(),10,10,1);
  ByteArrayOutputStream bout=new ByteArrayOutputStream();
  header.write(new DataOutputStream(bout));
  final StuckInputStream in=new StuckInputStream(new ByteArrayInputStream(bout.toByteArray()));
  when(connection.getInputStream()).thenReturn(in);
  doAnswer(new Answer<Void>(){
    public Void answer(    InvocationOnMock ignore) throws IOException {
      in.close();
      return null;
    }
  }
).when(connection).disconnect();
  Fetcher<Text,Text> underTest=new FakeFetcher<Text,Text>(job,id,ss,mm,r,metrics,except,key,connection,FETCHER);
  underTest.start();
  in.waitForFetcher();
  underTest.shutDown();
  underTest.join();
  assertTrue(in.wasClosedProperly());
  verify(mFs).create(eq(pTmp));
  verify(mFs).delete(eq(pTmp),eq(false));
  verify(odmo).abort();
}
