{
  statusUpdaterRunnable=new Runnable(){
    @Override @SuppressWarnings("unchecked") public void run(){
      int lastHeartbeatID=0;
      Set<NodeLabel> lastUpdatedNodeLabelsToRM=null;
      if (hasNodeLabelsProvider) {
        lastUpdatedNodeLabelsToRM=nodeLabelsProvider.getNodeLabels();
        lastUpdatedNodeLabelsToRM=(null == lastUpdatedNodeLabelsToRM) ? CommonNodeLabelsManager.EMPTY_NODELABEL_SET : lastUpdatedNodeLabelsToRM;
      }
      while (!isStopped) {
        try {
          NodeHeartbeatResponse response=null;
          Set<NodeLabel> nodeLabelsForHeartbeat=null;
          NodeStatus nodeStatus=getNodeStatus(lastHeartbeatID);
          if (hasNodeLabelsProvider) {
            nodeLabelsForHeartbeat=nodeLabelsProvider.getNodeLabels();
            nodeLabelsForHeartbeat=(nodeLabelsForHeartbeat == null) ? CommonNodeLabelsManager.EMPTY_NODELABEL_SET : nodeLabelsForHeartbeat;
            if (!areNodeLabelsUpdated(nodeLabelsForHeartbeat,lastUpdatedNodeLabelsToRM)) {
              nodeLabelsForHeartbeat=null;
            }
          }
          NodeHeartbeatRequest request=NodeHeartbeatRequest.newInstance(nodeStatus,NodeStatusUpdaterImpl.this.context.getContainerTokenSecretManager().getCurrentKey(),NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager().getCurrentKey(),nodeLabelsForHeartbeat);
          if (logAggregationEnabled) {
            List<LogAggregationReport> logAggregationReports=getLogAggregationReportsForApps(context.getLogAggregationStatusForApps());
            if (logAggregationReports != null && !logAggregationReports.isEmpty()) {
              request.setLogAggregationReportsForApps(logAggregationReports);
            }
          }
          response=resourceTracker.nodeHeartbeat(request);
          nextHeartBeatInterval=response.getNextHeartBeatInterval();
          updateMasterKeys(response);
          if (response.getNodeAction() == NodeAction.SHUTDOWN) {
            LOG.warn("Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat," + " hence shutting down.");
            LOG.warn("Message from ResourceManager: " + response.getDiagnosticsMessage());
            context.setDecommissioned(true);
            dispatcher.getEventHandler().handle(new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));
            break;
          }
          if (response.getNodeAction() == NodeAction.RESYNC) {
            LOG.warn("Node is out of sync with ResourceManager," + " hence resyncing.");
            LOG.warn("Message from ResourceManager: " + response.getDiagnosticsMessage());
            NodeStatusUpdaterImpl.this.rmIdentifier=ResourceManagerConstants.RM_INVALID_IDENTIFIER;
            dispatcher.getEventHandler().handle(new NodeManagerEvent(NodeManagerEventType.RESYNC));
            pendingCompletedContainers.clear();
            break;
          }
          if (response.getAreNodeLabelsAcceptedByRM()) {
            lastUpdatedNodeLabelsToRM=nodeLabelsForHeartbeat;
            LOG.info("Node Labels {" + StringUtils.join(",",nodeLabelsForHeartbeat) + "} were Accepted by RM ");
          }
 else           if (nodeLabelsForHeartbeat != null) {
            LOG.error(response.getDiagnosticsMessage());
          }
          removeOrTrackCompletedContainersFromContext(response.getContainersToBeRemovedFromNM());
          logAggregationReportForAppsTempList.clear();
          lastHeartbeatID=response.getResponseId();
          List<ContainerId> containersToCleanup=response.getContainersToCleanup();
          if (!containersToCleanup.isEmpty()) {
            dispatcher.getEventHandler().handle(new CMgrCompletedContainersEvent(containersToCleanup,CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));
          }
          List<ApplicationId> appsToCleanup=response.getApplicationsToCleanup();
          trackAppsForKeepAlive(appsToCleanup);
          if (!appsToCleanup.isEmpty()) {
            dispatcher.getEventHandler().handle(new CMgrCompletedAppsEvent(appsToCleanup,CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));
          }
          Map<ApplicationId,ByteBuffer> systemCredentials=response.getSystemCredentialsForApps();
          if (systemCredentials != null && !systemCredentials.isEmpty()) {
            ((NMContext)context).setSystemCrendentialsForApps(parseCredentials(systemCredentials));
          }
        }
 catch (        ConnectException e) {
          dispatcher.getEventHandler().handle(new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));
          throw new YarnRuntimeException(e);
        }
catch (        Throwable e) {
          LOG.error("Caught exception in status-updater",e);
        }
 finally {
synchronized (heartbeatMonitor) {
            nextHeartBeatInterval=nextHeartBeatInterval <= 0 ? YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS : nextHeartBeatInterval;
            try {
              heartbeatMonitor.wait(nextHeartBeatInterval);
            }
 catch (            InterruptedException e) {
            }
          }
        }
      }
    }
    /** 
 * Caller should take care of sending non null nodelabels for both
 * arguments
 * @param nodeLabelsNew
 * @param nodeLabelsOld
 * @return if the New node labels are diff from the older one.
 */
    private boolean areNodeLabelsUpdated(    Set<NodeLabel> nodeLabelsNew,    Set<NodeLabel> nodeLabelsOld){
      if (nodeLabelsNew.size() != nodeLabelsOld.size() || !nodeLabelsOld.containsAll(nodeLabelsNew)) {
        return true;
      }
      return false;
    }
    private void updateMasterKeys(    NodeHeartbeatResponse response){
      MasterKey updatedMasterKey=response.getContainerTokenMasterKey();
      if (updatedMasterKey != null) {
        context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);
      }
      updatedMasterKey=response.getNMTokenMasterKey();
      if (updatedMasterKey != null) {
        context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);
      }
    }
  }
;
  statusUpdater=new Thread(statusUpdaterRunnable,"Node Status Updater");
  statusUpdater.start();
}
