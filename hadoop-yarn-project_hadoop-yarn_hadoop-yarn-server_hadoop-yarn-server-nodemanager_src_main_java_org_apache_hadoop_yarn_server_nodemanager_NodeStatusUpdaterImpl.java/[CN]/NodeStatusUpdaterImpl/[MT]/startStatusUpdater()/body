{
  statusUpdaterRunnable=new Runnable(){
    @Override @SuppressWarnings("unchecked") public void run(){
      int lastHeartBeatID=0;
      while (!isStopped) {
        try {
          NodeHeartbeatResponse response=null;
          int rmRetryCount=0;
          long waitStartTime=System.currentTimeMillis();
          NodeStatus nodeStatus=getNodeStatusAndUpdateContainersInContext();
          nodeStatus.setResponseId(lastHeartBeatID);
          NodeHeartbeatRequest request=recordFactory.newRecordInstance(NodeHeartbeatRequest.class);
          request.setNodeStatus(nodeStatus);
          request.setLastKnownContainerTokenMasterKey(NodeStatusUpdaterImpl.this.context.getContainerTokenSecretManager().getCurrentKey());
          request.setLastKnownNMTokenMasterKey(NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager().getCurrentKey());
          while (!isStopped) {
            try {
              rmRetryCount++;
              response=resourceTracker.nodeHeartbeat(request);
              break;
            }
 catch (            Throwable e) {
              LOG.warn("Trying to heartbeat to ResourceManager, " + "current no. of failed attempts is " + rmRetryCount);
              if (System.currentTimeMillis() - waitStartTime < rmConnectWaitMS || waitForEver) {
                try {
                  LOG.info("Sleeping for " + rmConnectionRetryIntervalMS / 1000 + " seconds before next heartbeat to RM");
                  Thread.sleep(rmConnectionRetryIntervalMS);
                }
 catch (                InterruptedException ex) {
                }
              }
 else {
                String errorMessage="Failed to heartbeat to RM, " + "no. of failed attempts is " + rmRetryCount;
                LOG.error(errorMessage,e);
                throw new YarnRuntimeException(errorMessage,e);
              }
            }
          }
          nextHeartBeatInterval=response.getNextHeartBeatInterval();
          updateMasterKeys(response);
          if (response.getNodeAction() == NodeAction.SHUTDOWN) {
            LOG.warn("Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat," + " hence shutting down.");
            LOG.warn("Message from ResourceManager: " + response.getDiagnosticsMessage());
            dispatcher.getEventHandler().handle(new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));
            break;
          }
          if (response.getNodeAction() == NodeAction.RESYNC) {
            LOG.warn("Node is out of sync with ResourceManager," + " hence rebooting.");
            LOG.warn("Message from ResourceManager: " + response.getDiagnosticsMessage());
            NodeStatusUpdaterImpl.this.rmIdentifier=ResourceManagerConstants.RM_INVALID_IDENTIFIER;
            dispatcher.getEventHandler().handle(new NodeManagerEvent(NodeManagerEventType.RESYNC));
            break;
          }
          lastHeartBeatID=response.getResponseId();
          List<ContainerId> containersToCleanup=response.getContainersToCleanup();
          if (containersToCleanup.size() != 0) {
            dispatcher.getEventHandler().handle(new CMgrCompletedContainersEvent(containersToCleanup,CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));
          }
          List<ApplicationId> appsToCleanup=response.getApplicationsToCleanup();
          trackAppsForKeepAlive(appsToCleanup);
          if (appsToCleanup.size() != 0) {
            dispatcher.getEventHandler().handle(new CMgrCompletedAppsEvent(appsToCleanup));
          }
        }
 catch (        YarnRuntimeException e) {
          dispatcher.getEventHandler().handle(new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));
          throw e;
        }
catch (        Throwable e) {
          LOG.error("Caught exception in status-updater",e);
        }
 finally {
synchronized (heartbeatMonitor) {
            nextHeartBeatInterval=nextHeartBeatInterval <= 0 ? YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS : nextHeartBeatInterval;
            try {
              heartbeatMonitor.wait(nextHeartBeatInterval);
            }
 catch (            InterruptedException e) {
            }
          }
        }
      }
    }
    private void updateMasterKeys(    NodeHeartbeatResponse response){
      MasterKey updatedMasterKey=response.getContainerTokenMasterKey();
      if (updatedMasterKey != null) {
        context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);
      }
      updatedMasterKey=response.getNMTokenMasterKey();
      if (updatedMasterKey != null) {
        context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);
      }
    }
  }
;
  statusUpdater=new Thread(statusUpdaterRunnable,"Node Status Updater");
  statusUpdater.start();
}
