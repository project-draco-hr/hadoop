{
  for (Iterator<CachedBlock> cbIter=cachedBlocks.iterator(); cbIter.hasNext(); ) {
    scannedBlocks++;
    CachedBlock cblock=cbIter.next();
    List<DatanodeDescriptor> pendingCached=cblock.getDatanodes(Type.PENDING_CACHED);
    List<DatanodeDescriptor> cached=cblock.getDatanodes(Type.CACHED);
    List<DatanodeDescriptor> pendingUncached=cblock.getDatanodes(Type.PENDING_UNCACHED);
    for (Iterator<DatanodeDescriptor> iter=pendingUncached.iterator(); iter.hasNext(); ) {
      DatanodeDescriptor datanode=iter.next();
      if (!cblock.isInList(datanode.getCached())) {
        if (LOG.isTraceEnabled()) {
          LOG.trace("Block " + cblock.getBlockId() + ": removing from "+ "PENDING_UNCACHED for node "+ datanode.getDatanodeUuid()+ "because the DataNode uncached it.");
        }
        datanode.getPendingUncached().remove(cblock);
        iter.remove();
      }
    }
    BlockInfo blockInfo=blockManager.getStoredBlock(new Block(cblock.getBlockId()));
    String reason=findReasonForNotCaching(cblock,blockInfo);
    int neededCached=0;
    if (reason != null) {
      if (LOG.isTraceEnabled()) {
        LOG.trace("Block " + cblock.getBlockId() + ": can't cache "+ "block because it is "+ reason);
      }
    }
 else {
      neededCached=cblock.getReplication();
    }
    int numCached=cached.size();
    if (numCached >= neededCached) {
      for (Iterator<DatanodeDescriptor> iter=pendingCached.iterator(); iter.hasNext(); ) {
        DatanodeDescriptor datanode=iter.next();
        datanode.getPendingCached().remove(cblock);
        iter.remove();
        if (LOG.isTraceEnabled()) {
          LOG.trace("Block " + cblock.getBlockId() + ": removing from "+ "PENDING_CACHED for node "+ datanode.getDatanodeUuid()+ "because we already have "+ numCached+ " cached "+ "replicas and we only need "+ neededCached);
        }
      }
    }
    if (numCached < neededCached) {
      for (Iterator<DatanodeDescriptor> iter=pendingUncached.iterator(); iter.hasNext(); ) {
        DatanodeDescriptor datanode=iter.next();
        datanode.getPendingUncached().remove(cblock);
        iter.remove();
        if (LOG.isTraceEnabled()) {
          LOG.trace("Block " + cblock.getBlockId() + ": removing from "+ "PENDING_UNCACHED for node "+ datanode.getDatanodeUuid()+ "because we only have "+ numCached+ " cached replicas "+ "and we need "+ neededCached);
        }
      }
    }
    int neededUncached=numCached - (pendingUncached.size() + neededCached);
    if (neededUncached > 0) {
      addNewPendingUncached(neededUncached,cblock,cached,pendingUncached);
    }
 else {
      int additionalCachedNeeded=neededCached - (numCached + pendingCached.size());
      if (additionalCachedNeeded > 0) {
        addNewPendingCached(additionalCachedNeeded,cblock,cached,pendingCached);
      }
    }
    if ((neededCached == 0) && pendingUncached.isEmpty() && pendingCached.isEmpty()) {
      if (LOG.isTraceEnabled()) {
        LOG.trace("Block " + cblock.getBlockId() + ": removing from "+ "cachedBlocks, since neededCached == 0, and "+ "pendingUncached and pendingCached are empty.");
      }
      cbIter.remove();
    }
  }
}
