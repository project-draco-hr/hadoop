{
  BlockInfoContiguous blockInfo=namesystem.getStoredBlock(new Block(cachedBlock.getBlockId()));
  if (blockInfo == null) {
    LOG.debug("Block {}: can't add new cached replicas," + " because there is no record of this block " + "on the NameNode.",cachedBlock.getBlockId());
    return;
  }
  if (!blockInfo.isComplete()) {
    LOG.debug("Block {}: can't cache this block, because it is not yet" + " complete.",cachedBlock.getBlockId());
    return;
  }
  List<DatanodeDescriptor> possibilities=new LinkedList<DatanodeDescriptor>();
  int numReplicas=blockInfo.getCapacity();
  Collection<DatanodeDescriptor> corrupt=blockManager.getCorruptReplicas(blockInfo);
  int outOfCapacity=0;
  for (int i=0; i < numReplicas; i++) {
    DatanodeDescriptor datanode=blockInfo.getDatanode(i);
    if (datanode == null) {
      continue;
    }
    if (datanode.isDecommissioned() || datanode.isDecommissionInProgress()) {
      continue;
    }
    if (corrupt != null && corrupt.contains(datanode)) {
      continue;
    }
    if (pendingCached.contains(datanode) || cached.contains(datanode)) {
      continue;
    }
    long pendingBytes=0;
    Iterator<CachedBlock> it=datanode.getPendingCached().iterator();
    while (it.hasNext()) {
      CachedBlock cBlock=it.next();
      BlockInfoContiguous info=namesystem.getStoredBlock(new Block(cBlock.getBlockId()));
      if (info != null) {
        pendingBytes-=info.getNumBytes();
      }
    }
    it=datanode.getPendingUncached().iterator();
    while (it.hasNext()) {
      CachedBlock cBlock=it.next();
      BlockInfoContiguous info=namesystem.getStoredBlock(new Block(cBlock.getBlockId()));
      if (info != null) {
        pendingBytes+=info.getNumBytes();
      }
    }
    long pendingCapacity=pendingBytes + datanode.getCacheRemaining();
    if (pendingCapacity < blockInfo.getNumBytes()) {
      LOG.trace("Block {}: DataNode {} is not a valid possibility " + "because the block has size {}, but the DataNode only has {}" + "bytes of cache remaining ({} pending bytes, {} already cached.",blockInfo.getBlockId(),datanode.getDatanodeUuid(),blockInfo.getNumBytes(),pendingCapacity,pendingBytes,datanode.getCacheRemaining());
      outOfCapacity++;
      continue;
    }
    possibilities.add(datanode);
  }
  List<DatanodeDescriptor> chosen=chooseDatanodesForCaching(possibilities,neededCached,blockManager.getDatanodeManager().getStaleInterval());
  for (  DatanodeDescriptor datanode : chosen) {
    LOG.trace("Block {}: added to PENDING_CACHED on DataNode {}",blockInfo.getBlockId(),datanode.getDatanodeUuid());
    pendingCached.add(datanode);
    boolean added=datanode.getPendingCached().add(cachedBlock);
    assert added;
  }
  if (neededCached > chosen.size()) {
    LOG.debug("Block {}: we only have {} of {} cached replicas." + " {} DataNodes have insufficient cache capacity.",blockInfo.getBlockId(),(cachedBlock.getReplication() - neededCached + chosen.size()),cachedBlock.getReplication(),outOfCapacity);
  }
}
