{
  BlockInfo blockInfo=blockManager.getStoredBlock(new Block(cachedBlock.getBlockId()));
  if (blockInfo == null) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Not caching block " + cachedBlock + " because there "+ "is no record of it on the NameNode.");
    }
    return;
  }
  if (!blockInfo.isComplete()) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Not caching block " + cachedBlock + " because it "+ "is not yet complete.");
    }
    return;
  }
  List<DatanodeDescriptor> possibilities=new LinkedList<DatanodeDescriptor>();
  int numReplicas=blockInfo.getCapacity();
  Collection<DatanodeDescriptor> corrupt=blockManager.getCorruptReplicas(blockInfo);
  int outOfCapacity=0;
  for (int i=0; i < numReplicas; i++) {
    DatanodeDescriptor datanode=blockInfo.getDatanode(i);
    if (datanode == null) {
      continue;
    }
    if (datanode.isDecommissioned() || datanode.isDecommissionInProgress()) {
      continue;
    }
    if (corrupt != null && corrupt.contains(datanode)) {
      continue;
    }
    if (pendingCached.contains(datanode) || cached.contains(datanode)) {
      continue;
    }
    long pendingCapacity=datanode.getCacheRemaining();
    Iterator<CachedBlock> it=datanode.getPendingCached().iterator();
    while (it.hasNext()) {
      CachedBlock cBlock=it.next();
      BlockInfo info=blockManager.getStoredBlock(new Block(cBlock.getBlockId()));
      if (info != null) {
        pendingCapacity-=info.getNumBytes();
      }
    }
    it=datanode.getPendingUncached().iterator();
    while (it.hasNext()) {
      CachedBlock cBlock=it.next();
      BlockInfo info=blockManager.getStoredBlock(new Block(cBlock.getBlockId()));
      if (info != null) {
        pendingCapacity+=info.getNumBytes();
      }
    }
    if (pendingCapacity < blockInfo.getNumBytes()) {
      if (LOG.isTraceEnabled()) {
        LOG.trace("Datanode " + datanode + " is not a valid possibility for"+ " block "+ blockInfo.getBlockId()+ " of size "+ blockInfo.getNumBytes()+ " bytes, only has "+ datanode.getCacheRemaining()+ " bytes of cache remaining.");
      }
      outOfCapacity++;
      continue;
    }
    possibilities.add(datanode);
  }
  List<DatanodeDescriptor> chosen=chooseDatanodesForCaching(possibilities,neededCached,blockManager.getDatanodeManager().getStaleInterval());
  for (  DatanodeDescriptor datanode : chosen) {
    pendingCached.add(datanode);
    boolean added=datanode.getPendingCached().add(cachedBlock);
    assert added;
  }
  if (neededCached > chosen.size()) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Only have " + (cachedBlock.getReplication() - neededCached + chosen.size()) + " of "+ cachedBlock.getReplication()+ " cached replicas for "+ cachedBlock+ " ("+ outOfCapacity+ " nodes have insufficient "+ "capacity).");
    }
  }
}
