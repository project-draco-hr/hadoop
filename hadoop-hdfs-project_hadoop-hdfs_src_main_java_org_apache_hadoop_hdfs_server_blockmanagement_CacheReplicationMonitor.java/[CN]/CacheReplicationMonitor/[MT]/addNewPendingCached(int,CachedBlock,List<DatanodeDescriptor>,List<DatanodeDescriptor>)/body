{
  BlockInfo blockInfo=blockManager.getStoredBlock(new Block(cachedBlock.getBlockId()));
  if (blockInfo == null) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Block " + cachedBlock.getBlockId() + ": can't add new "+ "cached replicas, because there is no record of this block "+ "on the NameNode.");
    }
    return;
  }
  if (!blockInfo.isComplete()) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Block " + cachedBlock.getBlockId() + ": can't cache this "+ "block, because it is not yet complete.");
    }
    return;
  }
  List<DatanodeDescriptor> possibilities=new LinkedList<DatanodeDescriptor>();
  int numReplicas=blockInfo.getCapacity();
  Collection<DatanodeDescriptor> corrupt=blockManager.getCorruptReplicas(blockInfo);
  int outOfCapacity=0;
  for (int i=0; i < numReplicas; i++) {
    DatanodeDescriptor datanode=blockInfo.getDatanode(i);
    if (datanode == null) {
      continue;
    }
    if (datanode.isDecommissioned() || datanode.isDecommissionInProgress()) {
      continue;
    }
    if (corrupt != null && corrupt.contains(datanode)) {
      continue;
    }
    if (pendingCached.contains(datanode) || cached.contains(datanode)) {
      continue;
    }
    long pendingCapacity=datanode.getCacheRemaining();
    Iterator<CachedBlock> it=datanode.getPendingCached().iterator();
    while (it.hasNext()) {
      CachedBlock cBlock=it.next();
      BlockInfo info=blockManager.getStoredBlock(new Block(cBlock.getBlockId()));
      if (info != null) {
        pendingCapacity-=info.getNumBytes();
      }
    }
    it=datanode.getPendingUncached().iterator();
    while (it.hasNext()) {
      CachedBlock cBlock=it.next();
      BlockInfo info=blockManager.getStoredBlock(new Block(cBlock.getBlockId()));
      if (info != null) {
        pendingCapacity+=info.getNumBytes();
      }
    }
    if (pendingCapacity < blockInfo.getNumBytes()) {
      if (LOG.isTraceEnabled()) {
        LOG.trace("Block " + blockInfo.getBlockId() + ": DataNode "+ datanode.getDatanodeUuid()+ " is not a valid possibility "+ "because the block has size "+ blockInfo.getNumBytes()+ ", but "+ "the DataNode only has "+ datanode.getCacheRemaining()+ " "+ "bytes of cache remaining.");
      }
      outOfCapacity++;
      continue;
    }
    possibilities.add(datanode);
  }
  List<DatanodeDescriptor> chosen=chooseDatanodesForCaching(possibilities,neededCached,blockManager.getDatanodeManager().getStaleInterval());
  for (  DatanodeDescriptor datanode : chosen) {
    if (LOG.isTraceEnabled()) {
      LOG.trace("Block " + blockInfo.getBlockId() + ": added to "+ "PENDING_CACHED on DataNode "+ datanode.getDatanodeUuid());
    }
    pendingCached.add(datanode);
    boolean added=datanode.getPendingCached().add(cachedBlock);
    assert added;
  }
  if (neededCached > chosen.size()) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Block " + blockInfo.getBlockId() + ": we only have "+ (cachedBlock.getReplication() - neededCached + chosen.size())+ " of "+ cachedBlock.getReplication()+ " cached replicas.  "+ outOfCapacity+ " DataNodes have insufficient cache capacity.");
    }
  }
}
