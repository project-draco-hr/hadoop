{
  startTimeMs=0;
  LOG.info("Starting CacheReplicationMonitor with interval " + intervalMs + " milliseconds");
  try {
    long curTimeMs=Time.monotonicNow();
    while (true) {
      lock.lock();
      try {
        while (true) {
          if (shutdown) {
            LOG.info("Shutting down CacheReplicationMonitor");
            return;
          }
          if (needsRescan) {
            LOG.info("Rescanning because of pending operations");
            break;
          }
          long delta=(startTimeMs + intervalMs) - curTimeMs;
          if (delta <= 0) {
            LOG.info("Rescanning after " + (curTimeMs - startTimeMs) + " milliseconds");
            break;
          }
          doRescan.await(delta,TimeUnit.MILLISECONDS);
          curTimeMs=Time.monotonicNow();
        }
      }
  finally {
        lock.unlock();
      }
      lock.lock();
      try {
        isScanning=true;
        needsRescan=false;
      }
  finally {
        lock.unlock();
      }
      startTimeMs=curTimeMs;
      mark=!mark;
      rescan();
      curTimeMs=Time.monotonicNow();
      lock.lock();
      try {
        isScanning=false;
        scanCount++;
        scanFinished.signalAll();
      }
  finally {
        lock.unlock();
      }
      LOG.info("Scanned " + scannedDirectives + " directive(s) and "+ scannedBlocks+ " block(s) in "+ (curTimeMs - startTimeMs)+ " "+ "millisecond(s).");
    }
  }
 catch (  Throwable t) {
    LOG.fatal("Thread exiting",t);
    terminate(1,t);
  }
}
