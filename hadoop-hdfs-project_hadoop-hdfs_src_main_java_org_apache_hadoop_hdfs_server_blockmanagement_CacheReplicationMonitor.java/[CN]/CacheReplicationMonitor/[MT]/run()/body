{
  long startTimeMs=0;
  Thread.currentThread().setName("CacheReplicationMonitor(" + System.identityHashCode(this) + ")");
  LOG.info("Starting CacheReplicationMonitor with interval " + intervalMs + " milliseconds");
  try {
    long curTimeMs=Time.monotonicNow();
    while (true) {
      lock.lock();
      try {
        while (true) {
          if (shutdown) {
            LOG.info("Shutting down CacheReplicationMonitor");
            return;
          }
          if (needsRescan) {
            LOG.info("Rescanning because of pending operations");
            break;
          }
          long delta=(startTimeMs + intervalMs) - curTimeMs;
          if (delta <= 0) {
            LOG.info("Rescanning after " + (curTimeMs - startTimeMs) + " milliseconds");
            break;
          }
          doRescan.await(delta,TimeUnit.MILLISECONDS);
          curTimeMs=Time.monotonicNow();
        }
        isScanning=true;
        needsRescan=false;
      }
  finally {
        lock.unlock();
      }
      startTimeMs=curTimeMs;
      mark=!mark;
      rescan();
      curTimeMs=Time.monotonicNow();
      lock.lock();
      try {
        isScanning=false;
        scanCount++;
        scanFinished.signalAll();
      }
  finally {
        lock.unlock();
      }
      LOG.info("Scanned " + scannedDirectives + " directive(s) and "+ scannedBlocks+ " block(s) in "+ (curTimeMs - startTimeMs)+ " "+ "millisecond(s).");
    }
  }
 catch (  InterruptedException e) {
    LOG.info("Shutting down CacheReplicationMonitor.");
    return;
  }
catch (  Throwable t) {
    LOG.fatal("Thread exiting",t);
    terminate(1,t);
  }
}
