{
  LOG.debug("sendMapFile called for " + mapId + " to reduce "+ reduce);
  boolean isInputException=false;
  FileInputStream mapOutputIn=null;
  byte[] buffer=new byte[MAX_BYTES_TO_READ];
  long totalRead=0;
  String userName=null;
  String runAsUserName=null;
synchronized (tracker.runningJobs) {
    RunningJob rjob=tracker.runningJobs.get(JobID.forName(jobId));
    if (rjob == null) {
      throw new IOException("Unknown job " + jobId + "!!");
    }
    userName=rjob.jobConf.getUser();
    runAsUserName=tracker.getTaskController().getRunAsUser(rjob.jobConf);
  }
  Path indexFileName=lDirAlloc.getLocalPathToRead(TaskTracker.getIntermediateOutputDir(userName,jobId,mapId) + "/file.out.index",conf);
  Path mapOutputFileName=lDirAlloc.getLocalPathToRead(TaskTracker.getIntermediateOutputDir(userName,jobId,mapId) + "/file.out",conf);
  IndexRecord info=tracker.indexCache.getIndexInformation(mapId,reduce,indexFileName,runAsUserName);
  try {
    mapOutputIn=SecureIOUtils.openForRead(new File(mapOutputFileName.toUri().getPath()),runAsUserName,null);
    IOUtils.skipFully(mapOutputIn,info.startOffset);
    ShuffleHeader header=new ShuffleHeader(mapId,info.partLength,info.rawLength,reduce);
    header.write(outStream);
    isInputException=true;
    long rem=info.partLength;
    if (rem == 0) {
      throw new IOException("Illegal partLength of 0 for mapId " + mapId + " to reduce "+ reduce);
    }
    int len=mapOutputIn.read(buffer,0,(int)Math.min(rem,MAX_BYTES_TO_READ));
    long now=0;
    while (len >= 0) {
      rem-=len;
      try {
        shuffleMetrics.outputBytes(len);
        if (len > 0) {
          outStream.write(buffer,0,len);
        }
 else {
          LOG.info("Skipped zero-length read of map " + mapId + " to reduce "+ reduce);
        }
      }
 catch (      IOException ie) {
        isInputException=false;
        throw ie;
      }
      totalRead+=len;
      if (rem == 0) {
        break;
      }
      len=mapOutputIn.read(buffer,0,(int)Math.min(rem,MAX_BYTES_TO_READ));
    }
    try {
      outStream.flush();
    }
 catch (    IOException ie) {
      isInputException=false;
      throw ie;
    }
  }
 catch (  IOException ie) {
    String errorMsg="error on sending map " + mapId + " to reduce "+ reduce;
    if (isInputException) {
      tracker.mapOutputLost(TaskAttemptID.forName(mapId),errorMsg + StringUtils.stringifyException(ie));
    }
    throw new IOException(errorMsg,ie);
  }
 finally {
    if (mapOutputIn != null) {
      try {
        mapOutputIn.close();
      }
 catch (      IOException ioe) {
        LOG.info("problem closing map output file",ioe);
      }
    }
  }
  LOG.info("Sent out " + totalRead + " bytes to reduce "+ reduce+ " from map: "+ mapId+ " given "+ info.partLength+ "/"+ info.rawLength);
}
