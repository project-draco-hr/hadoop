{
  LOG.info("Starting tasktracker with owner as " + aclsManager.getMROwner().getShortUserName());
  localFs=FileSystem.getLocal(fConf);
  if (fConf.get(TT_HOST_NAME) != null) {
    this.localHostname=fConf.get(TT_HOST_NAME);
  }
  if (localHostname == null) {
    this.localHostname=DNS.getDefaultHost(fConf.get(TT_DNS_INTERFACE,"default"),fConf.get(TT_DNS_NAMESERVER,"default"));
  }
  checkLocalDirs(this.fConf.getLocalDirs());
  setAsyncDiskService(new MRAsyncDiskService(fConf));
  getAsyncDiskService().cleanupAllVolumes();
  this.tasks.clear();
  this.runningTasks=new LinkedHashMap<TaskAttemptID,TaskInProgress>();
  this.runningJobs=new TreeMap<JobID,RunningJob>();
  this.mapTotal=0;
  this.reduceTotal=0;
  this.acceptNewTasks=true;
  this.status=null;
  this.minSpaceStart=this.fConf.getLong(TT_LOCAL_DIR_MINSPACE_START,0L);
  this.minSpaceKill=this.fConf.getLong(TT_LOCAL_DIR_MINSPACE_KILL,0L);
  probe_sample_size=this.fConf.getInt(TT_MAX_TASK_COMPLETION_EVENTS_TO_POLL,500);
  this.myInstrumentation=createInstrumentation(this,fConf);
  InetSocketAddress socAddr=NetUtils.createSocketAddr(fConf.get(TT_REPORT_ADDRESS,"127.0.0.1:0"));
  String bindAddress=socAddr.getHostName();
  int tmpPort=socAddr.getPort();
  this.jvmManager=new JvmManager(this);
  int max=maxMapSlots > maxReduceSlots ? maxMapSlots : maxReduceSlots;
  this.taskReportServer=RPC.getServer(this.getClass(),this,bindAddress,tmpPort,2 * max,false,this.fConf,this.jobTokenSecretManager);
  if (this.fConf.getBoolean(CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION,false)) {
    PolicyProvider policyProvider=(PolicyProvider)(ReflectionUtils.newInstance(this.fConf.getClass(PolicyProvider.POLICY_PROVIDER_CONFIG,MapReducePolicyProvider.class,PolicyProvider.class),this.fConf));
    this.taskReportServer.refreshServiceAcl(fConf,policyProvider);
  }
  this.taskReportServer.start();
  this.taskReportAddress=taskReportServer.getListenerAddress();
  this.fConf.set(TT_REPORT_ADDRESS,taskReportAddress.getHostName() + ":" + taskReportAddress.getPort());
  LOG.info("TaskTracker up at: " + this.taskReportAddress);
  this.taskTrackerName="tracker_" + localHostname + ":"+ taskReportAddress;
  LOG.info("Starting tracker " + taskTrackerName);
  Class<? extends TaskController> taskControllerClass=fConf.getClass(TT_TASK_CONTROLLER,DefaultTaskController.class,TaskController.class);
  taskController=(TaskController)ReflectionUtils.newInstance(taskControllerClass,fConf);
  taskController.setup();
  this.distributedCacheManager=new TrackerDistributedCacheManager(this.fConf,taskController,asyncDiskService);
  this.distributedCacheManager.startCleanupThread();
  this.jobClient=(InterTrackerProtocol)UserGroupInformation.getLoginUser().doAs(new PrivilegedExceptionAction<Object>(){
    public Object run() throws IOException {
      return RPC.waitForProxy(InterTrackerProtocol.class,InterTrackerProtocol.versionID,jobTrackAddr,fConf);
    }
  }
);
  this.justInited=true;
  this.running=true;
  this.mapEventsFetcher=new MapEventsFetcherThread();
  mapEventsFetcher.setDaemon(true);
  mapEventsFetcher.setName("Map-events fetcher for all reduce tasks " + "on " + taskTrackerName);
  mapEventsFetcher.start();
  Class<? extends ResourceCalculatorPlugin> clazz=fConf.getClass(TT_RESOURCE_CALCULATOR_PLUGIN,null,ResourceCalculatorPlugin.class);
  resourceCalculatorPlugin=ResourceCalculatorPlugin.getResourceCalculatorPlugin(clazz,fConf);
  LOG.info(" Using ResourceCalculatorPlugin : " + resourceCalculatorPlugin);
  initializeMemoryManagement();
  setIndexCache(new IndexCache(this.fConf));
  taskLogCleanupThread.clearOldUserLogs(this.fConf);
  mapLauncher=new TaskLauncher(TaskType.MAP,maxMapSlots);
  reduceLauncher=new TaskLauncher(TaskType.REDUCE,maxReduceSlots);
  mapLauncher.start();
  reduceLauncher.start();
  setLocalizer(new Localizer(localFs,fConf.getLocalDirs(),taskController));
  if (shouldStartHealthMonitor(this.fConf)) {
    startHealthMonitor(this.fConf);
  }
  oobHeartbeatOnTaskCompletion=fConf.getBoolean(TT_OUTOFBAND_HEARBEAT,false);
}
