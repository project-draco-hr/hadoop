{
  LOG.info("Processing the event " + event.toString());
  final String containerManagerBindAddr=event.getContainerMgrAddress();
  ContainerId containerID=event.getContainerID();
  ContainerToken containerToken=event.getContainerToken();
  TaskAttemptId taskAttemptID=event.getTaskAttemptID();
  Timer timer=new Timer(true);
  ContainerManager proxy=null;
switch (event.getType()) {
case CONTAINER_REMOTE_LAUNCH:
    ContainerRemoteLaunchEvent launchEvent=(ContainerRemoteLaunchEvent)event;
  try {
    timer.schedule(new CommandTimer(Thread.currentThread(),event),nmTimeOut);
    proxy=getCMProxy(containerID,containerManagerBindAddr,containerToken);
    if (Thread.currentThread().isInterrupted()) {
      String message="Start-container for " + event.getContainerID() + " got interrupted. Returning.";
      sendContainerLaunchFailedMsg(taskAttemptID,message);
      return;
    }
    ContainerLaunchContext containerLaunchContext=launchEvent.getContainer();
    StartContainerRequest startRequest=Records.newRecord(StartContainerRequest.class);
    startRequest.setContainerLaunchContext(containerLaunchContext);
    StartContainerResponse response=proxy.startContainer(startRequest);
    timer.cancel();
    if (Thread.currentThread().isInterrupted()) {
      String message="Start-container for " + event.getContainerID() + " got interrupted. Returning.";
      sendContainerLaunchFailedMsg(taskAttemptID,message);
      return;
    }
    ByteBuffer portInfo=response.getServiceResponse(ShuffleHandler.MAPREDUCE_SHUFFLE_SERVICEID);
    int port=-1;
    if (portInfo != null) {
      port=ShuffleHandler.deserializeMetaData(portInfo);
    }
    LOG.info("Shuffle port returned by ContainerManager for " + taskAttemptID + " : "+ port);
    if (port < 0) {
      throw new IllegalStateException("Invalid shuffle port number " + port + " returned for "+ taskAttemptID);
    }
    context.getEventHandler().handle(new TaskAttemptContainerLaunchedEvent(taskAttemptID,port));
  }
 catch (  Throwable t) {
    String message="Container launch failed for " + containerID + " : "+ StringUtils.stringifyException(t);
    sendContainerLaunchFailedMsg(taskAttemptID,message);
  }
 finally {
    timer.cancel();
    ContainerLauncherImpl.this.rpc.stopProxy(proxy,getConfig());
  }
break;
case CONTAINER_REMOTE_CLEANUP:
if (eventQueue.contains(event)) {
eventQueue.remove(event);
context.getEventHandler().handle(new ContainerAllocatorEvent(taskAttemptID,ContainerAllocator.EventType.CONTAINER_DEALLOCATE));
}
 else {
try {
  timer.schedule(new CommandTimer(Thread.currentThread(),event),nmTimeOut);
  proxy=getCMProxy(containerID,containerManagerBindAddr,containerToken);
  if (Thread.currentThread().isInterrupted()) {
    LOG.info("Stop-container for " + event.getContainerID() + " got interrupted.");
  }
 else {
    StopContainerRequest stopRequest=Records.newRecord(StopContainerRequest.class);
    stopRequest.setContainerId(event.getContainerID());
    proxy.stopContainer(stopRequest);
  }
}
 catch (Throwable t) {
  String message="cleanup failed for container " + event.getContainerID() + " : "+ StringUtils.stringifyException(t);
  context.getEventHandler().handle(new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,message));
  LOG.warn(message);
}
 finally {
  timer.cancel();
  ContainerLauncherImpl.this.rpc.stopProxy(proxy,getConfig());
}
context.getEventHandler().handle(new TaskAttemptEvent(event.getTaskAttemptID(),TaskAttemptEventType.TA_CONTAINER_CLEANED));
}
break;
}
}
