{
  ThreadFactory tf=new ThreadFactoryBuilder().setNameFormat("ContainerLauncher #%d").setDaemon(true).build();
  launcherPool=new ThreadPoolExecutor(initialPoolSize,Integer.MAX_VALUE,1,TimeUnit.HOURS,new LinkedBlockingQueue<Runnable>(),tf);
  eventHandlingThread=new Thread(){
    @Override public void run(){
      ContainerLauncherEvent event=null;
      Set<String> allNodes=new HashSet<String>();
      while (!stopped.get() && !Thread.currentThread().isInterrupted()) {
        try {
          event=eventQueue.take();
        }
 catch (        InterruptedException e) {
          if (!stopped.get()) {
            LOG.error("Returning, interrupted : " + e);
          }
          return;
        }
        allNodes.add(event.getContainerMgrAddress());
        int poolSize=launcherPool.getCorePoolSize();
        if (poolSize != limitOnPoolSize) {
          int numNodes=allNodes.size();
          int idealPoolSize=Math.min(limitOnPoolSize,numNodes);
          if (poolSize < idealPoolSize) {
            int newPoolSize=Math.min(limitOnPoolSize,idealPoolSize + initialPoolSize);
            LOG.info("Setting ContainerLauncher pool size to " + newPoolSize + " as number-of-nodes to talk to is "+ numNodes);
            launcherPool.setCorePoolSize(newPoolSize);
          }
        }
        launcherPool.execute(createEventProcessor(event));
      }
    }
  }
;
  eventHandlingThread.setName("ContainerLauncher Event Handler");
  eventHandlingThread.start();
  super.serviceStart();
}
