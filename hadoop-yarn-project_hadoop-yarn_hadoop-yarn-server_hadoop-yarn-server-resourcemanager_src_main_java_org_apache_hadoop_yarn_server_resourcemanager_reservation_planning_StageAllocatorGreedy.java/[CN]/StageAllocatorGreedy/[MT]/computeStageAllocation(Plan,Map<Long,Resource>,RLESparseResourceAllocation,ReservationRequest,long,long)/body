{
  Resource totalCapacity=plan.getTotalCapacity();
  Map<ReservationInterval,Resource> allocationRequests=new HashMap<ReservationInterval,Resource>();
  Resource gang=Resources.multiply(rr.getCapability(),rr.getConcurrency());
  long dur=rr.getDuration();
  long step=plan.getStep();
  if (dur % step != 0) {
    dur+=(step - (dur % step));
  }
  int gangsToPlace=rr.getNumContainers() / rr.getConcurrency();
  int maxGang=0;
  while (gangsToPlace > 0 && stageDeadline - dur >= stageEarliestStart) {
    maxGang=gangsToPlace;
    long minPoint=stageDeadline;
    int curMaxGang=maxGang;
    for (long t=stageDeadline - plan.getStep(); t >= stageDeadline - dur && maxGang > 0; t=t - plan.getStep()) {
      Resource netAvailableRes=Resources.clone(totalCapacity);
      Resources.subtractFrom(netAvailableRes,plan.getTotalCommittedResources(t));
      Resources.subtractFrom(netAvailableRes,planModifications.getCapacityAtTime(t));
      curMaxGang=(int)Math.floor(Resources.divide(plan.getResourceCalculator(),totalCapacity,netAvailableRes,gang));
      curMaxGang=Math.min(gangsToPlace,curMaxGang);
      if (curMaxGang <= maxGang) {
        maxGang=curMaxGang;
        minPoint=t;
      }
    }
    if (maxGang > 0) {
      gangsToPlace-=maxGang;
      ReservationInterval reservationInt=new ReservationInterval(stageDeadline - dur,stageDeadline);
      Resource reservationRes=Resources.multiply(rr.getCapability(),rr.getConcurrency() * maxGang);
      planModifications.addInterval(reservationInt,reservationRes);
      allocationRequests.put(reservationInt,reservationRes);
    }
    stageDeadline=minPoint;
  }
  if (gangsToPlace == 0) {
    return allocationRequests;
  }
 else {
    for (    Map.Entry<ReservationInterval,Resource> tempAllocation : allocationRequests.entrySet()) {
      planModifications.removeInterval(tempAllocation.getKey(),tempAllocation.getValue());
    }
    return null;
  }
}
