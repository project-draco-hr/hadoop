{
  final long sleeptime=conf.getLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT) * 2000 + conf.getLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT) * 1000;
  AtomicInteger retryCount=new AtomicInteger(0);
  LOG.info("namenodes = " + namenodes);
  checkKeytabAndInit(conf);
  List<NameNodeConnector> connectors=Collections.emptyList();
  try {
    connectors=NameNodeConnector.newNameNodeConnectors(namenodes,Mover.class.getSimpleName(),MOVER_ID_PATH,conf,NameNodeConnector.DEFAULT_MAX_IDLE_ITERATIONS);
    while (connectors.size() > 0) {
      Collections.shuffle(connectors);
      Iterator<NameNodeConnector> iter=connectors.iterator();
      while (iter.hasNext()) {
        NameNodeConnector nnc=iter.next();
        final Mover m=new Mover(nnc,conf,retryCount);
        final ExitStatus r=m.run();
        if (r == ExitStatus.SUCCESS) {
          IOUtils.cleanup(LOG,nnc);
          iter.remove();
        }
 else         if (r != ExitStatus.IN_PROGRESS) {
          if (r == ExitStatus.NO_MOVE_PROGRESS) {
            System.err.println("Failed to move some blocks after " + m.retryMaxAttempts + " retries. Exiting...");
          }
 else           if (r == ExitStatus.NO_MOVE_BLOCK) {
            System.err.println("Some blocks can't be moved. Exiting...");
          }
 else {
            System.err.println("Mover failed. Exiting with status " + r + "... ");
          }
          return r.getExitCode();
        }
      }
      Thread.sleep(sleeptime);
    }
    System.out.println("Mover Successful: all blocks satisfy" + " the specified storage policy. Exiting...");
    return ExitStatus.SUCCESS.getExitCode();
  }
  finally {
    for (    NameNodeConnector nnc : connectors) {
      IOUtils.cleanup(LOG,nnc);
    }
  }
}
