{
  stack.push(dir);
  final long parentNamespace=counts.get(Quota.NAMESPACE);
  final long parentDiskspace=counts.get(Quota.DISKSPACE);
  counts.add(Quota.NAMESPACE,1);
  for (  INode child : dir.getChildrenList(null)) {
    if (child.isDirectory()) {
      updateCountForINodeWithQuota((INodeDirectory)child,counts,stack);
    }
 else {
      counts.add(Quota.NAMESPACE,1);
      if (child.isFile()) {
        counts.add(Quota.DISKSPACE,((INodeFile)child).diskspaceConsumed());
      }
    }
  }
  if (dir.isQuotaSet()) {
    final long namespace=counts.get(Quota.NAMESPACE) - parentNamespace;
    if (Quota.isViolated(dir.getNsQuota(),namespace)) {
      final INode[] inodes=stack.toArray(new INode[stack.size()]);
      LOG.error("BUG: Namespace quota violation in image for " + FSDirectory.getFullPathName(inodes,inodes.length) + " quota = "+ dir.getNsQuota()+ " < consumed = "+ namespace);
    }
    final long diskspace=counts.get(Quota.DISKSPACE) - parentDiskspace;
    if (Quota.isViolated(dir.getDsQuota(),diskspace)) {
      final INode[] inodes=stack.toArray(new INode[stack.size()]);
      LOG.error("BUG: Diskspace quota violation in image for " + FSDirectory.getFullPathName(inodes,inodes.length) + " quota = "+ dir.getDsQuota()+ " < consumed = "+ diskspace);
    }
    ((INodeDirectoryWithQuota)dir).setSpaceConsumed(namespace,diskspace);
  }
  stack.pop();
}
