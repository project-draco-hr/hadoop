{
  final long parentNamespace=counts.getNameSpace();
  final long parentStoragespace=counts.getStorageSpace();
  final EnumCounters<StorageType> parentTypeSpaces=counts.getTypeSpaces();
  dir.computeQuotaUsage4CurrentDirectory(bsps,counts);
  for (  INode child : dir.getChildrenList(Snapshot.CURRENT_STATE_ID)) {
    if (child.isDirectory()) {
      updateCountForQuotaRecursively(bsps,child.asDirectory(),counts);
    }
 else {
      child.computeQuotaUsage(bsps,counts,false);
    }
  }
  if (dir.isQuotaSet()) {
    final QuotaCounts q=dir.getQuotaCounts();
    final long namespace=counts.getNameSpace() - parentNamespace;
    final long nsQuota=q.getNameSpace();
    if (Quota.isViolated(nsQuota,namespace)) {
      LOG.error("BUG: Namespace quota violation in image for " + dir.getFullPathName() + " quota = "+ nsQuota+ " < consumed = "+ namespace);
    }
    final long ssConsumed=counts.getStorageSpace() - parentStoragespace;
    final long ssQuota=q.getStorageSpace();
    if (Quota.isViolated(ssQuota,ssConsumed)) {
      LOG.error("BUG: Storagespace quota violation in image for " + dir.getFullPathName() + " quota = "+ ssQuota+ " < consumed = "+ ssConsumed);
    }
    final EnumCounters<StorageType> typeSpaces=new EnumCounters<StorageType>(StorageType.class);
    for (    StorageType t : StorageType.getTypesSupportingQuota()) {
      final long typeSpace=counts.getTypeSpaces().get(t) - parentTypeSpaces.get(t);
      final long typeQuota=q.getTypeSpaces().get(t);
      if (Quota.isViolated(typeQuota,typeSpace)) {
        LOG.error("BUG: Storage type quota violation in image for " + dir.getFullPathName() + " type = "+ t.toString()+ " quota = "+ typeQuota+ " < consumed "+ typeSpace);
      }
    }
    dir.getDirectoryWithQuotaFeature().setSpaceConsumed(namespace,ssConsumed,typeSpaces);
  }
}
