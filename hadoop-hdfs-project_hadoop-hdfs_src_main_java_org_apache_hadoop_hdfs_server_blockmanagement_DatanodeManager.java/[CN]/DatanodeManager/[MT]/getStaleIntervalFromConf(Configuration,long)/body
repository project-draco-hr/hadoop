{
  long staleInterval=conf.getLong(DFSConfigKeys.DFS_NAMENODE_STALE_DATANODE_INTERVAL_KEY,DFSConfigKeys.DFS_NAMENODE_STALE_DATANODE_INTERVAL_DEFAULT);
  Preconditions.checkArgument(staleInterval > 0,DFSConfigKeys.DFS_NAMENODE_STALE_DATANODE_INTERVAL_KEY + " = '" + staleInterval+ "' is invalid. "+ "It should be a positive non-zero value.");
  final long heartbeatIntervalSeconds=conf.getTimeDuration(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_DEFAULT,TimeUnit.SECONDS);
  final long minStaleInterval=conf.getInt(DFSConfigKeys.DFS_NAMENODE_STALE_DATANODE_MINIMUM_INTERVAL_KEY,DFSConfigKeys.DFS_NAMENODE_STALE_DATANODE_MINIMUM_INTERVAL_DEFAULT) * heartbeatIntervalSeconds * 1000;
  if (staleInterval < minStaleInterval) {
    LOG.warn("The given interval for marking stale datanode = " + staleInterval + ", which is less than "+ DFSConfigKeys.DFS_NAMENODE_STALE_DATANODE_MINIMUM_INTERVAL_DEFAULT+ " heartbeat intervals. This may cause too frequent changes of "+ "stale states of DataNodes since a heartbeat msg may be missing "+ "due to temporary short-term failures. Reset stale interval to "+ minStaleInterval+ ".");
    staleInterval=minStaleInterval;
  }
  if (staleInterval > heartbeatExpireInterval) {
    LOG.warn("The given interval for marking stale datanode = " + staleInterval + ", which is larger than heartbeat expire interval "+ heartbeatExpireInterval+ ".");
  }
  return staleInterval;
}
