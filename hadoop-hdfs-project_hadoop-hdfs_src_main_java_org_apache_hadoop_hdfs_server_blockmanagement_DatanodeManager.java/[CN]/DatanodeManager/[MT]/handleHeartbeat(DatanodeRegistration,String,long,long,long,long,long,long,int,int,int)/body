{
synchronized (heartbeatManager) {
synchronized (datanodeMap) {
      DatanodeDescriptor nodeinfo=null;
      try {
        nodeinfo=getDatanode(nodeReg);
      }
 catch (      UnregisteredNodeException e) {
        return new DatanodeCommand[]{RegisterCommand.REGISTER};
      }
      if (nodeinfo != null && nodeinfo.isDisallowed()) {
        setDatanodeDead(nodeinfo);
        throw new DisallowedDatanodeException(nodeinfo);
      }
      if (nodeinfo == null || !nodeinfo.isAlive) {
        return new DatanodeCommand[]{RegisterCommand.REGISTER};
      }
      heartbeatManager.updateHeartbeat(nodeinfo,capacity,dfsUsed,remaining,blockPoolUsed,cacheCapacity,cacheUsed,xceiverCount,failedVolumes);
      if (namesystem.isInSafeMode()) {
        return new DatanodeCommand[0];
      }
      BlockInfoUnderConstruction[] blocks=nodeinfo.getLeaseRecoveryCommand(Integer.MAX_VALUE);
      if (blocks != null) {
        BlockRecoveryCommand brCommand=new BlockRecoveryCommand(blocks.length);
        for (        BlockInfoUnderConstruction b : blocks) {
          DatanodeDescriptor[] expectedLocations=b.getExpectedLocations();
          List<DatanodeDescriptor> recoveryLocations=new ArrayList<DatanodeDescriptor>(expectedLocations.length);
          for (int i=0; i < expectedLocations.length; i++) {
            if (!expectedLocations[i].isStale(this.staleInterval)) {
              recoveryLocations.add(expectedLocations[i]);
            }
          }
          if (recoveryLocations.size() > 1) {
            if (recoveryLocations.size() != expectedLocations.length) {
              LOG.info("Skipped stale nodes for recovery : " + (expectedLocations.length - recoveryLocations.size()));
            }
            brCommand.add(new RecoveringBlock(new ExtendedBlock(blockPoolId,b),recoveryLocations.toArray(new DatanodeDescriptor[recoveryLocations.size()]),b.getBlockRecoveryId()));
          }
 else {
            brCommand.add(new RecoveringBlock(new ExtendedBlock(blockPoolId,b),expectedLocations,b.getBlockRecoveryId()));
          }
        }
        return new DatanodeCommand[]{brCommand};
      }
      final List<DatanodeCommand> cmds=new ArrayList<DatanodeCommand>();
      List<BlockTargetPair> pendingList=nodeinfo.getReplicationCommand(maxTransfers);
      if (pendingList != null) {
        cmds.add(new BlockCommand(DatanodeProtocol.DNA_TRANSFER,blockPoolId,pendingList));
      }
      Block[] blks=nodeinfo.getInvalidateBlocks(blockInvalidateLimit);
      if (blks != null) {
        cmds.add(new BlockCommand(DatanodeProtocol.DNA_INVALIDATE,blockPoolId,blks));
      }
      DatanodeCommand pendingCacheCommand=getCacheCommand(nodeinfo.getPendingCached(),nodeinfo,DatanodeProtocol.DNA_CACHE,blockPoolId);
      if (pendingCacheCommand != null) {
        cmds.add(pendingCacheCommand);
      }
      DatanodeCommand pendingUncacheCommand=getCacheCommand(nodeinfo.getPendingUncached(),nodeinfo,DatanodeProtocol.DNA_UNCACHE,blockPoolId);
      if (pendingUncacheCommand != null) {
        cmds.add(pendingUncacheCommand);
      }
      blockManager.addKeyUpdateCommand(cmds,nodeinfo);
      if (nodeinfo.getBalancerBandwidth() > 0) {
        cmds.add(new BalancerBandwidthCommand(nodeinfo.getBalancerBandwidth()));
        nodeinfo.setBalancerBandwidth(0);
      }
      if (!cmds.isEmpty()) {
        return cmds.toArray(new DatanodeCommand[cmds.size()]);
      }
    }
  }
  return new DatanodeCommand[0];
}
