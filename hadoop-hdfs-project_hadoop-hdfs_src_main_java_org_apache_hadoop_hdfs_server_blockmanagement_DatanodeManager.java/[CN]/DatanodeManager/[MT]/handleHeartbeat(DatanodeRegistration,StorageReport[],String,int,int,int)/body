{
synchronized (heartbeatManager) {
synchronized (datanodeMap) {
      DatanodeDescriptor nodeinfo=null;
      try {
        nodeinfo=getDatanode(nodeReg);
      }
 catch (      UnregisteredNodeException e) {
        return new DatanodeCommand[]{RegisterCommand.REGISTER};
      }
      if (nodeinfo != null && nodeinfo.isDisallowed()) {
        setDatanodeDead(nodeinfo);
        throw new DisallowedDatanodeException(nodeinfo);
      }
      if (nodeinfo == null || !nodeinfo.isAlive) {
        return new DatanodeCommand[]{RegisterCommand.REGISTER};
      }
      heartbeatManager.updateHeartbeat(nodeinfo,reports,xceiverCount,failedVolumes);
      if (namesystem.isInSafeMode()) {
        return new DatanodeCommand[0];
      }
      BlockInfoUnderConstruction[] blocks=nodeinfo.getLeaseRecoveryCommand(Integer.MAX_VALUE);
      if (blocks != null) {
        BlockRecoveryCommand brCommand=new BlockRecoveryCommand(blocks.length);
        for (        BlockInfoUnderConstruction b : blocks) {
          final DatanodeStorageInfo[] storages=b.getExpectedStorageLocations();
          final List<DatanodeStorageInfo> recoveryLocations=new ArrayList<DatanodeStorageInfo>(storages.length);
          for (int i=0; i < storages.length; i++) {
            if (!storages[i].getDatanodeDescriptor().isStale(staleInterval)) {
              recoveryLocations.add(storages[i]);
            }
          }
          if (recoveryLocations.size() > 1) {
            if (recoveryLocations.size() != storages.length) {
              LOG.info("Skipped stale nodes for recovery : " + (storages.length - recoveryLocations.size()));
            }
            brCommand.add(new RecoveringBlock(new ExtendedBlock(blockPoolId,b),DatanodeStorageInfo.toDatanodeInfos(recoveryLocations),b.getBlockRecoveryId()));
          }
 else {
            brCommand.add(new RecoveringBlock(new ExtendedBlock(blockPoolId,b),DatanodeStorageInfo.toDatanodeInfos(storages),b.getBlockRecoveryId()));
          }
        }
        return new DatanodeCommand[]{brCommand};
      }
      final List<DatanodeCommand> cmds=new ArrayList<DatanodeCommand>();
      List<BlockTargetPair> pendingList=nodeinfo.getReplicationCommand(maxTransfers);
      if (pendingList != null) {
        cmds.add(new BlockCommand(DatanodeProtocol.DNA_TRANSFER,blockPoolId,pendingList));
      }
      Block[] blks=nodeinfo.getInvalidateBlocks(blockInvalidateLimit);
      if (blks != null) {
        cmds.add(new BlockCommand(DatanodeProtocol.DNA_INVALIDATE,blockPoolId,blks));
      }
      blockManager.addKeyUpdateCommand(cmds,nodeinfo);
      if (nodeinfo.getBalancerBandwidth() > 0) {
        cmds.add(new BalancerBandwidthCommand(nodeinfo.getBalancerBandwidth()));
        nodeinfo.setBalancerBandwidth(0);
      }
      if (!cmds.isEmpty()) {
        return cmds.toArray(new DatanodeCommand[cmds.size()]);
      }
    }
  }
  return new DatanodeCommand[0];
}
