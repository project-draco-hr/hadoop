{
  TimelineEntities te=new TimelineEntities();
  ApplicationEntity entity=new ApplicationEntity();
  String appId="application_1000178881110_2002";
  entity.setId(appId);
  Long cTime=1425016501000L;
  entity.setCreatedTime(cTime);
  Map<String,Object> infoMap=new HashMap<String,Object>();
  infoMap.put("infoMapKey1","infoMapValue1");
  infoMap.put("infoMapKey2",10);
  entity.addInfo(infoMap);
  String key="task";
  String value="is_related_to_entity_id_here";
  Set<String> isRelatedToSet=new HashSet<String>();
  isRelatedToSet.add(value);
  Map<String,Set<String>> isRelatedTo=new HashMap<String,Set<String>>();
  isRelatedTo.put(key,isRelatedToSet);
  entity.setIsRelatedToEntities(isRelatedTo);
  key="container";
  value="relates_to_entity_id_here";
  Set<String> relatesToSet=new HashSet<String>();
  relatesToSet.add(value);
  value="relates_to_entity_id_here_Second";
  relatesToSet.add(value);
  Map<String,Set<String>> relatesTo=new HashMap<String,Set<String>>();
  relatesTo.put(key,relatesToSet);
  entity.setRelatesToEntities(relatesTo);
  Map<String,String> conf=new HashMap<String,String>();
  conf.put("config_param1","value1");
  conf.put("config_param2","value2");
  entity.addConfigs(conf);
  Set<TimelineMetric> metrics=new HashSet<>();
  TimelineMetric m1=new TimelineMetric();
  m1.setId("MAP_SLOT_MILLIS");
  Map<Long,Number> metricValues=new HashMap<Long,Number>();
  long ts=System.currentTimeMillis();
  metricValues.put(ts - 120000,100000000);
  metricValues.put(ts - 100000,200000000);
  metricValues.put(ts - 80000,300000000);
  metricValues.put(ts - 60000,400000000);
  metricValues.put(ts - 40000,50000000000L);
  metricValues.put(ts - 20000,60000000000L);
  m1.setType(Type.TIME_SERIES);
  m1.setValues(metricValues);
  metrics.add(m1);
  entity.addMetrics(metrics);
  TimelineEntity aggEntity=new TimelineEntity();
  String type=TimelineEntityType.YARN_APPLICATION.toString();
  aggEntity.setId(appId);
  aggEntity.setType(type);
  long cTime2=1425016502000L;
  aggEntity.setCreatedTime(cTime2);
  TimelineMetric aggMetric=new TimelineMetric();
  aggMetric.setId("MEM_USAGE");
  Map<Long,Number> aggMetricValues=new HashMap<Long,Number>();
  ts=System.currentTimeMillis();
  aggMetricValues.put(ts - 120000,102400000L);
  aggMetric.setType(Type.SINGLE_VALUE);
  aggMetric.setRealtimeAggregationOp(TimelineMetricOperation.SUM);
  aggMetric.setValues(aggMetricValues);
  Set<TimelineMetric> aggMetrics=new HashSet<>();
  aggMetrics.add(aggMetric);
  entity.addMetrics(aggMetrics);
  te.addEntity(entity);
  HBaseTimelineWriterImpl hbi=null;
  try {
    Configuration c1=util.getConfiguration();
    hbi=new HBaseTimelineWriterImpl(c1);
    hbi.init(c1);
    hbi.start();
    String cluster="cluster_test_write_app";
    String user="user1";
    String flow="s!ome_f\tlow  _n am!e";
    String flowVersion="AB7822C10F1111";
    long runid=1002345678919L;
    hbi.write(cluster,user,flow,flowVersion,runid,appId,te);
    entity=new ApplicationEntity();
    appId="application_1000178881110_2002";
    entity.setId(appId);
    Map<String,Object> infoMap1=new HashMap<>();
    infoMap1.put("infoMapKey3","infoMapValue1");
    entity.addInfo(infoMap1);
    te=new TimelineEntities();
    te.addEntity(entity);
    hbi.write(cluster,user,flow,flowVersion,runid,appId,te);
    hbi.stop();
    infoMap.putAll(infoMap1);
    ApplicationRowKey applicationRowKey=new ApplicationRowKey(cluster,user,flow,runid,appId);
    byte[] rowKey=applicationRowKey.getRowKey();
    Get get=new Get(rowKey);
    get.setMaxVersions(Integer.MAX_VALUE);
    Connection conn=ConnectionFactory.createConnection(c1);
    Result result=new ApplicationTable().getResult(c1,conn,get);
    assertTrue(result != null);
    assertEquals(17,result.size());
    byte[] row1=result.getRow();
    assertTrue(isApplicationRowKeyCorrect(row1,cluster,user,flow,runid,appId));
    String id1=ApplicationColumn.ID.readResult(result).toString();
    assertEquals(appId,id1);
    Long cTime1=(Long)ApplicationColumn.CREATED_TIME.readResult(result);
    assertEquals(cTime,cTime1);
    Map<String,Object> infoColumns=ApplicationColumnPrefix.INFO.readResults(result,new StringKeyConverter());
    assertEquals(infoMap,infoColumns);
    for (    Map.Entry<String,Set<String>> isRelatedToEntry : isRelatedTo.entrySet()) {
      Object isRelatedToValue=ApplicationColumnPrefix.IS_RELATED_TO.readResult(result,isRelatedToEntry.getKey());
      String compoundValue=isRelatedToValue.toString();
      Set<String> isRelatedToValues=new HashSet<String>(Separator.VALUES.splitEncoded(compoundValue));
      assertEquals(isRelatedTo.get(isRelatedToEntry.getKey()).size(),isRelatedToValues.size());
      for (      String v : isRelatedToEntry.getValue()) {
        assertTrue(isRelatedToValues.contains(v));
      }
    }
    for (    Map.Entry<String,Set<String>> relatesToEntry : relatesTo.entrySet()) {
      String compoundValue=ApplicationColumnPrefix.RELATES_TO.readResult(result,relatesToEntry.getKey()).toString();
      Set<String> relatesToValues=new HashSet<String>(Separator.VALUES.splitEncoded(compoundValue));
      assertEquals(relatesTo.get(relatesToEntry.getKey()).size(),relatesToValues.size());
      for (      String v : relatesToEntry.getValue()) {
        assertTrue(relatesToValues.contains(v));
      }
    }
    KeyConverter<String> stringKeyConverter=new StringKeyConverter();
    Map<String,Object> configColumns=ApplicationColumnPrefix.CONFIG.readResults(result,stringKeyConverter);
    assertEquals(conf,configColumns);
    NavigableMap<String,NavigableMap<Long,Number>> metricsResult=ApplicationColumnPrefix.METRIC.readResultsWithTimestamps(result,stringKeyConverter);
    NavigableMap<Long,Number> metricMap=metricsResult.get(m1.getId());
    matchMetrics(metricValues,metricMap);
    TimelineEntity e1=reader.getEntity(new TimelineReaderContext(cluster,user,flow,runid,appId,entity.getType(),entity.getId()),new TimelineDataToRetrieve(null,null,EnumSet.of(TimelineReader.Field.ALL),Integer.MAX_VALUE));
    assertNotNull(e1);
    assertEquals(appId,e1.getId());
    assertEquals(TimelineEntityType.YARN_APPLICATION.toString(),e1.getType());
    assertEquals(cTime,e1.getCreatedTime());
    Map<String,Object> infoMap2=e1.getInfo();
    assertEquals(infoMap,infoMap2);
    Map<String,Set<String>> isRelatedTo2=e1.getIsRelatedToEntities();
    assertEquals(isRelatedTo,isRelatedTo2);
    Map<String,Set<String>> relatesTo2=e1.getRelatesToEntities();
    assertEquals(relatesTo,relatesTo2);
    Map<String,String> conf2=e1.getConfigs();
    assertEquals(conf,conf2);
    Set<TimelineMetric> metrics2=e1.getMetrics();
    assertEquals(2,metrics2.size());
    for (    TimelineMetric metric2 : metrics2) {
      Map<Long,Number> metricValues2=metric2.getValues();
      assertTrue(metric2.getId().equals("MAP_SLOT_MILLIS") || metric2.getId().equals("MEM_USAGE"));
      if (metric2.getId().equals("MAP_SLOT_MILLIS")) {
        assertEquals(6,metricValues2.size());
        matchMetrics(metricValues,metricValues2);
      }
      if (metric2.getId().equals("MEM_USAGE")) {
        assertEquals(1,metricValues2.size());
        matchMetrics(aggMetricValues,metricValues2);
      }
    }
    e1=reader.getEntity(new TimelineReaderContext(cluster,user,flow,runid,appId,entity.getType(),entity.getId()),new TimelineDataToRetrieve(null,null,EnumSet.of(TimelineReader.Field.ALL),3));
    assertNotNull(e1);
    assertEquals(appId,e1.getId());
    assertEquals(TimelineEntityType.YARN_APPLICATION.toString(),e1.getType());
    assertEquals(conf,e1.getConfigs());
    metrics2=e1.getMetrics();
    assertEquals(2,metrics2.size());
    for (    TimelineMetric metric2 : metrics2) {
      Map<Long,Number> metricValues2=metric2.getValues();
      assertTrue(metricValues2.size() <= 3);
      assertTrue(metric2.getId().equals("MAP_SLOT_MILLIS") || metric2.getId().equals("MEM_USAGE"));
    }
    e1=reader.getEntity(new TimelineReaderContext(cluster,user,flow,runid,appId,entity.getType(),entity.getId()),new TimelineDataToRetrieve(null,null,EnumSet.of(TimelineReader.Field.ALL),null));
    assertNotNull(e1);
    assertEquals(appId,e1.getId());
    assertEquals(TimelineEntityType.YARN_APPLICATION.toString(),e1.getType());
    assertEquals(cTime,e1.getCreatedTime());
    assertEquals(infoMap,e1.getInfo());
    assertEquals(isRelatedTo,e1.getIsRelatedToEntities());
    assertEquals(relatesTo,e1.getRelatesToEntities());
    assertEquals(conf,e1.getConfigs());
    assertEquals(2,e1.getMetrics().size());
    for (    TimelineMetric metric : e1.getMetrics()) {
      assertEquals(1,metric.getValues().size());
      assertEquals(TimelineMetric.Type.SINGLE_VALUE,metric.getType());
      assertTrue(metric.getId().equals("MAP_SLOT_MILLIS") || metric.getId().equals("MEM_USAGE"));
      assertEquals(1,metric.getValues().size());
      if (metric.getId().equals("MAP_SLOT_MILLIS")) {
        assertTrue(metric.getValues().containsKey(ts - 20000));
        assertEquals(metricValues.get(ts - 20000),metric.getValues().get(ts - 20000));
      }
      if (metric.getId().equals("MEM_USAGE")) {
        assertTrue(metric.getValues().containsKey(ts - 120000));
        assertEquals(aggMetricValues.get(ts - 120000),metric.getValues().get(ts - 120000));
      }
    }
  }
  finally {
    if (hbi != null) {
      hbi.stop();
      hbi.close();
    }
  }
}
