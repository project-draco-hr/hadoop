{
  initialize(plan,reservationId,reservation);
  RLESparseResourceAllocation allocations=new RLESparseResourceAllocation(plan.getResourceCalculator());
  StageProvider stageProvider=new StageProvider(allocateLeft,reservation);
  ReservationRequest currentReservationStage;
  long stageDeadline=stepRoundDown(reservation.getDeadline(),step);
  long successorStartingTime=-1;
  long predecessorEndTime=stepRoundDown(reservation.getArrival(),step);
  long stageArrivalTime=-1;
  while (stageProvider.hasNext()) {
    currentReservationStage=stageProvider.next();
    validateInputStage(plan,currentReservationStage);
    if (allocateLeft) {
      stageArrivalTime=predecessorEndTime;
    }
 else {
      stageArrivalTime=reservation.getArrival();
      if (jobType == ReservationRequestInterpreter.R_ORDER || jobType == ReservationRequestInterpreter.R_ORDER_NO_GAP) {
        stageArrivalTime=computeEarliestStartingTime(plan,reservation,stageProvider.getCurrentIndex(),currentReservationStage,stageDeadline);
      }
      stageArrivalTime=stepRoundUp(stageArrivalTime,step);
      stageArrivalTime=Math.max(stageArrivalTime,reservation.getArrival());
    }
    Map<ReservationInterval,Resource> curAlloc=computeStageAllocation(plan,currentReservationStage,stageArrivalTime,stageDeadline,user,reservationId);
    if (curAlloc == null) {
      if (jobType == ReservationRequestInterpreter.R_ANY) {
        continue;
      }
      throw new PlanningException("The request cannot be satisfied");
    }
    Long stageStartTime=findEarliestTime(curAlloc);
    Long stageEndTime=findLatestTime(curAlloc);
    for (    Entry<ReservationInterval,Resource> entry : curAlloc.entrySet()) {
      allocations.addInterval(entry.getKey(),entry.getValue());
    }
    if (jobType == ReservationRequestInterpreter.R_ANY) {
      break;
    }
    if (jobType == ReservationRequestInterpreter.R_ORDER || jobType == ReservationRequestInterpreter.R_ORDER_NO_GAP) {
      if (jobType == ReservationRequestInterpreter.R_ORDER_NO_GAP && successorStartingTime != -1 && ((allocateLeft && predecessorEndTime < stageStartTime) || (!allocateLeft && (stageEndTime < successorStartingTime))) || (!isNonPreemptiveAllocation(curAlloc))) {
        throw new PlanningException("The allocation found does not respect ORDER_NO_GAP");
      }
      if (allocateLeft) {
        predecessorEndTime=stageEndTime;
      }
 else {
        successorStartingTime=stageStartTime;
        stageDeadline=stageStartTime;
      }
    }
  }
  if (allocations.isEmpty()) {
    throw new PlanningException("The request cannot be satisfied");
  }
  return allocations;
}
