{
  String pool=sched.getName();
  long minShareTimeout=poolMgr.getMinSharePreemptionTimeout(pool);
  long fairShareTimeout=poolMgr.getFairSharePreemptionTimeout();
  int tasksDueToMinShare=0;
  int tasksDueToFairShare=0;
  if (curTime - sched.getLastTimeAtMinShare() > minShareTimeout) {
    int target=Math.min(sched.getMinShare(),sched.getDemand());
    tasksDueToMinShare=Math.max(0,target - sched.getRunningTasks());
  }
  if (curTime - sched.getLastTimeAtHalfFairShare() > fairShareTimeout) {
    int target=(int)Math.min(sched.getFairShare(),sched.getDemand());
    tasksDueToFairShare=Math.max(0,target - sched.getRunningTasks());
  }
  int tasksToPreempt=Math.max(tasksDueToMinShare,tasksDueToFairShare);
  if (tasksToPreempt > 0) {
    String message="Should preempt " + tasksToPreempt + " "+ sched.getTaskType()+ " tasks for pool "+ sched.getName()+ ": tasksDueToMinShare = "+ tasksDueToMinShare+ ", tasksDueToFairShare = "+ tasksDueToFairShare;
    eventLog.log("INFO",message);
    LOG.info(message);
  }
  return tasksToPreempt;
}
