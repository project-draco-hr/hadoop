{
  ClusterStatus clusterStatus=taskTrackerManager.getClusterStatus();
  if (autoComputeLocalityDelay) {
    JobTracker jobTracker=(JobTracker)taskTrackerManager;
    nodeLocalityDelay=Math.min(MAX_AUTOCOMPUTED_LOCALITY_DELAY,(long)(1.5 * jobTracker.getNextHeartbeatInterval()));
    rackLocalityDelay=nodeLocalityDelay;
  }
synchronized (this) {
    poolMgr.reloadAllocsIfNecessary();
    List<JobInProgress> toRemove=new ArrayList<JobInProgress>();
    for (    JobInProgress job : infos.keySet()) {
      int runState=job.getStatus().getRunState();
      if (runState == JobStatus.SUCCEEDED || runState == JobStatus.FAILED || runState == JobStatus.KILLED) {
        toRemove.add(job);
      }
    }
    for (    JobInProgress job : toRemove) {
      jobNoLongerRunning(job);
    }
    updateRunnability();
    for (    Pool pool : poolMgr.getPools()) {
      pool.getMapSchedulable().updateDemand();
      pool.getReduceSchedulable().updateDemand();
    }
    List<PoolSchedulable> mapScheds=getPoolSchedulables(TaskType.MAP);
    List<PoolSchedulable> reduceScheds=getPoolSchedulables(TaskType.REDUCE);
    SchedulingAlgorithms.computeFairShares(mapScheds,clusterStatus.getMaxMapTasks());
    SchedulingAlgorithms.computeFairShares(reduceScheds,clusterStatus.getMaxReduceTasks());
    for (    Pool pool : poolMgr.getPools()) {
      pool.getMapSchedulable().redistributeShare();
      pool.getReduceSchedulable().redistributeShare();
    }
    if (preemptionEnabled)     updatePreemptionVariables();
  }
}
