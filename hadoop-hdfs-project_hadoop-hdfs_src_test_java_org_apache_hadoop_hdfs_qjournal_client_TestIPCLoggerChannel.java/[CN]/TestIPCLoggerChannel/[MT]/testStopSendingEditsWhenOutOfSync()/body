{
  Mockito.doThrow(new IOException("injected error")).when(mockProxy).journal(Mockito.<RequestInfo>any(),Mockito.eq(1L),Mockito.eq(1L),Mockito.eq(1),Mockito.same(FAKE_DATA));
  try {
    ch.sendEdits(1L,1L,1,FAKE_DATA).get();
    fail("Injected JOOSE did not cause sendEdits() to throw");
  }
 catch (  ExecutionException ee) {
    GenericTestUtils.assertExceptionContains("injected",ee);
  }
  Mockito.verify(mockProxy).journal(Mockito.<RequestInfo>any(),Mockito.eq(1L),Mockito.eq(1L),Mockito.eq(1),Mockito.same(FAKE_DATA));
  assertTrue(ch.isOutOfSync());
  try {
    ch.sendEdits(1L,2L,1,FAKE_DATA).get();
    fail("sendEdits() should throw until next roll");
  }
 catch (  ExecutionException ee) {
    GenericTestUtils.assertExceptionContains("disabled until next roll",ee.getCause());
  }
  Mockito.verify(mockProxy,Mockito.never()).journal(Mockito.<RequestInfo>any(),Mockito.eq(1L),Mockito.eq(2L),Mockito.eq(1),Mockito.same(FAKE_DATA));
  Mockito.verify(mockProxy).heartbeat(Mockito.<RequestInfo>any());
  ch.startLogSegment(3L,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION).get();
  assertFalse(ch.isOutOfSync());
  ch.sendEdits(3L,3L,1,FAKE_DATA).get();
}
