{
  conf=new Configuration();
  conf.setInt(DFSConfigKeys.DFS_NAMENODE_CHECKPOINT_CHECK_PERIOD_KEY,1);
  conf.setInt(DFSConfigKeys.DFS_NAMENODE_CHECKPOINT_TXNS_KEY,1);
  conf.setInt(DFSConfigKeys.DFS_NAMENODE_NUM_CHECKPOINTS_RETAINED_KEY,10);
  conf.setInt(DFSConfigKeys.DFS_HA_TAILEDITS_PERIOD_KEY,1);
  HAUtil.setAllowStandbyReads(conf,true);
  if (clusterType == TestType.SHARED_DIR_HA) {
    int basePort=10000;
    int retryCount=0;
    while (true) {
      try {
        basePort=10000 + RANDOM.nextInt(1000) * 4;
        LOG.info("Set SHARED_DIR_HA cluster's basePort to " + basePort);
        MiniDFSNNTopology topology=MiniQJMHACluster.createDefaultTopology(basePort);
        cluster=new MiniDFSCluster.Builder(conf).nnTopology(topology).numDataNodes(0).checkExitOnShutdown(false).build();
        break;
      }
 catch (      BindException e) {
        if (cluster != null) {
          cluster.shutdown(true);
          cluster=null;
        }
        ++retryCount;
        LOG.info("SHARED_DIR_HA: MiniQJMHACluster port conflicts, retried " + retryCount + " times "+ e);
      }
    }
  }
 else {
    Builder builder=new MiniQJMHACluster.Builder(conf);
    builder.getDfsBuilder().numDataNodes(0).checkExitOnShutdown(false);
    miniQjmHaCluster=builder.build();
    cluster=miniQjmHaCluster.getDfsCluster();
  }
  cluster.waitActive();
  nn0=cluster.getNameNode(0);
  nn1=cluster.getNameNode(1);
  cluster.transitionToActive(0);
  fs=HATestUtil.configureFailoverFs(cluster,conf);
}
