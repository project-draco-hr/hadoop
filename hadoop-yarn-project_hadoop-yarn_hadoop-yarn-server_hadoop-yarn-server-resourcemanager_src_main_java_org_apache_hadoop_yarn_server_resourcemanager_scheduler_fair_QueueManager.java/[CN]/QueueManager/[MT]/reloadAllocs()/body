{
  if (allocFile == null)   return;
  Map<String,Resource> minQueueResources=new HashMap<String,Resource>();
  Map<String,Resource> maxQueueResources=new HashMap<String,Resource>();
  Map<String,Integer> queueMaxApps=new HashMap<String,Integer>();
  Map<String,Integer> userMaxApps=new HashMap<String,Integer>();
  Map<String,ResourceWeights> queueWeights=new HashMap<String,ResourceWeights>();
  Map<String,SchedulingPolicy> queuePolicies=new HashMap<String,SchedulingPolicy>();
  Map<String,Long> minSharePreemptionTimeouts=new HashMap<String,Long>();
  Map<String,Map<QueueACL,AccessControlList>> queueAcls=new HashMap<String,Map<QueueACL,AccessControlList>>();
  int userMaxAppsDefault=Integer.MAX_VALUE;
  int queueMaxAppsDefault=Integer.MAX_VALUE;
  long fairSharePreemptionTimeout=Long.MAX_VALUE;
  long defaultMinSharePreemptionTimeout=Long.MAX_VALUE;
  SchedulingPolicy defaultSchedPolicy=SchedulingPolicy.getDefault();
  List<String> queueNamesInAllocFile=new ArrayList<String>();
  DocumentBuilderFactory docBuilderFactory=DocumentBuilderFactory.newInstance();
  docBuilderFactory.setIgnoringComments(true);
  DocumentBuilder builder=docBuilderFactory.newDocumentBuilder();
  Document doc=builder.parse(allocFile);
  Element root=doc.getDocumentElement();
  if (!"allocations".equals(root.getTagName()))   throw new AllocationConfigurationException("Bad fair scheduler config " + "file: top-level element not <allocations>");
  NodeList elements=root.getChildNodes();
  for (int i=0; i < elements.getLength(); i++) {
    Node node=elements.item(i);
    if (!(node instanceof Element))     continue;
    Element element=(Element)node;
    if ("queue".equals(element.getTagName()) || "pool".equals(element.getTagName())) {
      loadQueue("root",element,minQueueResources,maxQueueResources,queueMaxApps,userMaxApps,queueWeights,queuePolicies,minSharePreemptionTimeouts,queueAcls,queueNamesInAllocFile);
    }
 else     if ("user".equals(element.getTagName())) {
      String userName=element.getAttribute("name");
      NodeList fields=element.getChildNodes();
      for (int j=0; j < fields.getLength(); j++) {
        Node fieldNode=fields.item(j);
        if (!(fieldNode instanceof Element))         continue;
        Element field=(Element)fieldNode;
        if ("maxRunningApps".equals(field.getTagName())) {
          String text=((Text)field.getFirstChild()).getData().trim();
          int val=Integer.parseInt(text);
          userMaxApps.put(userName,val);
        }
      }
    }
 else     if ("userMaxAppsDefault".equals(element.getTagName())) {
      String text=((Text)element.getFirstChild()).getData().trim();
      int val=Integer.parseInt(text);
      userMaxAppsDefault=val;
    }
 else     if ("fairSharePreemptionTimeout".equals(element.getTagName())) {
      String text=((Text)element.getFirstChild()).getData().trim();
      long val=Long.parseLong(text) * 1000L;
      fairSharePreemptionTimeout=val;
    }
 else     if ("defaultMinSharePreemptionTimeout".equals(element.getTagName())) {
      String text=((Text)element.getFirstChild()).getData().trim();
      long val=Long.parseLong(text) * 1000L;
      defaultMinSharePreemptionTimeout=val;
    }
 else     if ("queueMaxAppsDefault".equals(element.getTagName())) {
      String text=((Text)element.getFirstChild()).getData().trim();
      int val=Integer.parseInt(text);
      queueMaxAppsDefault=val;
    }
 else     if ("defaultQueueSchedulingPolicy".equals(element.getTagName()) || "defaultQueueSchedulingMode".equals(element.getTagName())) {
      String text=((Text)element.getFirstChild()).getData().trim();
      SchedulingPolicy.setDefault(text);
      defaultSchedPolicy=SchedulingPolicy.getDefault();
    }
 else {
      LOG.warn("Bad element in allocations file: " + element.getTagName());
    }
  }
synchronized (this) {
    info=new QueueManagerInfo(minQueueResources,maxQueueResources,queueMaxApps,userMaxApps,queueWeights,userMaxAppsDefault,queueMaxAppsDefault,defaultSchedPolicy,minSharePreemptionTimeouts,queueAcls,fairSharePreemptionTimeout,defaultMinSharePreemptionTimeout);
    for (    FSQueue queue : queues.values()) {
      FSQueueMetrics queueMetrics=queue.getMetrics();
      queueMetrics.setMinShare(queue.getMinShare());
      queueMetrics.setMaxShare(queue.getMaxShare());
    }
    Map<QueueACL,AccessControlList> rootAcls=new HashMap<QueueACL,AccessControlList>();
    rootAcls.put(QueueACL.SUBMIT_APPLICATIONS,new AccessControlList(" "));
    rootAcls.put(QueueACL.ADMINISTER_QUEUE,new AccessControlList(" "));
    queueAcls.put(ROOT_QUEUE,rootAcls);
    for (    String name : queueNamesInAllocFile) {
      getLeafQueue(name);
    }
    for (    Map.Entry<String,SchedulingPolicy> entry : queuePolicies.entrySet()) {
      queues.get(entry.getKey()).setPolicy(entry.getValue());
    }
  }
}
