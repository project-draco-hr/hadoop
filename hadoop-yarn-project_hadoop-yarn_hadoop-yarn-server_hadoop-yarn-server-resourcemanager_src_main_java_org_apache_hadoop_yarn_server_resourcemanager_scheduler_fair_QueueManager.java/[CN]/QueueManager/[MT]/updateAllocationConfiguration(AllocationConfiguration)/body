{
synchronized (queues) {
    for (    String name : queueConf.getConfiguredQueues().get(FSQueueType.LEAF)) {
      if (removeEmptyIncompatibleQueues(name,FSQueueType.LEAF)) {
        getLeafQueue(name,true,false);
      }
    }
    for (    String name : queueConf.getConfiguredQueues().get(FSQueueType.PARENT)) {
      if (removeEmptyIncompatibleQueues(name,FSQueueType.PARENT)) {
        getParentQueue(name,true,false);
      }
    }
  }
  rootQueue.recomputeSteadyShares();
  for (  FSQueue queue : queues.values()) {
    FSQueueMetrics queueMetrics=queue.getMetrics();
    queueMetrics.setMinShare(queue.getMinShare());
    queueMetrics.setMaxShare(queue.getMaxShare());
    try {
      SchedulingPolicy policy=queueConf.getSchedulingPolicy(queue.getName());
      policy.initialize(scheduler.getClusterResource());
      queue.setPolicy(policy);
    }
 catch (    AllocationConfigurationException ex) {
      LOG.warn("Cannot apply configured scheduling policy to queue " + queue.getName(),ex);
    }
  }
  rootQueue.recomputeSteadyShares();
  rootQueue.updatePreemptionVariables();
}
