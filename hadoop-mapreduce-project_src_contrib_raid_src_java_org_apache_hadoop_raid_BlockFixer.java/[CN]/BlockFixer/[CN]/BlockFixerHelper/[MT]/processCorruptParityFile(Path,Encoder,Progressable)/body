{
  LOG.info("Processing corrupt file " + parityPath);
  Path srcPath=sourcePathFromParityPath(parityPath);
  if (srcPath == null) {
    LOG.warn("Unusable parity file " + parityPath);
    return false;
  }
  DistributedFileSystem parityFs=getDFS(parityPath);
  FileStatus parityStat=parityFs.getFileStatus(parityPath);
  long blockSize=parityStat.getBlockSize();
  long parityFileSize=parityStat.getLen();
  FileStatus srcStat=getDFS(srcPath).getFileStatus(srcPath);
  long srcFileSize=srcStat.getLen();
  if (srcStat.getModificationTime() != parityStat.getModificationTime()) {
    LOG.info("Mismatching timestamp for " + srcPath + " and "+ parityPath+ ", moving on...");
    return false;
  }
  String uriPath=parityPath.toUri().getPath();
  int numBlocksFixed=0;
  List<LocatedBlock> corrupt=RaidDFSUtil.corruptBlocksInFile(parityFs,uriPath,0,parityFileSize);
  if (corrupt.size() == 0) {
    return false;
  }
  for (  LocatedBlock lb : corrupt) {
    ExtendedBlock corruptBlock=lb.getBlock();
    long corruptOffset=lb.getStartOffset();
    LOG.info("Found corrupt block " + corruptBlock + ", offset "+ corruptOffset);
    File localBlockFile=File.createTempFile(corruptBlock.getBlockName(),".tmp");
    localBlockFile.deleteOnExit();
    try {
      encoder.recoverParityBlockToFile(parityFs,srcPath,srcFileSize,blockSize,parityPath,corruptOffset,localBlockFile);
      DatanodeInfo datanode=chooseDatanode(lb.getLocations());
      computeMetadataAndSendFixedBlock(datanode,localBlockFile,lb,blockSize);
      numBlocksFixed++;
    }
  finally {
      localBlockFile.delete();
    }
    progress.progress();
  }
  LOG.info("Fixed " + numBlocksFixed + " blocks in "+ parityPath);
  return true;
}
