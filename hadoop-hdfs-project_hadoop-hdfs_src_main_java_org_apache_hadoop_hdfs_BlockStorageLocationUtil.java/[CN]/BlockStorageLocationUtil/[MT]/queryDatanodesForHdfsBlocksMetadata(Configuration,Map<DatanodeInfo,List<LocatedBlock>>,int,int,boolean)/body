{
  List<VolumeBlockLocationCallable> callables=createVolumeBlockLocationCallables(conf,datanodeBlocks,timeoutMs,connectToDnViaHostname);
  List<Future<HdfsBlocksMetadata>> futures=new ArrayList<Future<HdfsBlocksMetadata>>();
  ExecutorService executor=new ScheduledThreadPoolExecutor(poolsize);
  try {
    futures=executor.invokeAll(callables,timeoutMs,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e) {
  }
  executor.shutdown();
  Map<DatanodeInfo,HdfsBlocksMetadata> metadatas=Maps.newHashMapWithExpectedSize(datanodeBlocks.size());
  for (int i=0; i < futures.size(); i++) {
    VolumeBlockLocationCallable callable=callables.get(i);
    DatanodeInfo datanode=callable.getDatanodeInfo();
    Future<HdfsBlocksMetadata> future=futures.get(i);
    try {
      HdfsBlocksMetadata metadata=future.get();
      metadatas.put(callable.getDatanodeInfo(),metadata);
    }
 catch (    CancellationException e) {
      LOG.info("Cancelled while waiting for datanode " + datanode.getIpcAddr(false) + ": "+ e.toString());
    }
catch (    ExecutionException e) {
      Throwable t=e.getCause();
      if (t instanceof InvalidBlockTokenException) {
        LOG.warn("Invalid access token when trying to retrieve " + "information from datanode " + datanode.getIpcAddr(false));
        throw (InvalidBlockTokenException)t;
      }
 else       if (t instanceof UnsupportedOperationException) {
        LOG.info("Datanode " + datanode.getIpcAddr(false) + " does not support"+ " required #getHdfsBlocksMetadata() API");
        throw (UnsupportedOperationException)t;
      }
 else {
        LOG.info("Failed to query block locations on datanode " + datanode.getIpcAddr(false) + ": "+ t);
      }
      if (LOG.isDebugEnabled()) {
        LOG.debug("Could not fetch information from datanode",t);
      }
    }
catch (    InterruptedException e) {
      LOG.info("Interrupted while fetching HdfsBlocksMetadata");
    }
  }
  return metadatas;
}
