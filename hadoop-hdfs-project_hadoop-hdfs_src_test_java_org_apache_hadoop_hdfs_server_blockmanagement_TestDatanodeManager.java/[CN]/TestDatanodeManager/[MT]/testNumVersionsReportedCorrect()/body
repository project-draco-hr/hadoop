{
  FSNamesystem fsn=Mockito.mock(FSNamesystem.class);
  Mockito.when(fsn.hasWriteLock()).thenReturn(true);
  DatanodeManager dm=new DatanodeManager(Mockito.mock(BlockManager.class),fsn,new Configuration());
  Random rng=new Random();
  int seed=rng.nextInt();
  rng=new Random(seed);
  LOG.info("Using seed " + seed + " for testing");
  HashMap<String,DatanodeRegistration> sIdToDnReg=new HashMap<String,DatanodeRegistration>();
  for (int i=0; i < NUM_ITERATIONS; ++i) {
    if (rng.nextBoolean() && i % 3 == 0 && sIdToDnReg.size() != 0) {
      int randomIndex=rng.nextInt() % sIdToDnReg.size();
      Iterator<Map.Entry<String,DatanodeRegistration>> it=sIdToDnReg.entrySet().iterator();
      for (int j=0; j < randomIndex - 1; ++j) {
        it.next();
      }
      DatanodeRegistration toRemove=it.next().getValue();
      LOG.info("Removing node " + toRemove.getDatanodeUuid() + " ip "+ toRemove.getXferAddr()+ " version : "+ toRemove.getSoftwareVersion());
      dm.removeDatanode(toRemove);
      it.remove();
    }
 else {
      String storageID="someStorageID" + rng.nextInt(5000);
      DatanodeRegistration dr=Mockito.mock(DatanodeRegistration.class);
      Mockito.when(dr.getDatanodeUuid()).thenReturn(storageID);
      if (sIdToDnReg.containsKey(storageID)) {
        dr=sIdToDnReg.get(storageID);
        if (rng.nextBoolean()) {
          dr.setIpAddr(dr.getIpAddr() + "newIP");
        }
      }
 else {
        String ip="someIP" + storageID;
        Mockito.when(dr.getIpAddr()).thenReturn(ip);
        Mockito.when(dr.getXferAddr()).thenReturn(ip + ":9000");
        Mockito.when(dr.getXferPort()).thenReturn(9000);
      }
      Mockito.when(dr.getSoftwareVersion()).thenReturn("version" + rng.nextInt(5));
      LOG.info("Registering node storageID: " + dr.getDatanodeUuid() + ", version: "+ dr.getSoftwareVersion()+ ", IP address: "+ dr.getXferAddr());
      dm.registerDatanode(dr);
      sIdToDnReg.put(storageID,dr);
    }
    Map<String,Integer> mapToCheck=dm.getDatanodesSoftwareVersions();
    for (    Entry<String,DatanodeRegistration> it : sIdToDnReg.entrySet()) {
      String ver=it.getValue().getSoftwareVersion();
      if (!mapToCheck.containsKey(ver)) {
        throw new AssertionError("The correct number of datanodes of a " + "version was not found on iteration " + i);
      }
      mapToCheck.put(ver,mapToCheck.get(ver) - 1);
      if (mapToCheck.get(ver) == 0) {
        mapToCheck.remove(ver);
      }
    }
    for (    Entry<String,Integer> entry : mapToCheck.entrySet()) {
      LOG.info("Still in map: " + entry.getKey() + " has "+ entry.getValue());
    }
    assertEquals("The map of version counts returned by DatanodeManager was" + " not what it was expected to be on iteration " + i,0,mapToCheck.size());
  }
}
