{
  Map<Future<Void>,Integer> futures=new HashMap<>();
  CompletionService<Void> service=new ExecutorCompletionService<>(dfsClient.getStripedReadsThreadPool());
  if (alignedStripe.getSpanInBlock() == 0) {
    DFSClient.LOG.warn("Trying to read an empty stripe from" + blockGroup);
    return;
  }
  LocatedBlock[] blks=StripedBlockUtil.parseStripedBlockGroup(blockGroup,cellSize,dataBlkNum,parityBlkNum);
  for (short i=0; i < dataBlkNum; i++) {
    if (alignedStripe.chunks[i] != null && alignedStripe.chunks[i].state != StripingChunk.ALLZERO) {
      fetchOneStripingChunk(futures,service,blks[i],alignedStripe,i,corruptedBlockMap);
    }
  }
  byte[][] decodeInputs=null;
  while (!futures.isEmpty()) {
    try {
      StripingChunkReadResult r=getNextCompletedStripedRead(service,futures,0);
      if (DFSClient.LOG.isDebugEnabled()) {
        DFSClient.LOG.debug("Read task returned: " + r + ", for stripe "+ alignedStripe);
      }
      StripingChunk returnedChunk=alignedStripe.chunks[r.index];
      Preconditions.checkNotNull(returnedChunk);
      Preconditions.checkState(returnedChunk.state == StripingChunk.PENDING);
      if (r.state == StripingChunkReadResult.SUCCESSFUL) {
        returnedChunk.state=StripingChunk.FETCHED;
        alignedStripe.fetchedChunksNum++;
        if (alignedStripe.fetchedChunksNum == dataBlkNum) {
          clearFutures(futures.keySet());
          break;
        }
      }
 else {
        returnedChunk.state=StripingChunk.MISSING;
        alignedStripe.missingChunksNum++;
        if (alignedStripe.missingChunksNum > parityBlkNum) {
          clearFutures(futures.keySet());
          throw new IOException("Too many blocks are missing: " + alignedStripe);
        }
        if (decodeInputs == null) {
          decodeInputs=initDecodeInputs(alignedStripe,dataBlkNum,parityBlkNum);
        }
        for (int i=0; i < alignedStripe.chunks.length; i++) {
          StripingChunk chunk=alignedStripe.chunks[i];
          Preconditions.checkNotNull(chunk);
          if (chunk.state == StripingChunk.REQUESTED && i <= dataBlkNum) {
            fetchOneStripingChunk(futures,service,blks[i],alignedStripe,i,corruptedBlockMap);
          }
        }
      }
    }
 catch (    InterruptedException ie) {
      String err="Read request interrupted";
      DFSClient.LOG.error(err);
      clearFutures(futures.keySet());
      throw new InterruptedIOException(err);
    }
  }
  if (alignedStripe.missingChunksNum > 0) {
    finalizeDecodeInputs(decodeInputs,dataBlkNum,parityBlkNum,alignedStripe);
    decodeAndFillBuffer(decodeInputs,buf,alignedStripe,dataBlkNum,parityBlkNum,decoder);
  }
}
