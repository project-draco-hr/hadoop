{
  dfsClient.checkOpen();
  if (closed.get()) {
    throw new IOException("Stream closed");
  }
  Map<ExtendedBlock,Set<DatanodeInfo>> corruptedBlockMap=new ConcurrentHashMap<>();
  if (pos < getFileLength()) {
    try {
      if (pos > blockEnd) {
        blockSeekTo(pos);
      }
      int realLen=(int)Math.min(len,(blockEnd - pos + 1L));
synchronized (infoLock) {
        if (locatedBlocks.isLastBlockComplete()) {
          realLen=(int)Math.min(realLen,locatedBlocks.getFileLength() - pos);
        }
      }
      int result=0;
      while (result < realLen) {
        if (!curStripeRange.include(getOffsetInBlockGroup())) {
          readOneStripe(corruptedBlockMap);
        }
        int ret=copyToTargetBuf(strategy,off + result,realLen - result);
        result+=ret;
        pos+=ret;
      }
      if (dfsClient.stats != null) {
        dfsClient.stats.incrementBytesRead(result);
      }
      return result;
    }
  finally {
      reportCheckSumFailure(corruptedBlockMap,currentLocatedBlock.getLocations().length);
    }
  }
  return -1;
}
