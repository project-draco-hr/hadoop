{
  final int span=(int)alignedStripe.getSpanInBlock();
  for (int i=0; i < alignedStripe.chunks.length; i++) {
    final int decodeIndex=StripedBlockUtil.convertIndex4Decode(i,dataBlkNum,parityBlkNum);
    if (alignedStripe.chunks[i] != null && alignedStripe.chunks[i].state == StripingChunk.ALLZERO) {
      for (int j=0; j < span; j++) {
        decodeInputs[decodeIndex].put((byte)0);
      }
      decodeInputs[decodeIndex].flip();
    }
 else     if (alignedStripe.chunks[i] != null && alignedStripe.chunks[i].state == StripingChunk.FETCHED) {
      decodeInputs[decodeIndex].position(0);
      decodeInputs[decodeIndex].limit(span);
    }
  }
  int[] decodeIndices=new int[parityBlkNum];
  int pos=0;
  for (int i=0; i < alignedStripe.chunks.length; i++) {
    if (alignedStripe.chunks[i] != null && alignedStripe.chunks[i].state == StripingChunk.MISSING) {
      decodeIndices[pos++]=StripedBlockUtil.convertIndex4Decode(i,dataBlkNum,parityBlkNum);
    }
  }
  decodeIndices=Arrays.copyOf(decodeIndices,pos);
  final int decodeChunkNum=decodeIndices.length;
  ByteBuffer[] outputs=new ByteBuffer[decodeChunkNum];
  for (int i=0; i < decodeChunkNum; i++) {
    outputs[i]=decodeInputs[decodeIndices[i]];
    outputs[i].position(0);
    outputs[i].limit((int)alignedStripe.range.spanInBlock);
    decodeInputs[decodeIndices[i]]=null;
  }
  decoder.decode(decodeInputs,decodeIndices,outputs);
}
