{
  final StripingChunk chunk=alignedStripe.chunks[chunkIndex];
  final BlockReaderInfo readerInfo=blockReaders[chunkIndex];
  if (readerInfo == null || block == null || readerInfo.shouldSkip) {
    chunk.state=StripingChunk.MISSING;
    return false;
  }
  chunk.state=StripingChunk.PENDING;
  ByteBufferStrategy strategy=new ByteBufferStrategy(chunk.byteBuffer);
  Callable<Void> readCallable=readCell(readerInfo.reader,readerInfo.datanode,readerInfo.blockReaderOffset,alignedStripe.getOffsetInBlock(),strategy,chunk.byteBuffer.remaining(),block.getBlock(),corruptedBlockMap);
  Future<Void> request=readingService.submit(readCallable);
  futures.put(request,chunkIndex);
  return true;
}
