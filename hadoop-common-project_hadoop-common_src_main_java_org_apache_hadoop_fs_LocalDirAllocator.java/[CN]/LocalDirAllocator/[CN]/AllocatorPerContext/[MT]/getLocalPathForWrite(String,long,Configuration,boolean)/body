{
  Context ctx=confChanged(conf);
  int numDirs=ctx.localDirs.length;
  int numDirsSearched=0;
  if (pathStr.startsWith("/")) {
    pathStr=pathStr.substring(1);
  }
  Path returnPath=null;
  if (size == SIZE_UNKNOWN) {
    long[] availableOnDisk=new long[ctx.dirDF.length];
    long totalAvailable=0;
    for (int i=0; i < ctx.dirDF.length; ++i) {
      availableOnDisk[i]=ctx.dirDF[i].getAvailable();
      totalAvailable+=availableOnDisk[i];
    }
    if (totalAvailable == 0) {
      throw new DiskErrorException("No space available in any of the local directories.");
    }
    Random r=new java.util.Random();
    while (numDirsSearched < numDirs && returnPath == null) {
      long randomPosition=(r.nextLong() >>> 1) % totalAvailable;
      int dir=0;
      while (randomPosition > availableOnDisk[dir]) {
        randomPosition-=availableOnDisk[dir];
        dir++;
      }
      ctx.dirNumLastAccessed.set(dir);
      returnPath=createPath(ctx.localDirs[dir],pathStr,checkWrite);
      if (returnPath == null) {
        totalAvailable-=availableOnDisk[dir];
        availableOnDisk[dir]=0;
        numDirsSearched++;
      }
    }
  }
 else {
    int dirNum=ctx.getAndIncrDirNumLastAccessed();
    while (numDirsSearched < numDirs) {
      long capacity=ctx.dirDF[dirNum].getAvailable();
      if (capacity > size) {
        returnPath=createPath(ctx.localDirs[dirNum],pathStr,checkWrite);
        if (returnPath != null) {
          ctx.getAndIncrDirNumLastAccessed(numDirsSearched);
          break;
        }
      }
      dirNum++;
      dirNum=dirNum % numDirs;
      numDirsSearched++;
    }
  }
  if (returnPath != null) {
    return returnPath;
  }
  throw new DiskErrorException("Could not find any valid local " + "directory for " + pathStr);
}
