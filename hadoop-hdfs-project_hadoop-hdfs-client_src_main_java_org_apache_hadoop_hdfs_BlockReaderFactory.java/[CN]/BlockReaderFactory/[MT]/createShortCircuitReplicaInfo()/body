{
  if (createShortCircuitReplicaInfoCallback != null) {
    ShortCircuitReplicaInfo info=createShortCircuitReplicaInfoCallback.createShortCircuitReplicaInfo();
    if (info != null)     return info;
  }
  LOG.trace("{}: trying to create ShortCircuitReplicaInfo.",this);
  BlockReaderPeer curPeer;
  while (true) {
    curPeer=nextDomainPeer();
    if (curPeer == null)     break;
    if (curPeer.fromCache)     remainingCacheTries--;
    DomainPeer peer=(DomainPeer)curPeer.peer;
    Slot slot=null;
    ShortCircuitCache cache=clientContext.getShortCircuitCache();
    try {
      MutableBoolean usedPeer=new MutableBoolean(false);
      slot=cache.allocShmSlot(datanode,peer,usedPeer,new ExtendedBlockId(block.getBlockId(),block.getBlockPoolId()),clientName);
      if (usedPeer.booleanValue()) {
        LOG.trace("{}: allocShmSlot used up our previous socket {}.  " + "Allocating a new one...",this,peer.getDomainSocket());
        curPeer=nextDomainPeer();
        if (curPeer == null)         break;
        peer=(DomainPeer)curPeer.peer;
      }
      ShortCircuitReplicaInfo info=requestFileDescriptors(peer,slot);
      clientContext.getPeerCache().put(datanode,peer);
      return info;
    }
 catch (    IOException e) {
      if (slot != null) {
        cache.freeSlot(slot);
      }
      if (curPeer.fromCache) {
        LOG.debug("{}: closing stale domain peer {}",this,peer,e);
        IOUtilsClient.cleanup(LOG,peer);
      }
 else {
        LOG.warn(this + ": I/O error requesting file descriptors.  " + "Disabling domain socket "+ peer.getDomainSocket(),e);
        IOUtilsClient.cleanup(LOG,peer);
        clientContext.getDomainSocketFactory().disableDomainSocketPath(pathInfo.getPath());
        return null;
      }
    }
  }
  return null;
}
