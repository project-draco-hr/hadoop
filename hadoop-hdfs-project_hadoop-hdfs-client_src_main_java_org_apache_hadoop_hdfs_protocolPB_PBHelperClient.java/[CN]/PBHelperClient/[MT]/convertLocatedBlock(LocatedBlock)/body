{
  if (b == null)   return null;
  Builder builder=LocatedBlockProto.newBuilder();
  DatanodeInfo[] locs=b.getLocations();
  List<DatanodeInfo> cachedLocs=Lists.newLinkedList(Arrays.asList(b.getCachedLocations()));
  for (int i=0; i < locs.length; i++) {
    DatanodeInfo loc=locs[i];
    builder.addLocs(i,PBHelperClient.convert(loc));
    boolean locIsCached=cachedLocs.contains(loc);
    builder.addIsCached(locIsCached);
    if (locIsCached) {
      cachedLocs.remove(loc);
    }
  }
  Preconditions.checkArgument(cachedLocs.size() == 0,"Found additional cached replica locations that are not in the set of" + " storage-backed locations!");
  StorageType[] storageTypes=b.getStorageTypes();
  if (storageTypes != null) {
    for (    StorageType storageType : storageTypes) {
      builder.addStorageTypes(convertStorageType(storageType));
    }
  }
  final String[] storageIDs=b.getStorageIDs();
  if (storageIDs != null) {
    builder.addAllStorageIDs(Arrays.asList(storageIDs));
  }
  if (b instanceof LocatedStripedBlock) {
    LocatedStripedBlock sb=(LocatedStripedBlock)b;
    byte[] indices=sb.getBlockIndices();
    builder.setBlockIndices(PBHelperClient.getByteString(indices));
    Token<BlockTokenIdentifier>[] blockTokens=sb.getBlockTokens();
    builder.addAllBlockTokens(convert(blockTokens));
  }
  return builder.setB(PBHelperClient.convert(b.getBlock())).setBlockToken(PBHelperClient.convert(b.getBlockToken())).setCorrupt(b.isCorrupt()).setOffset(b.getStartOffset()).build();
}
