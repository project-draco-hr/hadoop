def main():
    parser = OptionParser(usage='usage: %prog --project PROJECT [--project PROJECT] --version VERSION [--version VERSION2 ...]', epilog='Markdown-formatted CHANGES and RELEASENOTES files will be stored in a directory named after the highest version provided.')
    parser.add_option('-i', '--index', dest='index', action='store_true', default=False, help='build an index file')
    parser.add_option('-l', '--license', dest='license', action='store_false', default=True, help='Add an ASF license')
    parser.add_option('-n', '--lint', dest='lint', action='store_true', help='use lint flag to exit on failures')
    parser.add_option('-p', '--project', dest='projects', action='append', type='string', help='projects in JIRA to include in releasenotes', metavar='PROJECT')
    parser.add_option('-r', '--range', dest='range', action='store_true', default=False, help='Given versions are a range')
    parser.add_option('-t', '--projecttitle', dest='title', type='string', help='Title to use for the project (default is Apache PROJECT)')
    parser.add_option('-u', '--usetoday', dest='usetoday', action='store_true', default=False, help='use current date for unreleased versions')
    parser.add_option('-v', '--version', dest='versions', action='append', type='string', help='versions in JIRA to include in releasenotes', metavar='VERSION')
    (options, args) = parser.parse_args()
    if (options.versions is None):
        options.versions = []
    if (len(args) > 2):
        options.versions.append(args[2])
    if (len(options.versions) <= 0):
        parser.error('At least one version needs to be supplied')
    projects = options.projects
    if (options.range is True):
        versions = [Version(v) for v in GetVersions(options.versions, projects).getlist()]
    else:
        versions = [Version(v) for v in options.versions]
    versions.sort()
    if (options.title is None):
        title = projects[0]
    else:
        title = options.title
    haderrors = False
    for v in versions:
        vstr = str(v)
        jlist = JiraIter(vstr, projects)
        if (vstr in releaseVersion):
            reldate = releaseVersion[vstr]
        elif options.usetoday:
            reldate = strftime('%Y-%m-%d', gmtime())
        else:
            reldate = 'Unreleased'
        if (not os.path.exists(vstr)):
            os.mkdir(vstr)
        reloutputs = Outputs('%(ver)s/RELEASENOTES.%(ver)s.md', '%(ver)s/RELEASENOTES.%(key)s.%(ver)s.md', [], {'ver': v, 'date': reldate, 'title': title, })
        choutputs = Outputs('%(ver)s/CHANGES.%(ver)s.md', '%(ver)s/CHANGES.%(key)s.%(ver)s.md', [], {'ver': v, 'date': reldate, 'title': title, })
        if (options.license is True):
            reloutputs.writeAll(asflicense)
            choutputs.writeAll(asflicense)
        relhead = '# %(title)s %(key)s %(ver)s Release Notes\n\nThese release notes cover new developer and user-facing incompatibilities, features, and major improvements.\n\n'
        chhead = '# %(title)s Changelog\n\n## Release %(ver)s - %(date)s\n\n'
        reloutputs.writeAll(relhead)
        choutputs.writeAll(chhead)
        errorCount = 0
        warningCount = 0
        lintMessage = ''
        incompatlist = []
        buglist = []
        improvementlist = []
        newfeaturelist = []
        subtasklist = []
        tasklist = []
        testlist = []
        otherlist = []
        for jira in sorted(jlist):
            if jira.getIncompatibleChange():
                incompatlist.append(jira)
            elif (jira.getType() == 'Bug'):
                buglist.append(jira)
            elif (jira.getType() == 'Improvement'):
                improvementlist.append(jira)
            elif (jira.getType() == 'New Feature'):
                newfeaturelist.append(jira)
            elif (jira.getType() == 'Sub-task'):
                subtasklist.append(jira)
            elif (jira.getType() == 'Task'):
                tasklist.append(jira)
            elif (jira.getType() == 'Test'):
                testlist.append(jira)
            else:
                otherlist.append(jira)
            line = ('* [%s](https://issues.apache.org/jira/browse/%s) | *%s* | **%s**\n' % (notableclean(jira.getId()), notableclean(jira.getId()), notableclean(jira.getPriority()), notableclean(jira.getSummary())))
            if (jira.getIncompatibleChange() and (len(jira.getReleaseNote()) == 0)):
                warningCount += 1
                reloutputs.writeKeyRaw(jira.getProject(), '\n---\n\n')
                reloutputs.writeKeyRaw(jira.getProject(), line)
                line = '\n**WARNING: No release note provided for this incompatible change.**\n\n'
                lintMessage += ('\nWARNING: incompatible change %s lacks release notes.' % notableclean(jira.getId()))
                reloutputs.writeKeyRaw(jira.getProject(), line)
            if jira.checkVersionString():
                warningCount += 1
                lintMessage += ('\nWARNING: Version string problem for %s ' % jira.getId())
            if (jira.checkMissingComponent() or jira.checkMissingAssignee()):
                errorCount += 1
                errorMessage = []
                (jira.checkMissingComponent() and errorMessage.append('component'))
                (jira.checkMissingAssignee() and errorMessage.append('assignee'))
                lintMessage += ('\nERROR: missing %s for %s ' % (' and '.join(errorMessage), jira.getId()))
            if (len(jira.getReleaseNote()) > 0):
                reloutputs.writeKeyRaw(jira.getProject(), '\n---\n\n')
                reloutputs.writeKeyRaw(jira.getProject(), line)
                line = ('\n%s\n\n' % tableclean(jira.getReleaseNote()))
                reloutputs.writeKeyRaw(jira.getProject(), line)
        if (options.lint is True):
            print lintMessage
            print '======================================='
            print ('%s: Error:%d, Warning:%d \n' % (vstr, errorCount, warningCount))
            if (errorCount > 0):
                haderrors = True
                cleanOutputDir(vstr)
                continue
        reloutputs.writeAll('\n\n')
        reloutputs.close()
        choutputs.writeAll('### INCOMPATIBLE CHANGES:\n\n')
        choutputs.writeAll('| JIRA | Summary | Priority | Component | Reporter | Contributor |\n')
        choutputs.writeAll('|:---- |:---- | :--- |:---- |:---- |:---- |\n')
        choutputs.writeList(incompatlist)
        choutputs.writeAll('\n\n### NEW FEATURES:\n\n')
        choutputs.writeAll('| JIRA | Summary | Priority | Component | Reporter | Contributor |\n')
        choutputs.writeAll('|:---- |:---- | :--- |:---- |:---- |:---- |\n')
        choutputs.writeList(newfeaturelist)
        choutputs.writeAll('\n\n### IMPROVEMENTS:\n\n')
        choutputs.writeAll('| JIRA | Summary | Priority | Component | Reporter | Contributor |\n')
        choutputs.writeAll('|:---- |:---- | :--- |:---- |:---- |:---- |\n')
        choutputs.writeList(improvementlist)
        choutputs.writeAll('\n\n### BUG FIXES:\n\n')
        choutputs.writeAll('| JIRA | Summary | Priority | Component | Reporter | Contributor |\n')
        choutputs.writeAll('|:---- |:---- | :--- |:---- |:---- |:---- |\n')
        choutputs.writeList(buglist)
        choutputs.writeAll('\n\n### TESTS:\n\n')
        choutputs.writeAll('| JIRA | Summary | Priority | Component | Reporter | Contributor |\n')
        choutputs.writeAll('|:---- |:---- | :--- |:---- |:---- |:---- |\n')
        choutputs.writeList(testlist)
        choutputs.writeAll('\n\n### SUB-TASKS:\n\n')
        choutputs.writeAll('| JIRA | Summary | Priority | Component | Reporter | Contributor |\n')
        choutputs.writeAll('|:---- |:---- | :--- |:---- |:---- |:---- |\n')
        choutputs.writeList(subtasklist)
        choutputs.writeAll('\n\n### OTHER:\n\n')
        choutputs.writeAll('| JIRA | Summary | Priority | Component | Reporter | Contributor |\n')
        choutputs.writeAll('|:---- |:---- | :--- |:---- |:---- |:---- |\n')
        choutputs.writeList(otherlist)
        choutputs.writeList(tasklist)
        choutputs.writeAll('\n\n')
        choutputs.close()
    if options.index:
        buildindex(title, options.license)
    if (haderrors is True):
        sys.exit(1)
