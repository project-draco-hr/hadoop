{
  final String basePath="testBatchAsyncAcl";
  final Path parent=new Path(String.format("/test/%s/",basePath));
  AsyncDistributedFileSystem adfs=cluster.getFileSystem().getAsyncDistributedFileSystem();
  int count=NUM_TESTS;
  final Path[] paths=new Path[count];
  for (int i=0; i < count; i++) {
    paths[i]=new Path(parent,"acl" + i);
    FileSystem.mkdirs(fs,paths[i],FsPermission.createImmutable((short)0750));
    assertTrue(fs.exists(paths[i]));
    assertTrue(fs.getFileStatus(paths[i]).isDirectory());
  }
  final List<AclEntry> aclSpec=getAclSpec();
  final AclEntry[] expectedAclSpec=getExpectedAclSpec();
  Map<Integer,Future<Void>> setAclRetFutures=new HashMap<Integer,Future<Void>>();
  Map<Integer,Future<AclStatus>> getAclRetFutures=new HashMap<Integer,Future<AclStatus>>();
  int start=0, end=0;
  try {
    for (int i=0; i < count; i++) {
      for (; ; ) {
        try {
          Future<Void> retFuture=adfs.setAcl(paths[i],aclSpec);
          setAclRetFutures.put(i,retFuture);
          break;
        }
 catch (        AsyncCallLimitExceededException e) {
          start=end;
          end=i;
          waitForAclReturnValues(setAclRetFutures,start,end);
        }
      }
    }
    waitForAclReturnValues(setAclRetFutures,end,count);
    start=0;
    end=0;
    for (int i=0; i < count; i++) {
      for (; ; ) {
        try {
          Future<AclStatus> retFuture=adfs.getAclStatus(paths[i]);
          getAclRetFutures.put(i,retFuture);
          break;
        }
 catch (        AsyncCallLimitExceededException e) {
          start=end;
          end=i;
          waitForAclReturnValues(getAclRetFutures,start,end,paths,expectedAclSpec);
        }
      }
    }
    waitForAclReturnValues(getAclRetFutures,end,count,paths,expectedAclSpec);
  }
 catch (  Exception e) {
    throw e;
  }
}
