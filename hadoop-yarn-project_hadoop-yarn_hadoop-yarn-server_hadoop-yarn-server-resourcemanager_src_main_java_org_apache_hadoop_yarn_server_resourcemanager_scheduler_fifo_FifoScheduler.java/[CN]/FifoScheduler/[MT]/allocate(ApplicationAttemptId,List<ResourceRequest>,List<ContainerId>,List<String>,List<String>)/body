{
  FiCaSchedulerApp application=getApplication(applicationAttemptId);
  if (application == null) {
    LOG.error("Calling allocate on removed " + "or non existant application " + applicationAttemptId);
    return EMPTY_ALLOCATION;
  }
  SchedulerUtils.normalizeRequests(ask,resourceCalculator,clusterResource,minimumAllocation,maximumAllocation);
  for (  ContainerId releasedContainer : release) {
    RMContainer rmContainer=getRMContainer(releasedContainer);
    if (rmContainer == null) {
      RMAuditLogger.logFailure(application.getUser(),AuditConstants.RELEASE_CONTAINER,"Unauthorized access or invalid container","FifoScheduler","Trying to release container not owned by app or with invalid id",application.getApplicationId(),releasedContainer);
    }
    containerCompleted(rmContainer,SchedulerUtils.createAbnormalContainerStatus(releasedContainer,SchedulerUtils.RELEASED_CONTAINER),RMContainerEventType.RELEASED);
  }
synchronized (application) {
    if (application.isStopped()) {
      LOG.info("Calling allocate on a stopped " + "application " + applicationAttemptId);
      return EMPTY_ALLOCATION;
    }
    if (!ask.isEmpty()) {
      LOG.debug("allocate: pre-update" + " applicationId=" + applicationAttemptId + " application="+ application);
      application.showRequests();
      application.updateResourceRequests(ask,blacklistAdditions,blacklistRemovals);
      LOG.debug("allocate: post-update" + " applicationId=" + applicationAttemptId + " application="+ application);
      application.showRequests();
      LOG.debug("allocate:" + " applicationId=" + applicationAttemptId + " #ask="+ ask.size());
    }
    return new Allocation(application.pullNewlyAllocatedContainers(),application.getHeadroom());
  }
}
