{
  AMRMTokenIdentifier amrmTokenIdentifier=authorizeRequest();
  ApplicationAttemptId applicationAttemptId=amrmTokenIdentifier.getApplicationAttemptId();
  ApplicationId appID=applicationAttemptId.getApplicationId();
  AllocateResponseLock lock=responseMap.get(applicationAttemptId);
  if (lock == null) {
    RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),AuditConstants.REGISTER_AM,"Application doesn't exist in cache " + applicationAttemptId,"ApplicationMasterService","Error in registering application master",appID,applicationAttemptId);
    throwApplicationDoesNotExistInCacheException(applicationAttemptId);
  }
synchronized (lock) {
    AllocateResponse lastResponse=lock.getAllocateResponse();
    if (hasApplicationMasterRegistered(applicationAttemptId)) {
      String message="Application Master is already registered : " + appID;
      LOG.warn(message);
      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),AuditConstants.REGISTER_AM,"","ApplicationMasterService",message,appID,applicationAttemptId);
      throw new InvalidApplicationMasterRequestException(message);
    }
    this.amLivelinessMonitor.receivedPing(applicationAttemptId);
    RMApp app=this.rmContext.getRMApps().get(appID);
    lastResponse.setResponseId(0);
    lock.setAllocateResponse(lastResponse);
    LOG.info("AM registration " + applicationAttemptId);
    this.rmContext.getDispatcher().getEventHandler().handle(new RMAppAttemptRegistrationEvent(applicationAttemptId,request.getHost(),request.getRpcPort(),request.getTrackingUrl()));
    RMAuditLogger.logSuccess(app.getUser(),AuditConstants.REGISTER_AM,"ApplicationMasterService",appID,applicationAttemptId);
    RegisterApplicationMasterResponse response=recordFactory.newRecordInstance(RegisterApplicationMasterResponse.class);
    response.setMaximumResourceCapability(rScheduler.getMaximumResourceCapability(app.getQueue()));
    response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId).getSubmissionContext().getAMContainerSpec().getApplicationACLs());
    response.setQueue(app.getQueue());
    if (UserGroupInformation.isSecurityEnabled()) {
      LOG.info("Setting client token master key");
      response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext.getClientToAMTokenSecretManager().getMasterKey(applicationAttemptId).getEncoded()));
    }
    List<Container> transferredContainers=((AbstractYarnScheduler)rScheduler).getTransferredContainers(applicationAttemptId);
    if (!transferredContainers.isEmpty()) {
      response.setContainersFromPreviousAttempts(transferredContainers);
      List<NMToken> nmTokens=new ArrayList<NMToken>();
      for (      Container container : transferredContainers) {
        try {
          NMToken token=rmContext.getNMTokenSecretManager().createAndGetNMToken(app.getUser(),applicationAttemptId,container);
          if (null != token) {
            nmTokens.add(token);
          }
        }
 catch (        IllegalArgumentException e) {
          if (e.getCause() instanceof UnknownHostException) {
            throw (UnknownHostException)e.getCause();
          }
        }
      }
      response.setNMTokensFromPreviousAttempts(nmTokens);
      LOG.info("Application " + appID + " retrieved "+ transferredContainers.size()+ " containers from previous"+ " attempts and "+ nmTokens.size()+ " NM tokens.");
    }
    response.setSchedulerResourceTypes(rScheduler.getSchedulingResourceTypes());
    return response;
  }
}
