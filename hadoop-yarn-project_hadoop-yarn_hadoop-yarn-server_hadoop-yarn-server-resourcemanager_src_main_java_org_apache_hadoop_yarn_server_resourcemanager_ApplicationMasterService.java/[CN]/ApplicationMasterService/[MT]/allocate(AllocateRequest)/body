{
  ApplicationAttemptId appAttemptId=request.getApplicationAttemptId();
  authorizeRequest(appAttemptId);
  this.amLivelinessMonitor.receivedPing(appAttemptId);
  AllocateResponse lastResponse=responseMap.get(appAttemptId);
  if (lastResponse == null) {
    LOG.error("AppAttemptId doesnt exist in cache " + appAttemptId);
    return resync;
  }
  if ((request.getResponseId() + 1) == lastResponse.getResponseId()) {
    return lastResponse;
  }
 else   if (request.getResponseId() + 1 < lastResponse.getResponseId()) {
    LOG.error("Invalid responseid from appAttemptId " + appAttemptId);
    return resync;
  }
synchronized (lastResponse) {
    this.rmContext.getDispatcher().getEventHandler().handle(new RMAppAttemptStatusupdateEvent(appAttemptId,request.getProgress()));
    List<ResourceRequest> ask=request.getAskList();
    List<ContainerId> release=request.getReleaseList();
    try {
      SchedulerUtils.validateResourceRequests(ask,rScheduler.getMaximumResourceCapability());
    }
 catch (    InvalidResourceRequestException e) {
      LOG.warn("Invalid resource ask by application " + appAttemptId,e);
      throw RPCUtil.getRemoteException(e);
    }
    Allocation allocation=this.rScheduler.allocate(appAttemptId,ask,release);
    RMApp app=this.rmContext.getRMApps().get(appAttemptId.getApplicationId());
    RMAppAttempt appAttempt=app.getRMAppAttempt(appAttemptId);
    AllocateResponse allocateResponse=recordFactory.newRecordInstance(AllocateResponse.class);
    List<RMNode> updatedNodes=new ArrayList<RMNode>();
    if (app.pullRMNodeUpdates(updatedNodes) > 0) {
      List<NodeReport> updatedNodeReports=new ArrayList<NodeReport>();
      for (      RMNode rmNode : updatedNodes) {
        SchedulerNodeReport schedulerNodeReport=rScheduler.getNodeReport(rmNode.getNodeID());
        Resource used=BuilderUtils.newResource(0,0);
        int numContainers=0;
        if (schedulerNodeReport != null) {
          used=schedulerNodeReport.getUsedResource();
          numContainers=schedulerNodeReport.getNumContainers();
        }
        NodeReport report=BuilderUtils.newNodeReport(rmNode.getNodeID(),rmNode.getState(),rmNode.getHttpAddress(),rmNode.getRackName(),used,rmNode.getTotalCapability(),numContainers,rmNode.getNodeHealthStatus());
        updatedNodeReports.add(report);
      }
      allocateResponse.setUpdatedNodes(updatedNodeReports);
    }
    allocateResponse.setAllocatedContainers(allocation.getContainers());
    allocateResponse.setCompletedContainersStatuses(appAttempt.pullJustFinishedContainers());
    allocateResponse.setResponseId(lastResponse.getResponseId() + 1);
    allocateResponse.setAvailableResources(allocation.getResourceLimit());
    AllocateResponse oldResponse=responseMap.put(appAttemptId,allocateResponse);
    if (oldResponse == null) {
      responseMap.remove(appAttemptId);
      String message="App Attempt removed from the cache during allocate" + appAttemptId;
      LOG.error(message);
      return resync;
    }
    allocateResponse.setNumClusterNodes(this.rScheduler.getNumClusterNodes());
    allocateResponse.setPreemptionMessage(generatePreemptionMessage(allocation));
    return allocateResponse;
  }
}
