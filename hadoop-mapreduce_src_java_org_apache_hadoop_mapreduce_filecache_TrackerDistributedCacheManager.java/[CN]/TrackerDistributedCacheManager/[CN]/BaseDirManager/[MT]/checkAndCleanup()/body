{
  Collection<CacheStatus> toBeDeletedCache=new LinkedList<CacheStatus>();
  HashMap<Path,CacheDir> toBeCleanedBaseDir=new HashMap<Path,CacheDir>();
synchronized (properties) {
    for (    Map.Entry<Path,CacheDir> baseDir : properties.entrySet()) {
      CacheDir baseDirCounts=baseDir.getValue();
      if (allowedCacheSize < baseDirCounts.size || allowedCacheSubdirs < baseDirCounts.subdirs) {
        CacheDir tcc=new CacheDir();
        tcc.size=baseDirCounts.size - allowedCacheSizeCleanupGoal;
        tcc.subdirs=baseDirCounts.subdirs - allowedCacheSubdirsCleanupGoal;
        toBeCleanedBaseDir.put(baseDir.getKey(),tcc);
      }
    }
  }
synchronized (cachedArchives) {
    for (Iterator<Map.Entry<String,CacheStatus>> it=cachedArchives.entrySet().iterator(); it.hasNext(); ) {
      Map.Entry<String,CacheStatus> entry=it.next();
      String cacheId=entry.getKey();
      CacheStatus cacheStatus=cachedArchives.get(cacheId);
      CacheDir leftToClean=toBeCleanedBaseDir.get(cacheStatus.getBaseDir());
      if (leftToClean != null && (leftToClean.size > 0 || leftToClean.subdirs > 0)) {
        if (!cacheStatus.isUsed()) {
          leftToClean.size-=cacheStatus.size;
          leftToClean.subdirs--;
          toBeDeletedCache.add(cacheStatus);
          it.remove();
        }
      }
    }
  }
  for (  CacheStatus cacheStatus : toBeDeletedCache) {
synchronized (cacheStatus) {
      deleteLocalPath(asyncDiskService,FileSystem.getLocal(trackerConf),cacheStatus.getLocalizedUniqueDir());
      deleteCacheUpdate(cacheStatus);
    }
  }
}
