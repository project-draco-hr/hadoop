{
  long rmConnectWaitMS=conf.getInt(YarnConfiguration.RESOURCEMANAGER_CONNECT_MAX_WAIT_MS,YarnConfiguration.DEFAULT_RESOURCEMANAGER_CONNECT_MAX_WAIT_MS);
  long rmConnectionRetryIntervalMS=conf.getLong(YarnConfiguration.RESOURCEMANAGER_CONNECT_RETRY_INTERVAL_MS,YarnConfiguration.DEFAULT_RESOURCEMANAGER_CONNECT_RETRY_INTERVAL_MS);
  if (rmConnectionRetryIntervalMS < 0) {
    throw new YarnRuntimeException("Invalid Configuration. " + YarnConfiguration.RESOURCEMANAGER_CONNECT_RETRY_INTERVAL_MS + " should not be negative.");
  }
  boolean waitForEver=(rmConnectWaitMS == -1);
  if (waitForEver) {
    return RetryPolicies.RETRY_FOREVER;
  }
 else {
    if (rmConnectWaitMS < 0) {
      throw new YarnRuntimeException("Invalid Configuration. " + YarnConfiguration.RESOURCEMANAGER_CONNECT_MAX_WAIT_MS + " can be -1, but can not be other negative numbers");
    }
    if (rmConnectWaitMS < rmConnectionRetryIntervalMS) {
      LOG.warn(YarnConfiguration.RESOURCEMANAGER_CONNECT_MAX_WAIT_MS + " is smaller than " + YarnConfiguration.RESOURCEMANAGER_CONNECT_RETRY_INTERVAL_MS+ ". Only try connect once.");
      rmConnectWaitMS=0;
    }
  }
  RetryPolicy retryPolicy=RetryPolicies.retryUpToMaximumTimeWithFixedSleep(rmConnectWaitMS,rmConnectionRetryIntervalMS,TimeUnit.MILLISECONDS);
  Map<Class<? extends Exception>,RetryPolicy> exceptionToPolicyMap=new HashMap<Class<? extends Exception>,RetryPolicy>();
  exceptionToPolicyMap.put(ConnectException.class,retryPolicy);
  exceptionToPolicyMap.put(IOException.class,retryPolicy);
  return RetryPolicies.retryByException(RetryPolicies.TRY_ONCE_THEN_FAIL,exceptionToPolicyMap);
}
