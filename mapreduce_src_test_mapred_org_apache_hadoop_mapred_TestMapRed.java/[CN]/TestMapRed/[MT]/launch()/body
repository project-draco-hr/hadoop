{
  JobConf conf=null;
  if (getConf() == null) {
    conf=new JobConf();
  }
 else {
    conf=new JobConf(getConf());
  }
  conf.setJarByClass(TestMapRed.class);
  int countsToGo=counts;
  int dist[]=new int[range];
  for (int i=0; i < range; i++) {
    double avgInts=(1.0 * countsToGo) / (range - i);
    dist[i]=(int)Math.max(0,Math.round(avgInts + (Math.sqrt(avgInts) * r.nextGaussian())));
    countsToGo-=dist[i];
  }
  if (countsToGo > 0) {
    dist[dist.length - 1]+=countsToGo;
  }
  FileSystem fs=FileSystem.get(conf);
  Path testdir=new Path("mapred.loadtest");
  if (!fs.mkdirs(testdir)) {
    throw new IOException("Mkdirs failed to create " + testdir.toString());
  }
  Path randomIns=new Path(testdir,"genins");
  if (!fs.mkdirs(randomIns)) {
    throw new IOException("Mkdirs failed to create " + randomIns.toString());
  }
  Path answerkey=new Path(randomIns,"answer.key");
  SequenceFile.Writer out=SequenceFile.createWriter(fs,conf,answerkey,IntWritable.class,IntWritable.class,SequenceFile.CompressionType.NONE);
  try {
    for (int i=0; i < range; i++) {
      out.append(new IntWritable(i),new IntWritable(dist[i]));
    }
  }
  finally {
    out.close();
  }
  Path randomOuts=new Path(testdir,"genouts");
  fs.delete(randomOuts,true);
  JobConf genJob=new JobConf(conf,TestMapRed.class);
  FileInputFormat.setInputPaths(genJob,randomIns);
  genJob.setInputFormat(SequenceFileInputFormat.class);
  genJob.setMapperClass(RandomGenMapper.class);
  FileOutputFormat.setOutputPath(genJob,randomOuts);
  genJob.setOutputKeyClass(IntWritable.class);
  genJob.setOutputValueClass(IntWritable.class);
  genJob.setOutputFormat(TextOutputFormat.class);
  genJob.setReducerClass(RandomGenReducer.class);
  genJob.setNumReduceTasks(1);
  JobClient.runJob(genJob);
  int intermediateReduces=10;
  Path intermediateOuts=new Path(testdir,"intermediateouts");
  fs.delete(intermediateOuts,true);
  JobConf checkJob=new JobConf(conf,TestMapRed.class);
  FileInputFormat.setInputPaths(checkJob,randomOuts);
  checkJob.setInputFormat(TextInputFormat.class);
  checkJob.setMapperClass(RandomCheckMapper.class);
  FileOutputFormat.setOutputPath(checkJob,intermediateOuts);
  checkJob.setOutputKeyClass(IntWritable.class);
  checkJob.setOutputValueClass(IntWritable.class);
  checkJob.setOutputFormat(MapFileOutputFormat.class);
  checkJob.setReducerClass(RandomCheckReducer.class);
  checkJob.setNumReduceTasks(intermediateReduces);
  JobClient.runJob(checkJob);
  Path finalOuts=new Path(testdir,"finalouts");
  fs.delete(finalOuts,true);
  JobConf mergeJob=new JobConf(conf,TestMapRed.class);
  FileInputFormat.setInputPaths(mergeJob,intermediateOuts);
  mergeJob.setInputFormat(SequenceFileInputFormat.class);
  mergeJob.setMapperClass(MergeMapper.class);
  FileOutputFormat.setOutputPath(mergeJob,finalOuts);
  mergeJob.setOutputKeyClass(IntWritable.class);
  mergeJob.setOutputValueClass(IntWritable.class);
  mergeJob.setOutputFormat(SequenceFileOutputFormat.class);
  mergeJob.setReducerClass(MergeReducer.class);
  mergeJob.setNumReduceTasks(1);
  JobClient.runJob(mergeJob);
  boolean success=true;
  Path recomputedkey=new Path(finalOuts,"part-00000");
  SequenceFile.Reader in=new SequenceFile.Reader(fs,recomputedkey,conf);
  int totalseen=0;
  try {
    IntWritable key=new IntWritable();
    IntWritable val=new IntWritable();
    for (int i=0; i < range; i++) {
      if (dist[i] == 0) {
        continue;
      }
      if (!in.next(key,val)) {
        System.err.println("Cannot read entry " + i);
        success=false;
        break;
      }
 else {
        if (!((key.get() == i) && (val.get() == dist[i]))) {
          System.err.println("Mismatch!  Pos=" + key.get() + ", i="+ i+ ", val="+ val.get()+ ", dist[i]="+ dist[i]);
          success=false;
        }
        totalseen+=val.get();
      }
    }
    if (success) {
      if (in.next(key,val)) {
        System.err.println("Unnecessary lines in recomputed key!");
        success=false;
      }
    }
  }
  finally {
    in.close();
  }
  int originalTotal=0;
  for (int i=0; i < dist.length; i++) {
    originalTotal+=dist[i];
  }
  System.out.println("Original sum: " + originalTotal);
  System.out.println("Recomputed sum: " + totalseen);
  Path resultFile=new Path(testdir,"results");
  BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(fs.create(resultFile)));
  try {
    bw.write("Success=" + success + "\n");
    System.out.println("Success=" + success);
  }
  finally {
    bw.close();
  }
  assertTrue("testMapRed failed",success);
  fs.delete(testdir,true);
}
