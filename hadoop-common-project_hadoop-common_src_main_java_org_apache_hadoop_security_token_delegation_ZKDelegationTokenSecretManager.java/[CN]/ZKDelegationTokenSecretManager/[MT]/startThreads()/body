{
  if (!isExternalClient) {
    try {
      zkClient.start();
    }
 catch (    Exception e) {
      throw new IOException("Could not start Curator Framework",e);
    }
  }
 else {
    CuratorFramework nullNsFw=zkClient.usingNamespace(null);
    EnsurePath ensureNs=nullNsFw.newNamespaceAwareEnsurePath("/" + zkClient.getNamespace());
    try {
      ensureNs.ensure(nullNsFw.getZookeeperClient());
    }
 catch (    Exception e) {
      throw new IOException("Could not create namespace",e);
    }
  }
  listenerThreadPool=Executors.newSingleThreadExecutor();
  try {
    delTokSeqCounter=new SharedCount(zkClient,ZK_DTSM_SEQNUM_ROOT,0);
    if (delTokSeqCounter != null) {
      delTokSeqCounter.start();
    }
  }
 catch (  Exception e) {
    throw new IOException("Could not start Sequence Counter",e);
  }
  try {
    keyIdSeqCounter=new SharedCount(zkClient,ZK_DTSM_KEYID_ROOT,0);
    if (keyIdSeqCounter != null) {
      keyIdSeqCounter.start();
    }
  }
 catch (  Exception e) {
    throw new IOException("Could not start KeyId Counter",e);
  }
  try {
    createPersistentNode(ZK_DTSM_MASTER_KEY_ROOT);
    createPersistentNode(ZK_DTSM_TOKENS_ROOT);
  }
 catch (  Exception e) {
    throw new RuntimeException("Could not create ZK paths");
  }
  try {
    keyCache=new PathChildrenCache(zkClient,ZK_DTSM_MASTER_KEY_ROOT,true);
    if (keyCache != null) {
      keyCache.start(StartMode.BUILD_INITIAL_CACHE);
      keyCache.getListenable().addListener(new PathChildrenCacheListener(){
        @Override public void childEvent(        CuratorFramework client,        PathChildrenCacheEvent event) throws Exception {
switch (event.getType()) {
case CHILD_ADDED:
            processKeyAddOrUpdate(event.getData().getData());
          break;
case CHILD_UPDATED:
        processKeyAddOrUpdate(event.getData().getData());
      break;
case CHILD_REMOVED:
    processKeyRemoved(event.getData().getPath());
  break;
default :
break;
}
}
}
,listenerThreadPool);
loadFromZKCache(false);
}
}
 catch (Exception e) {
throw new IOException("Could not start PathChildrenCache for keys",e);
}
try {
tokenCache=new PathChildrenCache(zkClient,ZK_DTSM_TOKENS_ROOT,true);
if (tokenCache != null) {
tokenCache.start(StartMode.BUILD_INITIAL_CACHE);
tokenCache.getListenable().addListener(new PathChildrenCacheListener(){
@Override public void childEvent(CuratorFramework client,PathChildrenCacheEvent event) throws Exception {
switch (event.getType()) {
case CHILD_ADDED:
processTokenAddOrUpdate(event.getData());
break;
case CHILD_UPDATED:
processTokenAddOrUpdate(event.getData());
break;
case CHILD_REMOVED:
processTokenRemoved(event.getData());
break;
default :
break;
}
}
}
,listenerThreadPool);
loadFromZKCache(true);
}
}
 catch (Exception e) {
throw new IOException("Could not start PathChildrenCache for tokens",e);
}
super.startThreads();
}
