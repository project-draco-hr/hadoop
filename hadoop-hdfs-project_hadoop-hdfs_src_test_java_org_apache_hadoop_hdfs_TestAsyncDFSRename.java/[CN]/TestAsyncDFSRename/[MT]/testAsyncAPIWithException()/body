{
  Configuration conf=new HdfsConfiguration();
  String group1="group1";
  String group2="group2";
  String user1="user1";
  UserGroupInformation ugi1;
  conf.setBoolean(DFSConfigKeys.DFS_PERMISSIONS_ENABLED_KEY,true);
  Map<String,String[]> u2gMap=new HashMap<String,String[]>(1);
  u2gMap.put(user1,new String[]{group1,group2});
  DFSTestUtil.updateConfWithFakeGroupMapping(conf,u2gMap);
  ugi1=UserGroupInformation.createUserForTesting(user1,new String[]{group1,group2});
  final MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(3).build();
  cluster.waitActive();
  FileSystem rootFs=FileSystem.get(conf);
  final Path renameDir=new Path("/test/async_api_exception/");
  final Path src=new Path(renameDir,"src");
  final Path dst=new Path(renameDir,"dst");
  rootFs.mkdirs(src);
  AsyncDistributedFileSystem adfs=ugi1.doAs(new PrivilegedExceptionAction<AsyncDistributedFileSystem>(){
    @Override public AsyncDistributedFileSystem run() throws Exception {
      return cluster.getFileSystem().getAsyncDistributedFileSystem();
    }
  }
);
  Future<Void> retFuture;
  try {
    retFuture=adfs.rename(src,dst,Rename.OVERWRITE);
    retFuture.get();
  }
 catch (  ExecutionException e) {
    TestAsyncDFS.checkPermissionDenied(e,src,user1);
    assertTrue("Permission denied messages must carry the path parent",e.getMessage().contains(src.getParent().toUri().getPath()));
  }
  FsPermission fsPerm=new FsPermission(permGenerator.next());
  try {
    retFuture=adfs.setPermission(src,fsPerm);
    retFuture.get();
  }
 catch (  ExecutionException e) {
    TestAsyncDFS.checkPermissionDenied(e,src,user1);
    assertTrue("Permission denied messages must carry the name of the path",e.getMessage().contains(src.getName()));
  }
  try {
    retFuture=adfs.setOwner(src,"user1","group2");
    retFuture.get();
  }
 catch (  ExecutionException e) {
    TestAsyncDFS.checkPermissionDenied(e,src,user1);
    assertTrue("Permission denied messages must carry the name of the path",e.getMessage().contains(src.getName()));
  }
 finally {
    if (rootFs != null) {
      rootFs.close();
    }
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}
