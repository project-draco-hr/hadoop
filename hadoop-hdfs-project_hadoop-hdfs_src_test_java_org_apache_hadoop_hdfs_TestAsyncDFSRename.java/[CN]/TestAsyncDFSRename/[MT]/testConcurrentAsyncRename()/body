{
  final Path parent=new Path(String.format("/test/%s/","testConcurrentAsyncRename"));
  assertTrue(fs.mkdirs(parent));
  final Path[] srcs=new Path[NUM_TESTS];
  final Path[] dsts=new Path[NUM_TESTS];
  for (int i=0; i < NUM_TESTS; i++) {
    srcs[i]=new Path(parent,"src" + i);
    dsts[i]=new Path(parent,"dst" + i);
    DFSTestUtil.createFile(fs,srcs[i],fileLen,replFactor,1);
    DFSTestUtil.createFile(fs,dsts[i],fileLen,replFactor,1);
  }
  int start=0, end=0;
  Map<Integer,Future<Void>> retFutures=new HashMap<Integer,Future<Void>>();
  for (int i=0; i < NUM_TESTS; i++) {
    for (; ; ) {
      try {
        LOG.info("rename #" + i);
        Future<Void> retFuture=adfs.rename(srcs[i],dsts[i],Rename.OVERWRITE);
        retFutures.put(i,retFuture);
        break;
      }
 catch (      AsyncCallLimitExceededException e) {
        LOG.error(e);
        start=end;
        end=i;
        LOG.info(String.format("start=%d, end=%d, i=%d",start,end,i));
        waitForReturnValues(retFutures,start,end);
      }
    }
  }
  waitForReturnValues(retFutures,end,NUM_TESTS);
  verifyRenames(srcs,dsts);
}
