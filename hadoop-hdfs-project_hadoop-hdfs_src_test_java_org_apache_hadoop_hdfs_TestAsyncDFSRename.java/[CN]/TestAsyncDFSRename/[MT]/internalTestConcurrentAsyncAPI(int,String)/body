{
  Configuration conf=new HdfsConfiguration();
  String group1="group1";
  String group2="group2";
  String user1="user1";
  int count=500;
  conf.setBoolean(DFSConfigKeys.DFS_PERMISSIONS_ENABLED_KEY,true);
  conf.setInt(CommonConfigurationKeys.IPC_CLIENT_ASYNC_CALLS_MAX_KEY,asyncCallLimit);
  Map<String,String[]> u2gMap=new HashMap<String,String[]>(1);
  u2gMap.put(user1,new String[]{group1,group2});
  DFSTestUtil.updateConfWithFakeGroupMapping(conf,u2gMap);
  final MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(3).build();
  cluster.waitActive();
  AsyncDistributedFileSystem adfs=cluster.getFileSystem().getAsyncDistributedFileSystem();
  FileSystem rootFs=FileSystem.get(conf);
  final Path parent=new Path(String.format("/test/%s/",basePath));
  final Path[] srcs=new Path[count];
  final Path[] dsts=new Path[count];
  short[] permissions=new short[count];
  for (int i=0; i < count; i++) {
    srcs[i]=new Path(parent,"src" + i);
    dsts[i]=new Path(parent,"dst" + i);
    DFSTestUtil.createFile(rootFs,srcs[i],fileLen,replFactor,1);
    DFSTestUtil.createFile(rootFs,dsts[i],fileLen,replFactor,1);
    assertTrue(rootFs.exists(srcs[i]));
    assertTrue(rootFs.getFileStatus(srcs[i]).isFile());
    assertTrue(rootFs.exists(dsts[i]));
    assertTrue(rootFs.getFileStatus(dsts[i]).isFile());
    permissions[i]=permGenerator.next();
  }
  Map<Integer,Future<Void>> renameRetFutures=new HashMap<Integer,Future<Void>>();
  Map<Integer,Future<Void>> permRetFutures=new HashMap<Integer,Future<Void>>();
  Map<Integer,Future<Void>> ownerRetFutures=new HashMap<Integer,Future<Void>>();
  int start=0, end=0;
  for (int i=0; i < count; i++) {
    for (; ; ) {
      try {
        Future<Void> returnFuture=adfs.rename(srcs[i],dsts[i],Rename.OVERWRITE);
        renameRetFutures.put(i,returnFuture);
        break;
      }
 catch (      AsyncCallLimitExceededException e) {
        start=end;
        end=i;
        waitForReturnValues(renameRetFutures,start,end);
      }
    }
  }
  for (int i=start; i < count; i++) {
    renameRetFutures.get(i).get();
  }
  cluster.restartNameNodes();
  for (int i=0; i < count; i++) {
    assertFalse(rootFs.exists(srcs[i]));
    assertTrue(rootFs.exists(dsts[i]));
  }
  try {
    for (int i=0; i < count; i++) {
      for (; ; ) {
        try {
          Future<Void> retFuture=adfs.setPermission(dsts[i],new FsPermission(permissions[i]));
          permRetFutures.put(i,retFuture);
          break;
        }
 catch (        AsyncCallLimitExceededException e) {
          start=end;
          end=i;
          waitForReturnValues(permRetFutures,start,end);
        }
      }
    }
    for (int i=start; i < count; i++) {
      permRetFutures.get(i).get();
    }
    cluster.restartNameNodes();
    for (int i=0; i < count; i++) {
      assertTrue(rootFs.exists(dsts[i]));
      FsPermission fsPerm=new FsPermission(permissions[i]);
      checkAccessPermissions(rootFs.getFileStatus(dsts[i]),fsPerm.getUserAction());
    }
    start=0;
    end=0;
    for (int i=0; i < count; i++) {
      for (; ; ) {
        try {
          Future<Void> retFuture=adfs.setOwner(dsts[i],"user1","group2");
          ownerRetFutures.put(i,retFuture);
          break;
        }
 catch (        AsyncCallLimitExceededException e) {
          start=end;
          end=i;
          waitForReturnValues(ownerRetFutures,start,end);
        }
      }
    }
    for (int i=start; i < count; i++) {
      ownerRetFutures.get(i).get();
    }
    cluster.restartNameNodes();
    for (int i=0; i < count; i++) {
      assertTrue(rootFs.exists(dsts[i]));
      assertTrue("user1".equals(rootFs.getFileStatus(dsts[i]).getOwner()));
      assertTrue("group2".equals(rootFs.getFileStatus(dsts[i]).getGroup()));
    }
  }
 catch (  AccessControlException ace) {
    throw ace;
  }
 finally {
    if (rootFs != null) {
      rootFs.close();
    }
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}
