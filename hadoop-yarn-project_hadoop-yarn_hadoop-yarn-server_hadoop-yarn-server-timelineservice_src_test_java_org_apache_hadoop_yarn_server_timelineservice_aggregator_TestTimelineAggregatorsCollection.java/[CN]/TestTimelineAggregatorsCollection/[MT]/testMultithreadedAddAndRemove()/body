{
  final TimelineAggregatorsCollection aggregatorCollection=spy(new TimelineAggregatorsCollection());
  doReturn(new Configuration()).when(aggregatorCollection).getConfig();
  final int NUM_APPS=5;
  List<Callable<Boolean>> tasks=new ArrayList<Callable<Boolean>>();
  for (int i=0; i < NUM_APPS; i++) {
    final ApplicationId appId=ApplicationId.newInstance(0L,i);
    Callable<Boolean> task=new Callable<Boolean>(){
      public Boolean call(){
        AppLevelTimelineAggregator aggregator=new AppLevelTimelineAggregator(appId.toString());
        boolean successPut=(aggregatorCollection.putIfAbsent(appId,aggregator) == aggregator);
        return successPut && aggregatorCollection.remove(appId.toString());
      }
    }
;
    tasks.add(task);
  }
  ExecutorService executor=Executors.newFixedThreadPool(NUM_APPS);
  try {
    List<Future<Boolean>> futures=executor.invokeAll(tasks);
    for (    Future<Boolean> future : futures) {
      assertTrue(future.get());
    }
  }
  finally {
    executor.shutdownNow();
  }
  for (int i=0; i < NUM_APPS; i++) {
    assertFalse(aggregatorCollection.containsKey(String.valueOf(i)));
  }
}
