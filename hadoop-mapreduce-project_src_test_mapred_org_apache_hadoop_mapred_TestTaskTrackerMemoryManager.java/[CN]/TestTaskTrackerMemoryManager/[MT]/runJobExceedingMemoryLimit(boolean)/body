{
  long PER_TASK_LIMIT=1L;
  Pattern taskOverLimitPattern=Pattern.compile(String.format(taskOverLimitPatternString,String.valueOf(PER_TASK_LIMIT * 1024 * 1024L)));
  Matcher mat=null;
  JobConf conf=new JobConf(miniMRCluster.createJobConf());
  if (doPhysicalMemory) {
    conf.setLong(MRJobConfig.MAP_MEMORY_PHYSICAL_MB,PER_TASK_LIMIT);
    conf.setLong(MRJobConfig.REDUCE_MEMORY_PHYSICAL_MB,PER_TASK_LIMIT);
  }
 else {
    conf.setMemoryForMapTask(PER_TASK_LIMIT);
    conf.setMemoryForReduceTask(PER_TASK_LIMIT);
  }
  conf.setMaxMapAttempts(1);
  conf.setMaxReduceAttempts(1);
  int ret=0;
  try {
    ret=runSleepJob(conf);
  }
 catch (  Exception e) {
    ret=1;
  }
  assertTrue(ret != 0);
  JobClient jClient=new JobClient(conf);
  JobStatus[] jStatus=jClient.getAllJobs();
  JobStatus js=jStatus[0];
  RunningJob rj=jClient.getJob(js.getJobID());
  TaskCompletionEvent[] taskComplEvents=rj.getTaskCompletionEvents(0);
  for (  TaskCompletionEvent tce : taskComplEvents) {
    assertTrue("Failure expected, task: " + tce.getTaskStatus(),tce.getTaskStatus() == TaskCompletionEvent.Status.TIPFAILED || tce.getTaskStatus() == TaskCompletionEvent.Status.FAILED);
    String[] diagnostics=rj.getTaskDiagnostics(tce.getTaskAttemptId());
    assertNotNull(diagnostics);
    for (    String str : diagnostics) {
      mat=taskOverLimitPattern.matcher(str);
      assertTrue(mat.find());
    }
  }
}
