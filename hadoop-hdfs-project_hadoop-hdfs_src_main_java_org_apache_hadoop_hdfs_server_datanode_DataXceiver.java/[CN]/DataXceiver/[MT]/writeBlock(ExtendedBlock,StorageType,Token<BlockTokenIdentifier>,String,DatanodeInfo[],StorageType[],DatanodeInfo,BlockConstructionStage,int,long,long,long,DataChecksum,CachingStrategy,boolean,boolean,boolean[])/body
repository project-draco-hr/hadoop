{
  previousOpClientName=clientname;
  updateCurrentThreadName("Receiving block " + block);
  final boolean isDatanode=clientname.length() == 0;
  final boolean isClient=!isDatanode;
  final boolean isTransfer=stage == BlockConstructionStage.TRANSFER_RBW || stage == BlockConstructionStage.TRANSFER_FINALIZED;
  allowLazyPersist=allowLazyPersist && (dnConf.getAllowNonLocalLazyPersist() || peer.isLocal());
  long size=0;
  final DataOutputStream replyOut=getBufferedOutputStream();
  checkAccess(replyOut,isClient,block,blockToken,Op.WRITE_BLOCK,BlockTokenIdentifier.AccessMode.WRITE);
  if (isTransfer && targets.length > 0) {
    throw new IOException(stage + " does not support multiple targets " + Arrays.asList(targets));
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("opWriteBlock: stage=" + stage + ", clientname="+ clientname+ "\n  block  ="+ block+ ", newGs="+ latestGenerationStamp+ ", bytesRcvd=["+ minBytesRcvd+ ", "+ maxBytesRcvd+ "]"+ "\n  targets="+ Arrays.asList(targets)+ "; pipelineSize="+ pipelineSize+ ", srcDataNode="+ srcDataNode+ ", pinning="+ pinning);
    LOG.debug("isDatanode=" + isDatanode + ", isClient="+ isClient+ ", isTransfer="+ isTransfer);
    LOG.debug("writeBlock receive buf size " + peer.getReceiveBufferSize() + " tcp no delay "+ peer.getTcpNoDelay());
  }
  final ExtendedBlock originalBlock=new ExtendedBlock(block);
  if (block.getNumBytes() == 0) {
    block.setNumBytes(dataXceiverServer.estimateBlockSize);
  }
  LOG.info("Receiving " + block + " src: "+ remoteAddress+ " dest: "+ localAddress);
  DataOutputStream mirrorOut=null;
  DataInputStream mirrorIn=null;
  Socket mirrorSock=null;
  String mirrorNode=null;
  String firstBadLink="";
  Status mirrorInStatus=SUCCESS;
  final String storageUuid;
  final boolean isOnTransientStorage;
  try {
    final Replica replica;
    if (isDatanode || stage != BlockConstructionStage.PIPELINE_CLOSE_RECOVERY) {
      setCurrentBlockReceiver(getBlockReceiver(block,storageType,in,peer.getRemoteAddressString(),peer.getLocalAddressString(),stage,latestGenerationStamp,minBytesRcvd,maxBytesRcvd,clientname,srcDataNode,datanode,requestedChecksum,cachingStrategy,allowLazyPersist,pinning));
      replica=blockReceiver.getReplica();
    }
 else {
      replica=datanode.data.recoverClose(block,latestGenerationStamp,minBytesRcvd);
    }
    storageUuid=replica.getStorageUuid();
    isOnTransientStorage=replica.isOnTransientStorage();
    if (targets.length > 0) {
      InetSocketAddress mirrorTarget=null;
      mirrorNode=targets[0].getXferAddr(connectToDnViaHostname);
      if (LOG.isDebugEnabled()) {
        LOG.debug("Connecting to datanode " + mirrorNode);
      }
      mirrorTarget=NetUtils.createSocketAddr(mirrorNode);
      mirrorSock=datanode.newSocket();
      try {
        DataNodeFaultInjector.get().failMirrorConnection();
        int timeoutValue=dnConf.socketTimeout + (HdfsConstants.READ_TIMEOUT_EXTENSION * targets.length);
        int writeTimeout=dnConf.socketWriteTimeout + (HdfsConstants.WRITE_TIMEOUT_EXTENSION * targets.length);
        NetUtils.connect(mirrorSock,mirrorTarget,timeoutValue);
        mirrorSock.setSoTimeout(timeoutValue);
        mirrorSock.setKeepAlive(true);
        if (dnConf.getTransferSocketSendBufferSize() > 0) {
          mirrorSock.setSendBufferSize(dnConf.getTransferSocketSendBufferSize());
        }
        OutputStream unbufMirrorOut=NetUtils.getOutputStream(mirrorSock,writeTimeout);
        InputStream unbufMirrorIn=NetUtils.getInputStream(mirrorSock);
        DataEncryptionKeyFactory keyFactory=datanode.getDataEncryptionKeyFactoryForBlock(block);
        IOStreamPair saslStreams=datanode.saslClient.socketSend(mirrorSock,unbufMirrorOut,unbufMirrorIn,keyFactory,blockToken,targets[0]);
        unbufMirrorOut=saslStreams.out;
        unbufMirrorIn=saslStreams.in;
        mirrorOut=new DataOutputStream(new BufferedOutputStream(unbufMirrorOut,smallBufferSize));
        mirrorIn=new DataInputStream(unbufMirrorIn);
        if (targetPinnings != null && targetPinnings.length > 0) {
          new Sender(mirrorOut).writeBlock(originalBlock,targetStorageTypes[0],blockToken,clientname,targets,targetStorageTypes,srcDataNode,stage,pipelineSize,minBytesRcvd,maxBytesRcvd,latestGenerationStamp,requestedChecksum,cachingStrategy,allowLazyPersist,targetPinnings[0],targetPinnings);
        }
 else {
          new Sender(mirrorOut).writeBlock(originalBlock,targetStorageTypes[0],blockToken,clientname,targets,targetStorageTypes,srcDataNode,stage,pipelineSize,minBytesRcvd,maxBytesRcvd,latestGenerationStamp,requestedChecksum,cachingStrategy,allowLazyPersist,false,targetPinnings);
        }
        mirrorOut.flush();
        DataNodeFaultInjector.get().writeBlockAfterFlush();
        if (isClient) {
          BlockOpResponseProto connectAck=BlockOpResponseProto.parseFrom(PBHelperClient.vintPrefixed(mirrorIn));
          mirrorInStatus=connectAck.getStatus();
          firstBadLink=connectAck.getFirstBadLink();
          if (LOG.isDebugEnabled() || mirrorInStatus != SUCCESS) {
            LOG.debug("Datanode " + targets.length + " got response for connect ack "+ " from downstream datanode with firstbadlink as "+ firstBadLink);
          }
        }
      }
 catch (      IOException e) {
        if (isClient) {
          BlockOpResponseProto.newBuilder().setStatus(ERROR).setFirstBadLink(targets[0].getXferAddr()).build().writeDelimitedTo(replyOut);
          replyOut.flush();
        }
        IOUtils.closeStream(mirrorOut);
        mirrorOut=null;
        IOUtils.closeStream(mirrorIn);
        mirrorIn=null;
        IOUtils.closeSocket(mirrorSock);
        mirrorSock=null;
        if (isClient) {
          LOG.error(datanode + ":Exception transfering block " + block+ " to mirror "+ mirrorNode+ ": "+ e);
          throw e;
        }
 else {
          LOG.info(datanode + ":Exception transfering " + block+ " to mirror "+ mirrorNode+ "- continuing without the mirror",e);
          incrDatanodeNetworkErrors();
        }
      }
    }
    if (isClient && !isTransfer) {
      if (LOG.isDebugEnabled() || mirrorInStatus != SUCCESS) {
        LOG.debug("Datanode " + targets.length + " forwarding connect ack to upstream firstbadlink is "+ firstBadLink);
      }
      BlockOpResponseProto.newBuilder().setStatus(mirrorInStatus).setFirstBadLink(firstBadLink).build().writeDelimitedTo(replyOut);
      replyOut.flush();
    }
    if (blockReceiver != null) {
      String mirrorAddr=(mirrorSock == null) ? null : mirrorNode;
      blockReceiver.receiveBlock(mirrorOut,mirrorIn,replyOut,mirrorAddr,null,targets,false);
      if (isTransfer) {
        if (LOG.isTraceEnabled()) {
          LOG.trace("TRANSFER: send close-ack");
        }
        writeResponse(SUCCESS,null,replyOut);
      }
    }
    if (isClient && stage == BlockConstructionStage.PIPELINE_CLOSE_RECOVERY) {
      block.setGenerationStamp(latestGenerationStamp);
      block.setNumBytes(minBytesRcvd);
    }
    if (isDatanode || stage == BlockConstructionStage.PIPELINE_CLOSE_RECOVERY) {
      datanode.closeBlock(block,null,storageUuid,isOnTransientStorage);
      LOG.info("Received " + block + " src: "+ remoteAddress+ " dest: "+ localAddress+ " of size "+ block.getNumBytes());
    }
    if (isClient) {
      size=block.getNumBytes();
    }
  }
 catch (  IOException ioe) {
    LOG.info("opWriteBlock " + block + " received exception "+ ioe);
    incrDatanodeNetworkErrors();
    throw ioe;
  }
 finally {
    IOUtils.closeStream(mirrorOut);
    IOUtils.closeStream(mirrorIn);
    IOUtils.closeStream(replyOut);
    IOUtils.closeSocket(mirrorSock);
    IOUtils.closeStream(blockReceiver);
    setCurrentBlockReceiver(null);
  }
  datanode.getMetrics().addWriteBlockOp(elapsed());
  datanode.getMetrics().incrWritesFromClient(peer.isLocal(),size);
}
