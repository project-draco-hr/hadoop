{
  updateCurrentThreadName("Replacing block " + block + " from "+ delHint);
  block.setNumBytes(dataXceiverServer.estimateBlockSize);
  if (datanode.isBlockTokenEnabled) {
    try {
      datanode.blockPoolTokenSecretManager.checkAccess(blockToken,null,block,BlockTokenSecretManager.AccessMode.REPLACE);
    }
 catch (    InvalidToken e) {
      LOG.warn("Invalid access token in request from " + remoteAddress + " for OP_REPLACE_BLOCK for block "+ block+ " : "+ e.getLocalizedMessage());
      sendResponse(s,ERROR_ACCESS_TOKEN,"Invalid access token",dnConf.socketWriteTimeout);
      return;
    }
  }
  if (!dataXceiverServer.balanceThrottler.acquire()) {
    String msg="Not able to receive block " + block.getBlockId() + " from "+ s.getRemoteSocketAddress()+ " because threads quota is exceeded.";
    LOG.warn(msg);
    sendResponse(s,ERROR,msg,dnConf.socketWriteTimeout);
    return;
  }
  Socket proxySock=null;
  DataOutputStream proxyOut=null;
  Status opStatus=SUCCESS;
  String errMsg=null;
  BlockReceiver blockReceiver=null;
  DataInputStream proxyReply=null;
  try {
    InetSocketAddress proxyAddr=NetUtils.createSocketAddr(proxySource.getXferAddr());
    proxySock=datanode.newSocket();
    NetUtils.connect(proxySock,proxyAddr,dnConf.socketTimeout);
    proxySock.setSoTimeout(dnConf.socketTimeout);
    OutputStream baseStream=NetUtils.getOutputStream(proxySock,dnConf.socketWriteTimeout);
    proxyOut=new DataOutputStream(new BufferedOutputStream(baseStream,HdfsConstants.SMALL_BUFFER_SIZE));
    new Sender(proxyOut).copyBlock(block,blockToken);
    proxyReply=new DataInputStream(new BufferedInputStream(NetUtils.getInputStream(proxySock),HdfsConstants.IO_FILE_BUFFER_SIZE));
    BlockOpResponseProto copyResponse=BlockOpResponseProto.parseFrom(HdfsProtoUtil.vintPrefixed(proxyReply));
    if (copyResponse.getStatus() != SUCCESS) {
      if (copyResponse.getStatus() == ERROR_ACCESS_TOKEN) {
        throw new IOException("Copy block " + block + " from "+ proxySock.getRemoteSocketAddress()+ " failed due to access token error");
      }
      throw new IOException("Copy block " + block + " from "+ proxySock.getRemoteSocketAddress()+ " failed");
    }
    ReadOpChecksumInfoProto checksumInfo=copyResponse.getReadOpChecksumInfo();
    DataChecksum remoteChecksum=DataTransferProtoUtil.fromProto(checksumInfo.getChecksum());
    blockReceiver=new BlockReceiver(block,proxyReply,proxySock.getRemoteSocketAddress().toString(),proxySock.getLocalSocketAddress().toString(),null,0,0,0,"",null,datanode,remoteChecksum);
    blockReceiver.receiveBlock(null,null,null,null,dataXceiverServer.balanceThrottler,null);
    datanode.notifyNamenodeReceivedBlock(block,delHint);
    LOG.info("Moved block " + block + " from "+ s.getRemoteSocketAddress());
  }
 catch (  IOException ioe) {
    opStatus=ERROR;
    errMsg="opReplaceBlock " + block + " received exception "+ ioe;
    LOG.info(errMsg);
    throw ioe;
  }
 finally {
    if (opStatus == SUCCESS) {
      try {
        proxyReply.readChar();
      }
 catch (      IOException ignored) {
      }
    }
    dataXceiverServer.balanceThrottler.release();
    try {
      sendResponse(s,opStatus,errMsg,dnConf.socketWriteTimeout);
    }
 catch (    IOException ioe) {
      LOG.warn("Error writing reply back to " + s.getRemoteSocketAddress());
    }
    IOUtils.closeStream(proxyOut);
    IOUtils.closeStream(blockReceiver);
    IOUtils.closeStream(proxyReply);
  }
  datanode.metrics.addReplaceBlockOp(elapsed());
}
