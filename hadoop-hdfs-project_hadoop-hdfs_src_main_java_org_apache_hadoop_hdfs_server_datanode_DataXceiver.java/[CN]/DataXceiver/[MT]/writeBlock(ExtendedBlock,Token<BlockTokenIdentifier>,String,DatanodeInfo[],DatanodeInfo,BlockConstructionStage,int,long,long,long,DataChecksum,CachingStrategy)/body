{
  previousOpClientName=clientname;
  updateCurrentThreadName("Receiving block " + block);
  final boolean isDatanode=clientname.length() == 0;
  final boolean isClient=!isDatanode;
  final boolean isTransfer=stage == BlockConstructionStage.TRANSFER_RBW || stage == BlockConstructionStage.TRANSFER_FINALIZED;
  if (isTransfer && targets.length > 0) {
    throw new IOException(stage + " does not support multiple targets " + Arrays.asList(targets));
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("opWriteBlock: stage=" + stage + ", clientname="+ clientname+ "\n  block  ="+ block+ ", newGs="+ latestGenerationStamp+ ", bytesRcvd=["+ minBytesRcvd+ ", "+ maxBytesRcvd+ "]"+ "\n  targets="+ Arrays.asList(targets)+ "; pipelineSize="+ pipelineSize+ ", srcDataNode="+ srcDataNode);
    LOG.debug("isDatanode=" + isDatanode + ", isClient="+ isClient+ ", isTransfer="+ isTransfer);
    LOG.debug("writeBlock receive buf size " + peer.getReceiveBufferSize() + " tcp no delay "+ peer.getTcpNoDelay());
  }
  final ExtendedBlock originalBlock=new ExtendedBlock(block);
  block.setNumBytes(dataXceiverServer.estimateBlockSize);
  LOG.info("Receiving " + block + " src: "+ remoteAddress+ " dest: "+ localAddress);
  final DataOutputStream replyOut=new DataOutputStream(new BufferedOutputStream(getOutputStream(),HdfsConstants.SMALL_BUFFER_SIZE));
  checkAccess(replyOut,isClient,block,blockToken,Op.WRITE_BLOCK,BlockTokenSecretManager.AccessMode.WRITE);
  DataOutputStream mirrorOut=null;
  DataInputStream mirrorIn=null;
  Socket mirrorSock=null;
  BlockReceiver blockReceiver=null;
  String mirrorNode=null;
  String firstBadLink="";
  Status mirrorInStatus=SUCCESS;
  Replica replica;
  try {
    if (isDatanode || stage != BlockConstructionStage.PIPELINE_CLOSE_RECOVERY) {
      blockReceiver=new BlockReceiver(block,in,peer.getRemoteAddressString(),peer.getLocalAddressString(),stage,latestGenerationStamp,minBytesRcvd,maxBytesRcvd,clientname,srcDataNode,datanode,requestedChecksum,cachingStrategy);
      replica=blockReceiver.getReplicaInfo();
    }
 else {
      replica=datanode.data.recoverClose(block,latestGenerationStamp,minBytesRcvd);
    }
    if (targets.length > 0) {
      InetSocketAddress mirrorTarget=null;
      mirrorNode=targets[0].getXferAddr(connectToDnViaHostname);
      if (LOG.isDebugEnabled()) {
        LOG.debug("Connecting to datanode " + mirrorNode);
      }
      mirrorTarget=NetUtils.createSocketAddr(mirrorNode);
      mirrorSock=datanode.newSocket();
      try {
        int timeoutValue=dnConf.socketTimeout + (HdfsServerConstants.READ_TIMEOUT_EXTENSION * targets.length);
        int writeTimeout=dnConf.socketWriteTimeout + (HdfsServerConstants.WRITE_TIMEOUT_EXTENSION * targets.length);
        NetUtils.connect(mirrorSock,mirrorTarget,timeoutValue);
        mirrorSock.setSoTimeout(timeoutValue);
        mirrorSock.setSendBufferSize(HdfsConstants.DEFAULT_DATA_SOCKET_SIZE);
        OutputStream unbufMirrorOut=NetUtils.getOutputStream(mirrorSock,writeTimeout);
        InputStream unbufMirrorIn=NetUtils.getInputStream(mirrorSock);
        if (dnConf.encryptDataTransfer) {
          IOStreamPair encryptedStreams=DataTransferEncryptor.getEncryptedStreams(unbufMirrorOut,unbufMirrorIn,datanode.blockPoolTokenSecretManager.generateDataEncryptionKey(block.getBlockPoolId()));
          unbufMirrorOut=encryptedStreams.out;
          unbufMirrorIn=encryptedStreams.in;
        }
        mirrorOut=new DataOutputStream(new BufferedOutputStream(unbufMirrorOut,HdfsConstants.SMALL_BUFFER_SIZE));
        mirrorIn=new DataInputStream(unbufMirrorIn);
        new Sender(mirrorOut).writeBlock(originalBlock,blockToken,clientname,targets,srcDataNode,stage,pipelineSize,minBytesRcvd,maxBytesRcvd,latestGenerationStamp,requestedChecksum,cachingStrategy);
        mirrorOut.flush();
        if (isClient) {
          BlockOpResponseProto connectAck=BlockOpResponseProto.parseFrom(PBHelper.vintPrefixed(mirrorIn));
          mirrorInStatus=connectAck.getStatus();
          firstBadLink=connectAck.getFirstBadLink();
          if (LOG.isDebugEnabled() || mirrorInStatus != SUCCESS) {
            LOG.info("Datanode " + targets.length + " got response for connect ack "+ " from downstream datanode with firstbadlink as "+ firstBadLink);
          }
        }
      }
 catch (      IOException e) {
        if (isClient) {
          BlockOpResponseProto.newBuilder().setStatus(ERROR).setFirstBadLink(targets[0].getXferAddr()).build().writeDelimitedTo(replyOut);
          replyOut.flush();
        }
        IOUtils.closeStream(mirrorOut);
        mirrorOut=null;
        IOUtils.closeStream(mirrorIn);
        mirrorIn=null;
        IOUtils.closeSocket(mirrorSock);
        mirrorSock=null;
        if (isClient) {
          LOG.error(datanode + ":Exception transfering block " + block+ " to mirror "+ mirrorNode+ ": "+ e);
          throw e;
        }
 else {
          LOG.info(datanode + ":Exception transfering " + block+ " to mirror "+ mirrorNode+ "- continuing without the mirror",e);
        }
      }
    }
    if (isClient && !isTransfer) {
      if (LOG.isDebugEnabled() || mirrorInStatus != SUCCESS) {
        LOG.info("Datanode " + targets.length + " forwarding connect ack to upstream firstbadlink is "+ firstBadLink);
      }
      BlockOpResponseProto.newBuilder().setStatus(mirrorInStatus).setFirstBadLink(firstBadLink).build().writeDelimitedTo(replyOut);
      replyOut.flush();
    }
    if (blockReceiver != null) {
      String mirrorAddr=(mirrorSock == null) ? null : mirrorNode;
      blockReceiver.receiveBlock(mirrorOut,mirrorIn,replyOut,mirrorAddr,null,targets);
      if (isTransfer) {
        if (LOG.isTraceEnabled()) {
          LOG.trace("TRANSFER: send close-ack");
        }
        writeResponse(SUCCESS,null,replyOut);
      }
    }
    if (isClient && stage == BlockConstructionStage.PIPELINE_CLOSE_RECOVERY) {
      block.setGenerationStamp(latestGenerationStamp);
      block.setNumBytes(minBytesRcvd);
    }
    if (isDatanode || stage == BlockConstructionStage.PIPELINE_CLOSE_RECOVERY) {
      datanode.closeBlock(block,DataNode.EMPTY_DEL_HINT,replica.getStorageUuid());
      LOG.info("Received " + block + " src: "+ remoteAddress+ " dest: "+ localAddress+ " of size "+ block.getNumBytes());
    }
  }
 catch (  IOException ioe) {
    LOG.info("opWriteBlock " + block + " received exception "+ ioe);
    throw ioe;
  }
 finally {
    IOUtils.closeStream(mirrorOut);
    IOUtils.closeStream(mirrorIn);
    IOUtils.closeStream(replyOut);
    IOUtils.closeSocket(mirrorSock);
    IOUtils.closeStream(blockReceiver);
  }
  datanode.metrics.addWriteBlockOp(elapsed());
  datanode.metrics.incrWritesFromClient(peer.isLocal());
}
