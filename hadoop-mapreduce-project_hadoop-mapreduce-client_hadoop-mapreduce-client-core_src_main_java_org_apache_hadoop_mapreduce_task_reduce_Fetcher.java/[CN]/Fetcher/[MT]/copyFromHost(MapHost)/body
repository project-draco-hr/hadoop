{
  List<TaskAttemptID> maps=scheduler.getMapsForHost(host);
  if (maps.size() == 0) {
    return;
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Fetcher " + id + " going to fetch from "+ host+ " for: "+ maps);
  }
  Set<TaskAttemptID> remaining=new HashSet<TaskAttemptID>(maps);
  DataInputStream input=null;
  try {
    URL url=getMapOutputURL(host,maps);
    openConnection(url);
    if (stopped) {
      abortConnect(host,remaining);
      return;
    }
    String msgToEncode=SecureShuffleUtils.buildMsgFrom(url);
    String encHash=SecureShuffleUtils.hashFromString(msgToEncode,shuffleSecretKey);
    connection.addRequestProperty(SecureShuffleUtils.HTTP_HEADER_URL_HASH,encHash);
    connection.setReadTimeout(readTimeout);
    connection.addRequestProperty(ShuffleHeader.HTTP_HEADER_NAME,ShuffleHeader.DEFAULT_HTTP_HEADER_NAME);
    connection.addRequestProperty(ShuffleHeader.HTTP_HEADER_VERSION,ShuffleHeader.DEFAULT_HTTP_HEADER_VERSION);
    connect(connection,connectionTimeout);
    if (stopped) {
      abortConnect(host,remaining);
      return;
    }
    input=new DataInputStream(connection.getInputStream());
    int rc=connection.getResponseCode();
    if (rc != HttpURLConnection.HTTP_OK) {
      throw new IOException("Got invalid response code " + rc + " from "+ url+ ": "+ connection.getResponseMessage());
    }
    if (!ShuffleHeader.DEFAULT_HTTP_HEADER_NAME.equals(connection.getHeaderField(ShuffleHeader.HTTP_HEADER_NAME)) || !ShuffleHeader.DEFAULT_HTTP_HEADER_VERSION.equals(connection.getHeaderField(ShuffleHeader.HTTP_HEADER_VERSION))) {
      throw new IOException("Incompatible shuffle response version");
    }
    String replyHash=connection.getHeaderField(SecureShuffleUtils.HTTP_HEADER_REPLY_URL_HASH);
    if (replyHash == null) {
      throw new IOException("security validation of TT Map output failed");
    }
    LOG.debug("url=" + msgToEncode + ";encHash="+ encHash+ ";replyHash="+ replyHash);
    SecureShuffleUtils.verifyReply(replyHash,encHash,shuffleSecretKey);
    LOG.info("for url=" + msgToEncode + " sent hash and received reply");
  }
 catch (  IOException ie) {
    boolean connectExcpt=ie instanceof ConnectException;
    ioErrs.increment(1);
    LOG.warn("Failed to connect to " + host + " with "+ remaining.size()+ " map outputs",ie);
    scheduler.hostFailed(host.getHostName());
    for (    TaskAttemptID left : remaining) {
      scheduler.copyFailed(left,host,false,connectExcpt);
    }
    for (    TaskAttemptID left : remaining) {
      scheduler.putBackKnownMapOutput(host,left);
    }
    return;
  }
  try {
    TaskAttemptID[] failedTasks=null;
    while (!remaining.isEmpty() && failedTasks == null) {
      failedTasks=copyMapOutput(host,input,remaining);
    }
    if (failedTasks != null && failedTasks.length > 0) {
      LOG.warn("copyMapOutput failed for tasks " + Arrays.toString(failedTasks));
      scheduler.hostFailed(host.getHostName());
      for (      TaskAttemptID left : failedTasks) {
        scheduler.copyFailed(left,host,true,false);
      }
    }
    if (failedTasks == null && !remaining.isEmpty()) {
      throw new IOException("server didn't return all expected map outputs: " + remaining.size() + " left.");
    }
    input.close();
    input=null;
  }
  finally {
    if (input != null) {
      IOUtils.cleanup(LOG,input);
      input=null;
    }
    for (    TaskAttemptID left : remaining) {
      scheduler.putBackKnownMapOutput(host,left);
    }
  }
}
