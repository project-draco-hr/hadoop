{
  List<TaskAttemptID> maps=scheduler.getMapsForHost(host);
  if (maps.size() == 0) {
    return;
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Fetcher " + id + " going to fetch from "+ host);
    for (    TaskAttemptID tmp : maps) {
      LOG.debug(tmp);
    }
  }
  Set<TaskAttemptID> remaining=new HashSet<TaskAttemptID>(maps);
  DataInputStream input;
  boolean connectSucceeded=false;
  try {
    URL url=getMapOutputURL(host,maps);
    HttpURLConnection connection=openConnection(url);
    String msgToEncode=SecureShuffleUtils.buildMsgFrom(url);
    String encHash=SecureShuffleUtils.hashFromString(msgToEncode,jobTokenSecret);
    connection.addRequestProperty(SecureShuffleUtils.HTTP_HEADER_URL_HASH,encHash);
    connection.setReadTimeout(readTimeout);
    connect(connection,connectionTimeout);
    connectSucceeded=true;
    input=new DataInputStream(connection.getInputStream());
    int rc=connection.getResponseCode();
    if (rc != HttpURLConnection.HTTP_OK) {
      throw new IOException("Got invalid response code " + rc + " from "+ url+ ": "+ connection.getResponseMessage());
    }
    String replyHash=connection.getHeaderField(SecureShuffleUtils.HTTP_HEADER_REPLY_URL_HASH);
    if (replyHash == null) {
      throw new IOException("security validation of TT Map output failed");
    }
    LOG.debug("url=" + msgToEncode + ";encHash="+ encHash+ ";replyHash="+ replyHash);
    SecureShuffleUtils.verifyReply(replyHash,encHash,jobTokenSecret);
    LOG.info("for url=" + msgToEncode + " sent hash and receievd reply");
  }
 catch (  IOException ie) {
    ioErrs.increment(1);
    LOG.warn("Failed to connect to " + host + " with "+ remaining.size()+ " map outputs",ie);
    if (!connectSucceeded) {
      for (      TaskAttemptID left : remaining) {
        scheduler.copyFailed(left,host,connectSucceeded);
      }
    }
 else {
      TaskAttemptID firstMap=maps.get(0);
      scheduler.copyFailed(firstMap,host,connectSucceeded);
    }
    for (    TaskAttemptID left : remaining) {
      scheduler.putBackKnownMapOutput(host,left);
    }
    return;
  }
  try {
    TaskAttemptID[] failedTasks=null;
    while (!remaining.isEmpty() && failedTasks == null) {
      failedTasks=copyMapOutput(host,input,remaining);
    }
    if (failedTasks != null) {
      for (      TaskAttemptID left : failedTasks) {
        scheduler.copyFailed(left,host,true);
      }
    }
    IOUtils.cleanup(LOG,input);
    if (failedTasks == null && !remaining.isEmpty()) {
      throw new IOException("server didn't return all expected map outputs: " + remaining.size() + " left.");
    }
  }
  finally {
    for (    TaskAttemptID left : remaining) {
      scheduler.putBackKnownMapOutput(host,left);
    }
  }
}
