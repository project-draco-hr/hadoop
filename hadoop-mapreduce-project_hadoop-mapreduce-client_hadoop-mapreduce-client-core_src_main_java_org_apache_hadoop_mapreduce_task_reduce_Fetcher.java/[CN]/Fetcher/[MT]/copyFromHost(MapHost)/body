{
  retryStartTime=0;
  List<TaskAttemptID> maps=scheduler.getMapsForHost(host);
  if (maps.size() == 0) {
    return;
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Fetcher " + id + " going to fetch from "+ host+ " for: "+ maps);
  }
  Set<TaskAttemptID> remaining=new HashSet<TaskAttemptID>(maps);
  URL url=getMapOutputURL(host,maps);
  DataInputStream input=openShuffleUrl(host,remaining,url);
  if (input == null) {
    return;
  }
  try {
    TaskAttemptID[] failedTasks=null;
    while (!remaining.isEmpty() && failedTasks == null) {
      try {
        failedTasks=copyMapOutput(host,input,remaining,fetchRetryEnabled);
      }
 catch (      IOException e) {
        connection.disconnect();
        url=getMapOutputURL(host,remaining);
        input=openShuffleUrl(host,remaining,url);
        if (input == null) {
          return;
        }
      }
    }
    if (failedTasks != null && failedTasks.length > 0) {
      LOG.warn("copyMapOutput failed for tasks " + Arrays.toString(failedTasks));
      scheduler.hostFailed(host.getHostName());
      for (      TaskAttemptID left : failedTasks) {
        scheduler.copyFailed(left,host,true,false);
      }
    }
    if (failedTasks == null && !remaining.isEmpty()) {
      throw new IOException("server didn't return all expected map outputs: " + remaining.size() + " left.");
    }
    input.close();
    input=null;
  }
  finally {
    if (input != null) {
      IOUtils.cleanup(LOG,input);
      input=null;
    }
    for (    TaskAttemptID left : remaining) {
      scheduler.putBackKnownMapOutput(host,left);
    }
  }
}
