{
  retryStartTime=0;
  List<TaskAttemptID> maps=scheduler.getMapsForHost(host);
  if (maps.size() == 0) {
    return;
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Fetcher " + id + " going to fetch from "+ host+ " for: "+ maps);
  }
  Set<TaskAttemptID> remaining=new HashSet<TaskAttemptID>(maps);
  DataInputStream input=null;
  URL url=getMapOutputURL(host,maps);
  try {
    setupConnectionsWithRetry(host,remaining,url);
    if (stopped) {
      abortConnect(host,remaining);
      return;
    }
  }
 catch (  IOException ie) {
    boolean connectExcpt=ie instanceof ConnectException;
    ioErrs.increment(1);
    LOG.warn("Failed to connect to " + host + " with "+ remaining.size()+ " map outputs",ie);
    scheduler.hostFailed(host.getHostName());
    for (    TaskAttemptID left : remaining) {
      scheduler.copyFailed(left,host,false,connectExcpt);
    }
    for (    TaskAttemptID left : remaining) {
      scheduler.putBackKnownMapOutput(host,left);
    }
    return;
  }
  input=new DataInputStream(connection.getInputStream());
  try {
    TaskAttemptID[] failedTasks=null;
    while (!remaining.isEmpty() && failedTasks == null) {
      try {
        failedTasks=copyMapOutput(host,input,remaining,fetchRetryEnabled);
      }
 catch (      IOException e) {
        connection.disconnect();
        url=getMapOutputURL(host,remaining);
        setupConnectionsWithRetry(host,remaining,url);
        if (stopped) {
          abortConnect(host,remaining);
          return;
        }
        input=new DataInputStream(connection.getInputStream());
      }
    }
    if (failedTasks != null && failedTasks.length > 0) {
      LOG.warn("copyMapOutput failed for tasks " + Arrays.toString(failedTasks));
      scheduler.hostFailed(host.getHostName());
      for (      TaskAttemptID left : failedTasks) {
        scheduler.copyFailed(left,host,true,false);
      }
    }
    if (failedTasks == null && !remaining.isEmpty()) {
      throw new IOException("server didn't return all expected map outputs: " + remaining.size() + " left.");
    }
    input.close();
    input=null;
  }
  finally {
    if (input != null) {
      IOUtils.cleanup(LOG,input);
      input=null;
    }
    for (    TaskAttemptID left : remaining) {
      scheduler.putBackKnownMapOutput(host,left);
    }
  }
}
