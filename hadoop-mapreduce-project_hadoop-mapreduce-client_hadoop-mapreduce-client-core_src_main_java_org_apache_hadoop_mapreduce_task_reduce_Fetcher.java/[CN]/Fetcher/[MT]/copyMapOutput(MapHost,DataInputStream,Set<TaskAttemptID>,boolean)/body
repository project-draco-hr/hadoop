{
  MapOutput<K,V> mapOutput=null;
  TaskAttemptID mapId=null;
  long decompressedLength=-1;
  long compressedLength=-1;
  try {
    long startTime=Time.monotonicNow();
    int forReduce=-1;
    try {
      ShuffleHeader header=new ShuffleHeader();
      header.readFields(input);
      mapId=TaskAttemptID.forName(header.mapId);
      compressedLength=header.compressedLength;
      decompressedLength=header.uncompressedLength;
      forReduce=header.forReduce;
    }
 catch (    IllegalArgumentException e) {
      badIdErrs.increment(1);
      LOG.warn("Invalid map id ",e);
      return remaining.toArray(new TaskAttemptID[remaining.size()]);
    }
    InputStream is=input;
    is=CryptoUtils.wrapIfNecessary(jobConf,is,compressedLength);
    compressedLength-=CryptoUtils.cryptoPadding(jobConf);
    decompressedLength-=CryptoUtils.cryptoPadding(jobConf);
    if (!verifySanity(compressedLength,decompressedLength,forReduce,remaining,mapId)) {
      return new TaskAttemptID[]{mapId};
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("header: " + mapId + ", len: "+ compressedLength+ ", decomp len: "+ decompressedLength);
    }
    try {
      mapOutput=merger.reserve(mapId,decompressedLength,id);
    }
 catch (    IOException ioe) {
      ioErrs.increment(1);
      scheduler.reportLocalError(ioe);
      return EMPTY_ATTEMPT_ID_ARRAY;
    }
    if (mapOutput == null) {
      LOG.info("fetcher#" + id + " - MergeManager returned status WAIT ...");
      return EMPTY_ATTEMPT_ID_ARRAY;
    }
    try {
      LOG.info("fetcher#" + id + " about to shuffle output of map "+ mapOutput.getMapId()+ " decomp: "+ decompressedLength+ " len: "+ compressedLength+ " to "+ mapOutput.getDescription());
      mapOutput.shuffle(host,is,compressedLength,decompressedLength,metrics,reporter);
    }
 catch (    java.lang.InternalError e) {
      LOG.warn("Failed to shuffle for fetcher#" + id,e);
      throw new IOException(e);
    }
    long endTime=Time.monotonicNow();
    retryStartTime=0;
    scheduler.copySucceeded(mapId,host,compressedLength,startTime,endTime,mapOutput);
    remaining.remove(mapId);
    metrics.successFetch();
    return null;
  }
 catch (  IOException ioe) {
    if (canRetry) {
      checkTimeoutOrRetry(host,ioe);
    }
    ioErrs.increment(1);
    if (mapId == null || mapOutput == null) {
      LOG.warn("fetcher#" + id + " failed to read map header"+ mapId+ " decomp: "+ decompressedLength+ ", "+ compressedLength,ioe);
      if (mapId == null) {
        return remaining.toArray(new TaskAttemptID[remaining.size()]);
      }
 else {
        return new TaskAttemptID[]{mapId};
      }
    }
    LOG.warn("Failed to shuffle output of " + mapId + " from "+ host.getHostName(),ioe);
    mapOutput.abort();
    metrics.failedFetch();
    return new TaskAttemptID[]{mapId};
  }
}
