{
  Configuration conf=new Configuration();
  conf.set("hadoop.security.authentication","kerberos");
  UserGroupInformation.setConfiguration(conf);
  final File testDir=getTestDir();
  conf=createBaseKMSConf(testDir);
  conf.set("hadoop.kms.authentication.type","kerberos");
  conf.set("hadoop.kms.authentication.kerberos.keytab",keytab.getAbsolutePath());
  conf.set("hadoop.kms.authentication.kerberos.principal","HTTP/localhost");
  conf.set("hadoop.kms.authentication.kerberos.name.rules","DEFAULT");
  for (  KMSACLs.Type type : KMSACLs.Type.values()) {
    conf.set(type.getAclConfigKey(),type.toString());
  }
  conf.set(KMSACLs.Type.CREATE.getAclConfigKey(),"CREATE,ROLLOVER,GET,SET_KEY_MATERIAL,GENERATE_EEK,DECRYPT_EEK");
  conf.set(KMSACLs.Type.ROLLOVER.getAclConfigKey(),"CREATE,ROLLOVER,GET,SET_KEY_MATERIAL,GENERATE_EEK,DECRYPT_EEK");
  conf.set(KMSACLs.Type.GENERATE_EEK.getAclConfigKey(),"CREATE,ROLLOVER,GET,SET_KEY_MATERIAL,GENERATE_EEK");
  conf.set(KMSACLs.Type.DECRYPT_EEK.getAclConfigKey(),"CREATE,ROLLOVER,GET,SET_KEY_MATERIAL,GENERATE_EEK");
  conf.set(KeyAuthorizationKeyProvider.KEY_ACL + "test_key.MANAGEMENT","CREATE");
  conf.set(KeyAuthorizationKeyProvider.KEY_ACL + "some_key.MANAGEMENT","ROLLOVER");
  conf.set(KMSConfiguration.WHITELIST_KEY_ACL_PREFIX + "MANAGEMENT","DECRYPT_EEK");
  conf.set(KeyAuthorizationKeyProvider.KEY_ACL + "all_access.ALL","GENERATE_EEK");
  conf.set(KeyAuthorizationKeyProvider.KEY_ACL + "all_access.DECRYPT_EEK","ROLLOVER");
  conf.set(KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + "MANAGEMENT","ROLLOVER");
  writeConf(testDir,conf);
  runServer(null,null,testDir,new KMSCallable<Void>(){
    @Override public Void call() throws Exception {
      final Configuration conf=new Configuration();
      conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME,128);
      final URI uri=createKMSUri(getKMSUrl());
      doAs("CREATE",new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          KeyProvider kp=new KMSClientProvider(uri,conf);
          try {
            Options options=new KeyProvider.Options(conf);
            Map<String,String> attributes=options.getAttributes();
            HashMap<String,String> newAttribs=new HashMap<String,String>(attributes);
            newAttribs.put("key.acl.name","test_key");
            options.setAttributes(newAttribs);
            KeyProvider.KeyVersion kv=kp.createKey("k0",options);
            Assert.assertNull(kv.getMaterial());
            KeyVersion rollVersion=kp.rollNewVersion("k0");
            Assert.assertNull(rollVersion.getMaterial());
            KeyProviderCryptoExtension kpce=KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);
            try {
              kpce.generateEncryptedKey("k0");
              Assert.fail("User [CREATE] should not be allowed to generate_eek on k0");
            }
 catch (            Exception e) {
            }
            newAttribs=new HashMap<String,String>(attributes);
            newAttribs.put("key.acl.name","all_access");
            options.setAttributes(newAttribs);
            try {
              kp.createKey("kx",options);
              Assert.fail("User [CREATE] should not be allowed to create kx");
            }
 catch (            Exception e) {
            }
          }
 catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      doAs("DECRYPT_EEK",new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          KeyProvider kp=new KMSClientProvider(uri,conf);
          try {
            Options options=new KeyProvider.Options(conf);
            Map<String,String> attributes=options.getAttributes();
            HashMap<String,String> newAttribs=new HashMap<String,String>(attributes);
            newAttribs.put("key.acl.name","some_key");
            options.setAttributes(newAttribs);
            KeyProvider.KeyVersion kv=kp.createKey("kk0",options);
            Assert.assertNull(kv.getMaterial());
            KeyVersion rollVersion=kp.rollNewVersion("kk0");
            Assert.assertNull(rollVersion.getMaterial());
            KeyProviderCryptoExtension kpce=KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);
            try {
              kpce.generateEncryptedKey("kk0");
              Assert.fail("User [DECRYPT_EEK] should not be allowed to generate_eek on kk0");
            }
 catch (            Exception e) {
            }
            newAttribs=new HashMap<String,String>(attributes);
            newAttribs.put("key.acl.name","all_access");
            options.setAttributes(newAttribs);
            kp.createKey("kkx",options);
          }
 catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      doAs("ROLLOVER",new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          KeyProvider kp=new KMSClientProvider(uri,conf);
          try {
            Options options=new KeyProvider.Options(conf);
            Map<String,String> attributes=options.getAttributes();
            HashMap<String,String> newAttribs=new HashMap<String,String>(attributes);
            newAttribs.put("key.acl.name","test_key2");
            options.setAttributes(newAttribs);
            KeyProvider.KeyVersion kv=kp.createKey("k1",options);
            Assert.assertNull(kv.getMaterial());
            KeyVersion rollVersion=kp.rollNewVersion("k1");
            Assert.assertNull(rollVersion.getMaterial());
            try {
              kp.rollNewVersion("k0");
              Assert.fail("User [ROLLOVER] should not be allowed to rollover k0");
            }
 catch (            Exception e) {
            }
            KeyProviderCryptoExtension kpce=KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);
            try {
              kpce.generateEncryptedKey("k1");
              Assert.fail("User [ROLLOVER] should not be allowed to generate_eek on k1");
            }
 catch (            Exception e) {
            }
            newAttribs=new HashMap<String,String>(attributes);
            newAttribs.put("key.acl.name","all_access");
            options.setAttributes(newAttribs);
            try {
              kp.createKey("kx",options);
              Assert.fail("User [ROLLOVER] should not be allowed to create kx");
            }
 catch (            Exception e) {
            }
          }
 catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      doAs("GET",new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          KeyProvider kp=new KMSClientProvider(uri,conf);
          try {
            Options options=new KeyProvider.Options(conf);
            Map<String,String> attributes=options.getAttributes();
            HashMap<String,String> newAttribs=new HashMap<String,String>(attributes);
            newAttribs.put("key.acl.name","test_key");
            options.setAttributes(newAttribs);
            try {
              kp.createKey("k2",options);
              Assert.fail("User [GET] should not be allowed to create key..");
            }
 catch (            Exception e) {
            }
            newAttribs=new HashMap<String,String>(attributes);
            newAttribs.put("key.acl.name","all_access");
            options.setAttributes(newAttribs);
            try {
              kp.createKey("kx",options);
              Assert.fail("User [GET] should not be allowed to create kx");
            }
 catch (            Exception e) {
            }
          }
 catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      final EncryptedKeyVersion ekv=doAs("GENERATE_EEK",new PrivilegedExceptionAction<EncryptedKeyVersion>(){
        @Override public EncryptedKeyVersion run() throws Exception {
          KeyProvider kp=new KMSClientProvider(uri,conf);
          try {
            Options options=new KeyProvider.Options(conf);
            Map<String,String> attributes=options.getAttributes();
            HashMap<String,String> newAttribs=new HashMap<String,String>(attributes);
            newAttribs.put("key.acl.name","all_access");
            options.setAttributes(newAttribs);
            kp.createKey("kx",options);
            KeyProviderCryptoExtension kpce=KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);
            try {
              return kpce.generateEncryptedKey("kx");
            }
 catch (            Exception e) {
              Assert.fail("User [GENERATE_EEK] should be allowed to generate_eek on kx");
            }
          }
 catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      doAs("ROLLOVER",new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          KeyProvider kp=new KMSClientProvider(uri,conf);
          try {
            KeyProviderCryptoExtension kpce=KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);
            kpce.decryptEncryptedKey(ekv);
          }
 catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      return null;
    }
  }
);
  conf.set(KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + "MANAGEMENT","");
  conf.set(KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + "GENERATE_EEK","*");
  writeConf(testDir,conf);
  runServer(null,null,testDir,new KMSCallable<Void>(){
    @Override public Void call() throws Exception {
      final Configuration conf=new Configuration();
      conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME,128);
      final URI uri=createKMSUri(getKMSUrl());
      doAs("GENERATE_EEK",new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          KeyProvider kp=new KMSClientProvider(uri,conf);
          try {
            KeyProviderCryptoExtension kpce=KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);
            try {
              kpce.generateEncryptedKey("k1");
            }
 catch (            Exception e) {
              Assert.fail("User [GENERATE_EEK] should be allowed to generate_eek on k1");
            }
          }
 catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      return null;
    }
  }
);
}
