{
  org.apache.log4j.Logger.getRootLogger().setLevel(org.apache.log4j.Level.DEBUG);
  conf=new Configuration(false);
  conf.setLong(WAIT_TIME_BEFORE_KILL,10000);
  conf.setLong(MONITORING_INTERVAL,3000);
  conf.setFloat(TOTAL_PREEMPTION_PER_ROUND,(float)1.0);
  conf.setFloat(NATURAL_TERMINATION_FACTOR,(float)1.0);
  conf.set(YarnConfiguration.RM_SCHEDULER_MONITOR_POLICIES,ProportionalCapacityPreemptionPolicy.class.getCanonicalName());
  conf.setBoolean(YarnConfiguration.RM_SCHEDULER_ENABLE_MONITORS,true);
  conf.set("yarn.resourcemanager.scheduler.class",CapacityScheduler.class.getName());
  mClock=mock(Clock.class);
  cs=mock(CapacityScheduler.class);
  when(cs.getResourceCalculator()).thenReturn(rc);
  when(cs.getPreemptionManager()).thenReturn(new PreemptionManager());
  nlm=mock(RMNodeLabelsManager.class);
  mDisp=mock(EventHandler.class);
  rmContext=mock(RMContext.class);
  when(rmContext.getNodeLabelManager()).thenReturn(nlm);
  Dispatcher disp=mock(Dispatcher.class);
  when(rmContext.getDispatcher()).thenReturn(disp);
  when(disp.getEventHandler()).thenReturn(mDisp);
  csConf=new CapacitySchedulerConfiguration();
  when(cs.getConfiguration()).thenReturn(csConf);
  when(cs.getRMContext()).thenReturn(rmContext);
  policy=new ProportionalCapacityPreemptionPolicy(conf,rmContext,cs,mClock);
  partitionToResource=new HashMap<>();
  nodeIdToSchedulerNodes=new HashMap<>();
  nameToCSQueues=new HashMap<>();
}
