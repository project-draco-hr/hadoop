{
  YarnConfiguration conf=new YarnConfiguration();
  MockRM rm=new MockRM();
  rm.init(conf);
  rm.start();
  final String queue="default";
  final String user="user";
  CapacityScheduler cs=(CapacityScheduler)rm.getResourceScheduler();
  final LeafQueue defaultQueue=(LeafQueue)cs.getQueue(queue);
  final List<FiCaSchedulerApp> listOfApps=createListOfApps(10000,user,defaultQueue);
  final CyclicBarrier cb=new CyclicBarrier(2);
  final List<ConcurrentModificationException> conException=new ArrayList<ConcurrentModificationException>();
  Thread submitAndRemove=new Thread(new Runnable(){
    @Override public void run(){
      for (      FiCaSchedulerApp fiCaSchedulerApp : listOfApps) {
        defaultQueue.submitApplicationAttempt(fiCaSchedulerApp,user);
      }
      try {
        cb.await();
      }
 catch (      Exception e) {
      }
      for (      FiCaSchedulerApp fiCaSchedulerApp : listOfApps) {
        defaultQueue.finishApplicationAttempt(fiCaSchedulerApp,queue);
      }
    }
  }
,"SubmitAndRemoveApplicationAttempt Thread");
  Thread getAppsInQueue=new Thread(new Runnable(){
    List<ApplicationAttemptId> apps=new ArrayList<ApplicationAttemptId>();
    @Override public void run(){
      try {
        try {
          cb.await();
        }
 catch (        Exception e) {
        }
        defaultQueue.collectSchedulerApplications(apps);
      }
 catch (      ConcurrentModificationException e) {
        conException.add(e);
      }
    }
  }
,"GetAppsInQueue Thread");
  submitAndRemove.start();
  getAppsInQueue.start();
  submitAndRemove.join();
  getAppsInQueue.join();
  assertTrue("ConcurrentModificationException is thrown",conException.isEmpty());
  rm.stop();
}
