{
  if (!schedulerClass.equals(CapacityScheduler.class)) {
    return;
  }
  conf.setBoolean(CapacitySchedulerConfiguration.ENABLE_USER_METRICS,true);
  conf.set(CapacitySchedulerConfiguration.RESOURCE_CALCULATOR_CLASS,DominantResourceCalculator.class.getName());
  CapacitySchedulerConfiguration csConf=new CapacitySchedulerConfiguration(conf);
  setupQueueConfiguration(csConf);
  MemoryRMStateStore memStore=new MemoryRMStateStore();
  memStore.init(csConf);
  rm1=new MockRM(csConf,memStore);
  rm1.start();
  MockNM nm1=new MockNM("127.0.0.1:1234",8192,rm1.getResourceTrackerService());
  MockNM nm2=new MockNM("127.1.1.1:4321",8192,rm1.getResourceTrackerService());
  nm1.registerNode();
  nm2.registerNode();
  RMApp app1_1=rm1.submitApp(1024,"app1_1",USER_1,null,A);
  MockAM am1_1=MockRM.launchAndRegisterAM(app1_1,rm1,nm1);
  RMApp app1_2=rm1.submitApp(1024,"app1_2",USER_1,null,A);
  MockAM am1_2=MockRM.launchAndRegisterAM(app1_2,rm1,nm2);
  RMApp app2=rm1.submitApp(1024,"app2",USER_2,null,B);
  MockAM am2=MockRM.launchAndRegisterAM(app2,rm1,nm2);
  rm1.clearQueueMetrics(app1_1);
  rm1.clearQueueMetrics(app1_2);
  rm1.clearQueueMetrics(app2);
  rm2=new MockRM(csConf,memStore);
  rm2.start();
  nm1.setResourceTrackerService(rm2.getResourceTrackerService());
  nm2.setResourceTrackerService(rm2.getResourceTrackerService());
  List<NMContainerStatus> am1_1Containers=createNMContainerStatusForApp(am1_1);
  List<NMContainerStatus> am1_2Containers=createNMContainerStatusForApp(am1_2);
  am1_1Containers.addAll(am1_2Containers);
  nm1.registerNode(am1_1Containers,null);
  List<NMContainerStatus> am2Containers=createNMContainerStatusForApp(am2);
  nm2.registerNode(am2Containers,null);
  waitForNumContainersToRecover(2,rm2,am1_1.getApplicationAttemptId());
  waitForNumContainersToRecover(2,rm2,am1_2.getApplicationAttemptId());
  waitForNumContainersToRecover(2,rm2,am1_2.getApplicationAttemptId());
  Resource containerResource=Resource.newInstance(1024,1);
  Resource nmResource=Resource.newInstance(nm1.getMemory(),nm1.getvCores());
  Resource clusterResource=Resources.multiply(nmResource,2);
  Resource q1Resource=Resources.multiply(clusterResource,0.5);
  Resource q2Resource=Resources.multiply(clusterResource,0.5);
  Resource q1UsedResource=Resources.multiply(containerResource,4);
  Resource q2UsedResource=Resources.multiply(containerResource,2);
  Resource totalUsedResource=Resources.add(q1UsedResource,q2UsedResource);
  Resource q1availableResources=Resources.subtract(q1Resource,q1UsedResource);
  Resource q2availableResources=Resources.subtract(q2Resource,q2UsedResource);
  Resource totalAvailableResource=Resources.add(q1availableResources,q2availableResources);
  Map<ApplicationId,SchedulerApplication> schedulerApps=((AbstractYarnScheduler)rm2.getResourceScheduler()).getSchedulerApplications();
  SchedulerApplication schedulerApp1_1=schedulerApps.get(app1_1.getApplicationId());
  checkCSLeafQueue(rm2,schedulerApp1_1,clusterResource,q1Resource,q1UsedResource,4);
  QueueMetrics queue1Metrics=schedulerApp1_1.getQueue().getMetrics();
  asserteMetrics(queue1Metrics,2,0,2,0,4,q1availableResources.getMemory(),q1availableResources.getVirtualCores(),q1UsedResource.getMemory(),q1UsedResource.getVirtualCores());
  SchedulerApplication schedulerApp2=schedulerApps.get(app2.getApplicationId());
  checkCSLeafQueue(rm2,schedulerApp2,clusterResource,q2Resource,q2UsedResource,2);
  QueueMetrics queue2Metrics=schedulerApp2.getQueue().getMetrics();
  asserteMetrics(queue2Metrics,1,0,1,0,2,q2availableResources.getMemory(),q2availableResources.getVirtualCores(),q2UsedResource.getMemory(),q2UsedResource.getVirtualCores());
  LeafQueue leafQueue=(LeafQueue)schedulerApp2.getQueue();
  ParentQueue parentQueue=(ParentQueue)leafQueue.getParent();
  checkParentQueue(parentQueue,6,totalUsedResource,(float)6 / 16,(float)6 / 16);
  asserteMetrics(parentQueue.getMetrics(),3,0,3,0,6,totalAvailableResource.getMemory(),totalAvailableResource.getVirtualCores(),totalUsedResource.getMemory(),totalUsedResource.getVirtualCores());
}
