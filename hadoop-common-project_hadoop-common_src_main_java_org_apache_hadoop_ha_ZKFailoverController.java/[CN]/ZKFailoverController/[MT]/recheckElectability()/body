{
synchronized (elector) {
synchronized (this) {
      boolean healthy=lastHealthState == State.SERVICE_HEALTHY;
      long remainingDelay=delayJoiningUntilNanotime - System.nanoTime();
      if (remainingDelay > 0) {
        if (healthy) {
          LOG.info("Would have joined master election, but this node is " + "prohibited from doing so for " + TimeUnit.NANOSECONDS.toMillis(remainingDelay) + " more ms");
        }
        scheduleRecheck(remainingDelay);
        return;
      }
switch (lastHealthState) {
case SERVICE_HEALTHY:
        elector.joinElection(targetToData(localTarget));
      break;
case INITIALIZING:
    LOG.info("Ensuring that " + localTarget + " does not "+ "participate in active master election");
  elector.quitElection(false);
break;
case SERVICE_UNHEALTHY:
case SERVICE_NOT_RESPONDING:
LOG.info("Quitting master election for " + localTarget + " and marking that fencing is necessary");
elector.quitElection(true);
break;
case HEALTH_MONITOR_FAILED:
fatalError("Health monitor failed!");
break;
default :
throw new IllegalArgumentException("Unhandled state:" + lastHealthState);
}
}
}
}
