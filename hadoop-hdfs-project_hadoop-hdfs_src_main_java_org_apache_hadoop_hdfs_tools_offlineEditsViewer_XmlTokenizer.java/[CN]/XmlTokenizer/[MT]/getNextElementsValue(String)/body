{
  boolean gotSTART_ELEMENT=false;
  try {
    int eventType=in.getEventType();
    while (true) {
switch (eventType) {
case XMLStreamConstants.CHARACTERS:
        if (gotSTART_ELEMENT) {
          return in.getText().trim();
        }
      break;
case XMLStreamConstants.END_DOCUMENT:
    throw new IOException("End of XML while looking for element [" + wantedName + "]");
case XMLStreamConstants.START_ELEMENT:
  if (gotSTART_ELEMENT) {
    throw new IOException("START_ELEMENT [" + in.getName() + " event when expecting CHARACTERS event for ["+ wantedName+ "]");
  }
 else   if (in.getName().toString().equals(wantedName)) {
    gotSTART_ELEMENT=true;
  }
 else {
    throw new IOException("unexpected element name [" + in.getName() + "], was expecting ["+ wantedName+ "]");
  }
break;
case XMLStreamConstants.COMMENT:
case XMLStreamConstants.END_ELEMENT:
case XMLStreamConstants.SPACE:
case XMLStreamConstants.START_DOCUMENT:
break;
case XMLStreamConstants.ATTRIBUTE:
case XMLStreamConstants.CDATA:
case XMLStreamConstants.DTD:
case XMLStreamConstants.ENTITY_DECLARATION:
case XMLStreamConstants.ENTITY_REFERENCE:
case XMLStreamConstants.NAMESPACE:
case XMLStreamConstants.NOTATION_DECLARATION:
case XMLStreamConstants.PROCESSING_INSTRUCTION:
default :
throw new IOException("Unsupported event type [" + eventType + "] (see XMLStreamConstants)");
}
if (!in.hasNext()) {
break;
}
eventType=in.next();
}
}
 catch (XMLStreamException e) {
throw new IOException("Error reading XML stream",e);
}
throw new IOException("Error reading XML stream, should never reach this line, " + "most likely XML does not have elements we are loking for");
}
