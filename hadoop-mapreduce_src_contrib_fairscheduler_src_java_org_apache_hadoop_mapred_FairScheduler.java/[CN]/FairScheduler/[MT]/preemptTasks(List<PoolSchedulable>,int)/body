{
  if (scheds.isEmpty() || tasksToPreempt == 0)   return;
  TaskType taskType=scheds.get(0).getTaskType();
  List<TaskStatus> runningTasks=new ArrayList<TaskStatus>();
  for (  PoolSchedulable sched : scheds) {
    if (sched.getRunningTasks() > sched.getFairShare())     for (    JobSchedulable js : sched.getJobSchedulables()) {
      runningTasks.addAll(getRunningTasks(js.getJob(),taskType));
    }
  }
  Collections.sort(runningTasks,new Comparator<TaskStatus>(){
    public int compare(    TaskStatus t1,    TaskStatus t2){
      if (t1.getStartTime() < t2.getStartTime())       return 1;
 else       if (t1.getStartTime() == t2.getStartTime())       return 0;
 else       return -1;
    }
  }
);
  HashMap<Pool,Integer> tasksLeft=new HashMap<Pool,Integer>();
  for (  Pool p : poolMgr.getPools()) {
    tasksLeft.put(p,p.getSchedulable(taskType).getRunningTasks());
  }
  for (  TaskStatus status : runningTasks) {
    JobID jobID=status.getTaskID().getJobID();
    JobInProgress job=taskTrackerManager.getJob(jobID);
    Pool pool=poolMgr.getPool(job);
    PoolSchedulable sched=pool.getSchedulable(taskType);
    int tasksLeftForPool=tasksLeft.get(pool);
    if (tasksLeftForPool > sched.getFairShare()) {
      eventLog.log("PREEMPT",status.getTaskID(),status.getTaskTracker());
      try {
        taskTrackerManager.killTask(status.getTaskID(),false);
        tasksToPreempt--;
        if (tasksToPreempt == 0)         break;
        tasksLeft.put(pool,--tasksLeftForPool);
      }
 catch (      IOException e) {
        LOG.error("Failed to kill task " + status.getTaskID(),e);
      }
    }
  }
}
