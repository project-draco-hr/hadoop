{
  super(cs,queueName,parent,old);
  this.scheduler=cs;
  this.queueComparator=cs.getQueueComparator();
  this.rootQueue=(parent == null);
  float rawCapacity=cs.getConfiguration().getCapacity(getQueuePath());
  if (rootQueue && (rawCapacity != CapacitySchedulerConfiguration.MAXIMUM_CAPACITY_VALUE)) {
    throw new IllegalArgumentException("Illegal " + "capacity of " + rawCapacity + " for queue "+ queueName+ ". Must be "+ CapacitySchedulerConfiguration.MAXIMUM_CAPACITY_VALUE);
  }
  float capacity=(float)rawCapacity / 100;
  float parentAbsoluteCapacity=(rootQueue) ? 1.0f : parent.getAbsoluteCapacity();
  float absoluteCapacity=parentAbsoluteCapacity * capacity;
  float maximumCapacity=(float)cs.getConfiguration().getMaximumCapacity(getQueuePath()) / 100;
  float absoluteMaxCapacity=CSQueueUtils.computeAbsoluteMaximumCapacity(maximumCapacity,parent);
  QueueState state=cs.getConfiguration().getState(getQueuePath());
  Map<QueueACL,AccessControlList> acls=cs.getConfiguration().getAcls(getQueuePath());
  setupQueueConfigs(cs.getClusterResource(),capacity,absoluteCapacity,maximumCapacity,absoluteMaxCapacity,state,acls,accessibleLabels,defaultLabelExpression,capacitiyByNodeLabels,maxCapacityByNodeLabels,cs.getConfiguration().getReservationContinueLook());
  this.childQueues=new TreeSet<CSQueue>(queueComparator);
  LOG.info("Initialized parent-queue " + queueName + " name="+ queueName+ ", fullname="+ getQueuePath());
}
