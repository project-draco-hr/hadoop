{
  try {
    writeLock.lock();
    if (schedulingMode == SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY && !accessibleToPartition(node.getPartition())) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Skip this queue=" + getQueuePath() + ", because it is not able to access partition="+ node.getPartition());
      }
      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager,node,getParentName(),getQueueName(),ActivityState.REJECTED,ActivityDiagnosticConstant.NOT_ABLE_TO_ACCESS_PARTITION + node.getPartition());
      if (rootQueue) {
        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,node);
      }
      return CSAssignment.NULL_ASSIGNMENT;
    }
    if (!super.hasPendingResourceRequest(node.getPartition(),clusterResource,schedulingMode)) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Skip this queue=" + getQueuePath() + ", because it doesn't need more resource, schedulingMode="+ schedulingMode.name()+ " node-partition="+ node.getPartition());
      }
      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager,node,getParentName(),getQueueName(),ActivityState.SKIPPED,ActivityDiagnosticConstant.QUEUE_DO_NOT_NEED_MORE_RESOURCE);
      if (rootQueue) {
        ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,node);
      }
      return CSAssignment.NULL_ASSIGNMENT;
    }
    CSAssignment assignment=new CSAssignment(Resources.createResource(0,0),NodeType.NODE_LOCAL);
    while (canAssign(clusterResource,node)) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Trying to assign containers to child-queue of " + getQueueName());
      }
      if (!super.canAssignToThisQueue(clusterResource,node.getPartition(),resourceLimits,Resources.createResource(getMetrics().getReservedMB(),getMetrics().getReservedVirtualCores()),schedulingMode)) {
        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager,node,getParentName(),getQueueName(),ActivityState.SKIPPED,ActivityDiagnosticConstant.QUEUE_MAX_CAPACITY_LIMIT);
        if (rootQueue) {
          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,node);
        }
        break;
      }
      CSAssignment assignedToChild=assignContainersToChildQueues(clusterResource,node,resourceLimits,schedulingMode);
      assignment.setType(assignedToChild.getType());
      if (Resources.greaterThan(resourceCalculator,clusterResource,assignedToChild.getResource(),Resources.none())) {
        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager,node,getParentName(),getQueueName(),ActivityState.ACCEPTED,ActivityDiagnosticConstant.EMPTY);
        if (node.getReservedContainer() == null) {
          if (rootQueue) {
            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(activitiesManager,node,assignedToChild.getAssignmentInformation().getFirstAllocatedOrReservedContainerId(),AllocationState.ALLOCATED);
          }
        }
 else {
          if (rootQueue) {
            ActivitiesLogger.NODE.finishAllocatedNodeAllocation(activitiesManager,node,assignedToChild.getAssignmentInformation().getFirstAllocatedOrReservedContainerId(),AllocationState.RESERVED);
          }
        }
        allocateResource(clusterResource,assignedToChild.getResource(),node.getPartition(),assignedToChild.isIncreasedAllocation());
        Resources.addTo(assignment.getResource(),assignedToChild.getResource());
        Resources.addTo(assignment.getAssignmentInformation().getAllocated(),assignedToChild.getAssignmentInformation().getAllocated());
        Resources.addTo(assignment.getAssignmentInformation().getReserved(),assignedToChild.getAssignmentInformation().getReserved());
        assignment.getAssignmentInformation().incrAllocations(assignedToChild.getAssignmentInformation().getNumAllocations());
        assignment.getAssignmentInformation().incrReservations(assignedToChild.getAssignmentInformation().getNumReservations());
        assignment.getAssignmentInformation().getAllocationDetails().addAll(assignedToChild.getAssignmentInformation().getAllocationDetails());
        assignment.getAssignmentInformation().getReservationDetails().addAll(assignedToChild.getAssignmentInformation().getReservationDetails());
        assignment.setIncreasedAllocation(assignedToChild.isIncreasedAllocation());
        LOG.info("assignedContainer" + " queue=" + getQueueName() + " usedCapacity="+ getUsedCapacity()+ " absoluteUsedCapacity="+ getAbsoluteUsedCapacity()+ " used="+ queueUsage.getUsed()+ " cluster="+ clusterResource);
      }
 else {
        assignment.setSkippedType(assignedToChild.getSkippedType());
        ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager,node,getParentName(),getQueueName(),ActivityState.SKIPPED,ActivityDiagnosticConstant.EMPTY);
        if (rootQueue) {
          ActivitiesLogger.NODE.finishSkippedNodeAllocation(activitiesManager,node);
        }
        break;
      }
      if (LOG.isDebugEnabled()) {
        LOG.debug("ParentQ=" + getQueueName() + " assignedSoFarInThisIteration="+ assignment.getResource()+ " usedCapacity="+ getUsedCapacity()+ " absoluteUsedCapacity="+ getAbsoluteUsedCapacity());
      }
      if (!rootQueue || assignment.getType() == NodeType.OFF_SWITCH) {
        if (LOG.isDebugEnabled()) {
          if (rootQueue && assignment.getType() == NodeType.OFF_SWITCH) {
            LOG.debug("Not assigning more than one off-switch container," + " assignments so far: " + assignment);
          }
        }
        break;
      }
    }
    return assignment;
  }
  finally {
    writeLock.unlock();
  }
}
