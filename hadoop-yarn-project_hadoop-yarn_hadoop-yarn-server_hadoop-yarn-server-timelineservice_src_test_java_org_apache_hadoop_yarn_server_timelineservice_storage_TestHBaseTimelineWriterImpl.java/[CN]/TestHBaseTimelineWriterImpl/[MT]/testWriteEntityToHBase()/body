{
  TimelineEntities te=new TimelineEntities();
  TimelineEntity entity=new TimelineEntity();
  String id="hello";
  String type="world";
  entity.setId(id);
  entity.setType(type);
  Long cTime=1425016501000L;
  Long mTime=1425026901000L;
  entity.setCreatedTime(cTime);
  entity.setModifiedTime(mTime);
  String key="task";
  String value="is_related_to_entity_id_here";
  Set<String> isRelatedToSet=new HashSet<String>();
  isRelatedToSet.add(value);
  Map<String,Set<String>> isRelatedTo=new HashMap<String,Set<String>>();
  isRelatedTo.put(key,isRelatedToSet);
  entity.setIsRelatedToEntities(isRelatedTo);
  key="container";
  value="relates_to_entity_id_here";
  Set<String> relatesToSet=new HashSet<String>();
  relatesToSet.add(value);
  value="relates_to_entity_id_here_Second";
  relatesToSet.add(value);
  Map<String,Set<String>> relatesTo=new HashMap<String,Set<String>>();
  relatesTo.put(key,relatesToSet);
  entity.setRelatesToEntities(relatesTo);
  Map<String,String> conf=new HashMap<String,String>();
  conf.put("config_param1","value1");
  conf.put("config_param2","value2");
  entity.addConfigs(conf);
  Set<TimelineMetric> metrics=new HashSet<>();
  TimelineMetric m1=new TimelineMetric();
  m1.setId("MAP_SLOT_MILLIS");
  Map<Long,Number> metricValues=new HashMap<Long,Number>();
  long ts=System.currentTimeMillis();
  metricValues.put(ts - 120000,100000000);
  metricValues.put(ts - 100000,200000000);
  metricValues.put(ts - 80000,300000000);
  metricValues.put(ts - 60000,400000000);
  metricValues.put(ts - 40000,50000000000L);
  metricValues.put(ts - 20000,60000000000L);
  m1.setType(Type.TIME_SERIES);
  m1.setValues(metricValues);
  metrics.add(m1);
  entity.addMetrics(metrics);
  te.addEntity(entity);
  HBaseTimelineWriterImpl hbi=null;
  try {
    Configuration c1=util.getConfiguration();
    hbi=new HBaseTimelineWriterImpl(c1);
    hbi.init(c1);
    String cluster="cluster1";
    String user="user1";
    String flow="some_flow_name";
    String flowVersion="AB7822C10F1111";
    long runid=1002345678919L;
    String appName="some app name";
    hbi.write(cluster,user,flow,flowVersion,runid,appName,te);
    hbi.stop();
    Scan s=new Scan();
    byte[] startRow=TimelineWriterUtils.getRowKeyPrefix(cluster,user,flow,runid,appName);
    s.setStartRow(startRow);
    s.setMaxVersions(Integer.MAX_VALUE);
    ResultScanner scanner=null;
    TableName entityTableName=TableName.valueOf(TimelineEntitySchemaConstants.DEFAULT_ENTITY_TABLE_NAME);
    Connection conn=ConnectionFactory.createConnection(c1);
    Table entityTable=conn.getTable(entityTableName);
    int rowCount=0;
    int colCount=0;
    scanner=entityTable.getScanner(s);
    for (    Result result : scanner) {
      if (result != null && !result.isEmpty()) {
        rowCount++;
        colCount+=result.size();
        byte[] row1=result.getRow();
        assertTrue(isRowKeyCorrect(row1,cluster,user,flow,runid,appName,entity));
        NavigableMap<byte[],byte[]> infoValues=result.getFamilyMap(EntityColumnFamily.INFO.getInBytes());
        String id1=TimelineWriterUtils.getValueAsString(EntityColumnDetails.ID.getInBytes(),infoValues);
        assertEquals(id,id1);
        String type1=TimelineWriterUtils.getValueAsString(EntityColumnDetails.TYPE.getInBytes(),infoValues);
        assertEquals(type,type1);
        Long cTime1=TimelineWriterUtils.getValueAsLong(EntityColumnDetails.CREATED_TIME.getInBytes(),infoValues);
        assertEquals(cTime1,cTime);
        Long mTime1=TimelineWriterUtils.getValueAsLong(EntityColumnDetails.MODIFIED_TIME.getInBytes(),infoValues);
        assertEquals(mTime1,mTime);
        checkRelatedEntities(isRelatedTo,infoValues,EntityColumnDetails.PREFIX_IS_RELATED_TO.getInBytes());
        checkRelatedEntities(relatesTo,infoValues,EntityColumnDetails.PREFIX_RELATES_TO.getInBytes());
        NavigableMap<byte[],byte[]> configValuesResult=result.getFamilyMap(EntityColumnFamily.CONFIG.getInBytes());
        checkConfigs(configValuesResult,conf);
        NavigableMap<byte[],byte[]> metricsResult=result.getFamilyMap(EntityColumnFamily.METRICS.getInBytes());
        checkMetricsSizeAndKey(metricsResult,metrics);
        List<Cell> metricCells=result.getColumnCells(EntityColumnFamily.METRICS.getInBytes(),Bytes.toBytes(m1.getId()));
        checkMetricsTimeseries(metricCells,m1);
      }
    }
    assertEquals(1,rowCount);
    assertEquals(15,colCount);
  }
  finally {
    hbi.stop();
    hbi.close();
  }
}
