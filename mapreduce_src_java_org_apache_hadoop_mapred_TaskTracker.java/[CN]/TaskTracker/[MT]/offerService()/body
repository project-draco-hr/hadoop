{
  long lastHeartbeat=0;
  while (running && !shuttingDown) {
    try {
      long now=System.currentTimeMillis();
      long waitTime=heartbeatInterval - (now - lastHeartbeat);
      if (waitTime > 0) {
synchronized (finishedCount) {
          if (finishedCount.get() == 0) {
            finishedCount.wait(waitTime);
          }
          finishedCount.set(0);
        }
      }
      if (justInited) {
        String jobTrackerBV=jobClient.getBuildVersion();
        if (!VersionInfo.getBuildVersion().equals(jobTrackerBV)) {
          String msg="Shutting down. Incompatible buildVersion." + "\nJobTracker's: " + jobTrackerBV + "\nTaskTracker's: "+ VersionInfo.getBuildVersion();
          LOG.error(msg);
          try {
            jobClient.reportTaskTrackerError(taskTrackerName,null,msg);
          }
 catch (          Exception e) {
            LOG.info("Problem reporting to jobtracker: " + e);
          }
          return State.DENIED;
        }
        String dir=jobClient.getSystemDir();
        if (dir == null) {
          throw new IOException("Failed to get system directory");
        }
        systemDirectory=new Path(dir);
        systemFS=systemDirectory.getFileSystem(fConf);
      }
      HeartbeatResponse heartbeatResponse=transmitHeartBeat(now);
      lastHeartbeat=System.currentTimeMillis();
      TaskTrackerAction[] actions=heartbeatResponse.getActions();
      if (LOG.isDebugEnabled()) {
        LOG.debug("Got heartbeatResponse from JobTracker with responseId: " + heartbeatResponse.getResponseId() + " and "+ ((actions != null) ? actions.length : 0)+ " actions");
      }
      if (reinitTaskTracker(actions)) {
        return State.STALE;
      }
      heartbeatInterval=heartbeatResponse.getHeartbeatInterval();
      justStarted=false;
      justInited=false;
      if (actions != null) {
        for (        TaskTrackerAction action : actions) {
          if (action instanceof LaunchTaskAction) {
            addToTaskQueue((LaunchTaskAction)action);
          }
 else           if (action instanceof CommitTaskAction) {
            CommitTaskAction commitAction=(CommitTaskAction)action;
            if (!commitResponses.contains(commitAction.getTaskID())) {
              LOG.info("Received commit task action for " + commitAction.getTaskID());
              commitResponses.add(commitAction.getTaskID());
            }
          }
 else {
            tasksToCleanup.put(action);
          }
        }
      }
      markUnresponsiveTasks();
      killOverflowingTasks();
      if (!acceptNewTasks && isIdle()) {
        acceptNewTasks=true;
      }
      checkJettyPort(server.getPort());
    }
 catch (    InterruptedException ie) {
      LOG.info("Interrupted. Closing down.");
      return State.INTERRUPTED;
    }
catch (    DiskErrorException de) {
      String msg="Exiting task tracker for disk error:\n" + StringUtils.stringifyException(de);
      LOG.error(msg);
synchronized (this) {
        jobClient.reportTaskTrackerError(taskTrackerName,"DiskErrorException",msg);
      }
      return State.STALE;
    }
catch (    RemoteException re) {
      String reClass=re.getClassName();
      if (DisallowedTaskTrackerException.class.getName().equals(reClass)) {
        LOG.info("Tasktracker disallowed by JobTracker.");
        return State.DENIED;
      }
    }
catch (    Exception except) {
      String msg="Caught exception: " + StringUtils.stringifyException(except);
      LOG.error(msg);
    }
  }
  return State.NORMAL;
}
