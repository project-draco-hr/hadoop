{
  boolean sendAllCounters;
  if (now > (previousUpdate + COUNTER_UPDATE_INTERVAL)) {
    sendAllCounters=true;
    previousUpdate=now;
  }
 else {
    sendAllCounters=false;
  }
  if (status == null) {
synchronized (this) {
      status=new TaskTrackerStatus(taskTrackerName,localHostname,httpPort,cloneAndResetRunningTaskStatuses(sendAllCounters),failures,maxMapSlots,maxReduceSlots);
    }
  }
 else {
    LOG.info("Resending 'status' to '" + jobTrackAddr.getHostName() + "' with reponseId '"+ heartbeatResponseId);
  }
  boolean askForNewTask;
  long localMinSpaceStart;
synchronized (this) {
    askForNewTask=((status.countOccupiedMapSlots() < maxMapSlots || status.countOccupiedReduceSlots() < maxReduceSlots) && acceptNewTasks);
    localMinSpaceStart=minSpaceStart;
  }
  if (askForNewTask) {
    checkLocalDirs(fConf.getLocalDirs());
    askForNewTask=enoughFreeSpace(localMinSpaceStart);
    long freeDiskSpace=getFreeSpace();
    long totVmem=getTotalVirtualMemoryOnTT();
    long totPmem=getTotalPhysicalMemoryOnTT();
    long availableVmem=getAvailableVirtualMemoryOnTT();
    long availablePmem=getAvailablePhysicalMemoryOnTT();
    long cumuCpuTime=getCumulativeCpuTimeOnTT();
    long cpuFreq=getCpuFrequencyOnTT();
    int numCpu=getNumProcessorsOnTT();
    float cpuUsage=getCpuUsageOnTT();
    status.getResourceStatus().setAvailableSpace(freeDiskSpace);
    status.getResourceStatus().setTotalVirtualMemory(totVmem);
    status.getResourceStatus().setTotalPhysicalMemory(totPmem);
    status.getResourceStatus().setMapSlotMemorySizeOnTT(mapSlotMemorySizeOnTT);
    status.getResourceStatus().setReduceSlotMemorySizeOnTT(reduceSlotSizeMemoryOnTT);
    status.getResourceStatus().setAvailableVirtualMemory(availableVmem);
    status.getResourceStatus().setAvailablePhysicalMemory(availablePmem);
    status.getResourceStatus().setCumulativeCpuTime(cumuCpuTime);
    status.getResourceStatus().setCpuFrequency(cpuFreq);
    status.getResourceStatus().setNumProcessors(numCpu);
    status.getResourceStatus().setCpuUsage(cpuUsage);
  }
  TaskTrackerHealthStatus healthStatus=status.getHealthStatus();
synchronized (this) {
    if (healthChecker != null) {
      healthChecker.setHealthStatus(healthStatus);
    }
 else {
      healthStatus.setNodeHealthy(true);
      healthStatus.setLastReported(0L);
      healthStatus.setHealthReport("");
    }
  }
  HeartbeatResponse heartbeatResponse=jobClient.heartbeat(status,justStarted,justInited,askForNewTask,heartbeatResponseId);
  heartbeatResponseId=heartbeatResponse.getResponseId();
synchronized (this) {
    for (    TaskStatus taskStatus : status.getTaskReports()) {
      if (taskStatus.getRunState() != TaskStatus.State.RUNNING && taskStatus.getRunState() != TaskStatus.State.UNASSIGNED && taskStatus.getRunState() != TaskStatus.State.COMMIT_PENDING && !taskStatus.inTaskCleanupPhase()) {
        if (taskStatus.getIsMap()) {
          mapTotal--;
        }
 else {
          reduceTotal--;
        }
        try {
          myInstrumentation.completeTask(taskStatus.getTaskID());
        }
 catch (        MetricsException me) {
          LOG.warn("Caught: " + StringUtils.stringifyException(me));
        }
        runningTasks.remove(taskStatus.getTaskID());
      }
    }
    for (    TaskInProgress tip : runningTasks.values()) {
      tip.getStatus().clearStatus();
    }
  }
  status=null;
  return heartbeatResponse;
}
