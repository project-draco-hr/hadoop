{
  DatanodeCommand cmd=null;
  long startTime=now();
  if (startTime - lastBlockReport > dnConf.blockReportInterval) {
    reportReceivedDeletedBlocks();
    long brCreateStartTime=now();
    long totalBlockCount=0;
    Map<String,BlockListAsLongs> perVolumeBlockLists=dn.getFSDataset().getBlockReports(bpos.getBlockPoolId());
    long brSendStartTime=now();
    StorageBlockReport[] reports=new StorageBlockReport[perVolumeBlockLists.size()];
    int i=0;
    for (    Map.Entry<String,BlockListAsLongs> kvPair : perVolumeBlockLists.entrySet()) {
      String storageID=kvPair.getKey();
      BlockListAsLongs blockList=kvPair.getValue();
      totalBlockCount+=blockList.getNumberOfBlocks();
      DatanodeStorage dnStorage=new DatanodeStorage(storageID);
      reports[i++]=new StorageBlockReport(dnStorage,blockList.getBlockListAsLongs());
    }
    cmd=bpNamenode.blockReport(bpRegistration,bpos.getBlockPoolId(),reports);
    long brSendCost=now() - brSendStartTime;
    long brCreateCost=brSendStartTime - brCreateStartTime;
    dn.getMetrics().addBlockReport(brSendCost);
    LOG.info("BlockReport of " + totalBlockCount + " blocks took "+ brCreateCost+ " msec to generate and "+ brSendCost+ " msecs for RPC and NN processing");
    if (resetBlockReportTime) {
      lastBlockReport=startTime - DFSUtil.getRandom().nextInt((int)(dnConf.blockReportInterval));
      resetBlockReportTime=false;
    }
 else {
      lastBlockReport+=(now() - lastBlockReport) / dnConf.blockReportInterval * dnConf.blockReportInterval;
    }
    LOG.info("sent block report, processed command:" + cmd);
  }
  return cmd;
}
