{
  long totalCapacity=0;
  long totalRemaining=0;
  long totalBlockPoolUsed=0;
  long totalDfsUsed=0;
  Set<DatanodeStorageInfo> failedStorageInfos=null;
  boolean checkFailedStorages=(volFailures > this.volumeFailures) || !heartbeatedSinceRegistration;
  if (checkFailedStorages) {
    LOG.info("Number of failed storage changes from " + this.volumeFailures + " to "+ volFailures);
    failedStorageInfos=new HashSet<DatanodeStorageInfo>(storageMap.values());
  }
  setCacheCapacity(cacheCapacity);
  setCacheUsed(cacheUsed);
  setXceiverCount(xceiverCount);
  setLastUpdate(Time.now());
  this.volumeFailures=volFailures;
  for (  StorageReport report : reports) {
    DatanodeStorageInfo storage=updateStorage(report.getStorage());
    if (checkFailedStorages) {
      failedStorageInfos.remove(storage);
    }
    storage.receivedHeartbeat(report);
    totalCapacity+=report.getCapacity();
    totalRemaining+=report.getRemaining();
    totalBlockPoolUsed+=report.getBlockPoolUsed();
    totalDfsUsed+=report.getDfsUsed();
  }
  rollBlocksScheduled(getLastUpdate());
  setCapacity(totalCapacity);
  setRemaining(totalRemaining);
  setBlockPoolUsed(totalBlockPoolUsed);
  setDfsUsed(totalDfsUsed);
  if (checkFailedStorages) {
    updateFailedStorage(failedStorageInfos);
  }
  if (storageMap.size() != reports.length) {
    pruneStorageMap(reports);
  }
}
