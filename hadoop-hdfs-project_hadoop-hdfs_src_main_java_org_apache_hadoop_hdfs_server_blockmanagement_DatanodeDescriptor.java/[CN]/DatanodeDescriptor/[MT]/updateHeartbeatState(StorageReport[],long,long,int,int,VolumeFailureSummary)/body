{
  long totalCapacity=0;
  long totalRemaining=0;
  long totalBlockPoolUsed=0;
  long totalDfsUsed=0;
  long totalNonDfsUsed=0;
  Set<DatanodeStorageInfo> failedStorageInfos=null;
  final boolean checkFailedStorages;
  if (volumeFailureSummary != null && this.volumeFailureSummary != null) {
    checkFailedStorages=volumeFailureSummary.getLastVolumeFailureDate() > this.volumeFailureSummary.getLastVolumeFailureDate();
  }
 else {
    checkFailedStorages=(volFailures > this.volumeFailures) || !heartbeatedSinceRegistration;
  }
  if (checkFailedStorages) {
    if (this.volumeFailures != volFailures) {
      LOG.info("Number of failed storages changes from {} to {}",this.volumeFailures,volFailures);
    }
synchronized (storageMap) {
      failedStorageInfos=new HashSet<>(storageMap.values());
    }
  }
  setCacheCapacity(cacheCapacity);
  setCacheUsed(cacheUsed);
  setXceiverCount(xceiverCount);
  setLastUpdate(Time.now());
  setLastUpdateMonotonic(Time.monotonicNow());
  this.volumeFailures=volFailures;
  this.volumeFailureSummary=volumeFailureSummary;
  for (  StorageReport report : reports) {
    DatanodeStorageInfo storage=updateStorage(report.getStorage());
    if (checkFailedStorages) {
      failedStorageInfos.remove(storage);
    }
    storage.receivedHeartbeat(report);
    totalCapacity+=report.getCapacity();
    totalRemaining+=report.getRemaining();
    totalBlockPoolUsed+=report.getBlockPoolUsed();
    totalDfsUsed+=report.getDfsUsed();
    totalNonDfsUsed+=report.getNonDfsUsed();
  }
  rollBlocksScheduled(getLastUpdateMonotonic());
  setCapacity(totalCapacity);
  setRemaining(totalRemaining);
  setBlockPoolUsed(totalBlockPoolUsed);
  setDfsUsed(totalDfsUsed);
  setNonDfsUsed(totalNonDfsUsed);
  if (checkFailedStorages) {
    updateFailedStorage(failedStorageInfos);
  }
  long storageMapSize;
synchronized (storageMap) {
    storageMapSize=storageMap.size();
  }
  if (storageMapSize != reports.length) {
    pruneStorageMap(reports);
  }
}
