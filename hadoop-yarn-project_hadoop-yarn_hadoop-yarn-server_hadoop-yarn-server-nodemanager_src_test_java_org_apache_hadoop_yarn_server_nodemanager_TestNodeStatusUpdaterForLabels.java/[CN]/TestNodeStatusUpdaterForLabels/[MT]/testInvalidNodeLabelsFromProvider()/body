{
  final ResourceTrackerForLabels resourceTracker=new ResourceTrackerForLabels();
  nm=new NodeManager(){
    @Override protected NodeLabelsProvider createNodeLabelsProvider(    Configuration conf) throws IOException {
      return dummyLabelsProviderRef;
    }
    @Override protected NodeStatusUpdater createNodeStatusUpdater(    Context context,    Dispatcher dispatcher,    NodeHealthCheckerService healthChecker,    NodeLabelsProvider labelsProvider){
      return new NodeStatusUpdaterImpl(context,dispatcher,healthChecker,metrics,labelsProvider){
        @Override protected ResourceTracker getRMClient(){
          return resourceTracker;
        }
        @Override protected void stopRMProxy(){
          return;
        }
      }
;
    }
  }
;
  dummyLabelsProviderRef.setNodeLabels(toNodeLabelSet("P"));
  YarnConfiguration conf=createNMConfigForDistributeNodeLabels();
  nm.init(conf);
  resourceTracker.resetNMHeartbeatReceiveFlag();
  nm.start();
  resourceTracker.waitTillHeartbeat();
  resourceTracker.resetNMHeartbeatReceiveFlag();
  dummyLabelsProviderRef.setNodeLabels(toNodeLabelSet("_.P"));
  nm.getNodeStatusUpdater().sendOutofBandHeartBeat();
  resourceTracker.waitTillHeartbeat();
  assertNull("On Invalid Labels we need to retain earlier labels, HB " + "needs to send null",resourceTracker.labels);
  resourceTracker.resetNMHeartbeatReceiveFlag();
  nm.getNodeStatusUpdater().sendOutofBandHeartBeat();
  resourceTracker.waitTillHeartbeat();
  resourceTracker.resetNMHeartbeatReceiveFlag();
  assertNull("NodeStatusUpdater need not send repeatedly empty labels on " + "invalid labels from provider ",resourceTracker.labels);
}
