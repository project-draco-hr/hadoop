{
  READ3Response response=new READ3Response(Nfs3Status.NFS3_OK);
  final String userName=securityHandler.getUser();
  if (!checkAccessPrivilege(remoteAddress,AccessPrivilege.READ_ONLY)) {
    response.setStatus(Nfs3Status.NFS3ERR_ACCES);
    return response;
  }
  DFSClient dfsClient=clientCache.getDfsClient(userName);
  if (dfsClient == null) {
    response.setStatus(Nfs3Status.NFS3ERR_SERVERFAULT);
    return response;
  }
  READ3Request request;
  try {
    request=READ3Request.deserialize(xdr);
  }
 catch (  IOException e) {
    LOG.error("Invalid READ request");
    return new READ3Response(Nfs3Status.NFS3ERR_INVAL);
  }
  long offset=request.getOffset();
  int count=request.getCount();
  FileHandle handle=request.getHandle();
  if (LOG.isDebugEnabled()) {
    LOG.debug("NFS READ fileId: " + handle.getFileId() + " offset: "+ offset+ " count: "+ count+ " client:"+ remoteAddress);
  }
  Nfs3FileAttributes attrs;
  boolean eof;
  if (count == 0) {
    try {
      attrs=Nfs3Utils.getFileAttr(dfsClient,Nfs3Utils.getFileIdPath(handle),iug);
    }
 catch (    IOException e) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Get error accessing file, fileId:" + handle.getFileId(),e);
      }
      return new READ3Response(Nfs3Status.NFS3ERR_IO);
    }
    if (attrs == null) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Can't get path for fileId:" + handle.getFileId());
      }
      return new READ3Response(Nfs3Status.NFS3ERR_NOENT);
    }
    int access=Nfs3Utils.getAccessRightsForUserGroup(securityHandler.getUid(),securityHandler.getGid(),securityHandler.getAuxGids(),attrs);
    if ((access & Nfs3Constant.ACCESS3_READ) != 0) {
      eof=offset >= attrs.getSize();
      return new READ3Response(Nfs3Status.NFS3_OK,attrs,0,eof,ByteBuffer.wrap(new byte[0]));
    }
 else {
      return new READ3Response(Nfs3Status.NFS3ERR_ACCES);
    }
  }
  int ret=writeManager.commitBeforeRead(dfsClient,handle,offset + count);
  if (ret != Nfs3Status.NFS3_OK) {
    LOG.warn("commitBeforeRead didn't succeed with ret=" + ret + ". Read may not get most recent data.");
  }
  try {
    int rtmax=config.getInt(NfsConfigKeys.DFS_NFS_MAX_READ_TRANSFER_SIZE_KEY,NfsConfigKeys.DFS_NFS_MAX_READ_TRANSFER_SIZE_DEFAULT);
    int buffSize=Math.min(rtmax,count);
    byte[] readbuffer=new byte[buffSize];
    int readCount=0;
    for (int i=0; i < 1; ++i) {
      FSDataInputStream fis=clientCache.getDfsInputStream(userName,Nfs3Utils.getFileIdPath(handle));
      if (fis == null) {
        return new READ3Response(Nfs3Status.NFS3ERR_ACCES);
      }
      try {
        readCount=fis.read(offset,readbuffer,0,count);
        metrics.incrBytesRead(readCount);
      }
 catch (      IOException e) {
        if (e.getMessage().equals("Stream closed")) {
          clientCache.invalidateDfsInputStream(userName,Nfs3Utils.getFileIdPath(handle));
          continue;
        }
 else {
          throw e;
        }
      }
    }
    attrs=Nfs3Utils.getFileAttr(dfsClient,Nfs3Utils.getFileIdPath(handle),iug);
    if (readCount < count) {
      LOG.info("Partical read. Asked offset:" + offset + " count:"+ count+ " and read back:"+ readCount+ "file size:"+ attrs.getSize());
    }
    if (readCount < 0) {
      readCount=0;
    }
    eof=(offset + readCount) >= attrs.getSize();
    return new READ3Response(Nfs3Status.NFS3_OK,attrs,readCount,eof,ByteBuffer.wrap(readbuffer));
  }
 catch (  IOException e) {
    LOG.warn("Read error: " + e.getClass() + " offset: "+ offset+ " count: "+ count,e);
    int status=mapErrorStatus(e);
    return new READ3Response(status);
  }
}
