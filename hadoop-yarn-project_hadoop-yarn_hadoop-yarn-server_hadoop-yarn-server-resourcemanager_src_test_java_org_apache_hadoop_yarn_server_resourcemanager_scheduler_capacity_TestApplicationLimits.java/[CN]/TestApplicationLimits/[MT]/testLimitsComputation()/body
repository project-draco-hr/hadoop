{
  CapacitySchedulerConfiguration csConf=new CapacitySchedulerConfiguration();
  setupQueueConfiguration(csConf);
  YarnConfiguration conf=new YarnConfiguration();
  CapacitySchedulerContext csContext=mock(CapacitySchedulerContext.class);
  when(csContext.getConfiguration()).thenReturn(csConf);
  when(csContext.getConf()).thenReturn(conf);
  when(csContext.getMinimumResourceCapability()).thenReturn(Resources.createResource(GB,1));
  when(csContext.getMaximumResourceCapability()).thenReturn(Resources.createResource(16 * GB,16));
  when(csContext.getApplicationComparator()).thenReturn(CapacityScheduler.applicationComparator);
  when(csContext.getQueueComparator()).thenReturn(CapacityScheduler.queueComparator);
  when(csContext.getResourceCalculator()).thenReturn(resourceCalculator);
  Resource clusterResource=Resources.createResource(100 * 16 * GB,100 * 16);
  when(csContext.getClusterResources()).thenReturn(clusterResource);
  Map<String,CSQueue> queues=new HashMap<String,CSQueue>();
  CSQueue root=CapacityScheduler.parseQueue(csContext,csConf,null,"root",queues,queues,TestUtils.spyHook);
  LeafQueue queue=(LeafQueue)queues.get(A);
  LOG.info("Queue 'A' -" + " maxActiveApplications=" + queue.getMaximumActiveApplications() + " maxActiveApplicationsPerUser="+ queue.getMaximumActiveApplicationsPerUser());
  int expectedMaxActiveApps=Math.max(1,(int)Math.ceil(((float)clusterResource.getMemory() / (1 * GB)) * csConf.getMaximumApplicationMasterResourcePerQueuePercent(queue.getQueuePath()) * queue.getAbsoluteMaximumCapacity()));
  assertEquals(expectedMaxActiveApps,queue.getMaximumActiveApplications());
  int expectedMaxActiveAppsUsingAbsCap=Math.max(1,(int)Math.ceil(((float)clusterResource.getMemory() / (1 * GB)) * csConf.getMaximumApplicationMasterResourcePercent() * queue.getAbsoluteCapacity()));
  assertEquals((int)Math.ceil(expectedMaxActiveAppsUsingAbsCap * (queue.getUserLimit() / 100.0f) * queue.getUserLimitFactor()),queue.getMaximumActiveApplicationsPerUser());
  assertEquals((int)(clusterResource.getMemory() * queue.getAbsoluteCapacity()),queue.getMetrics().getAvailableMB());
  clusterResource=Resources.createResource(120 * 16 * GB);
  root.updateClusterResource(clusterResource);
  expectedMaxActiveApps=Math.max(1,(int)Math.ceil(((float)clusterResource.getMemory() / (1 * GB)) * csConf.getMaximumApplicationMasterResourcePerQueuePercent(queue.getQueuePath()) * queue.getAbsoluteMaximumCapacity()));
  assertEquals(expectedMaxActiveApps,queue.getMaximumActiveApplications());
  expectedMaxActiveAppsUsingAbsCap=Math.max(1,(int)Math.ceil(((float)clusterResource.getMemory() / (1 * GB)) * csConf.getMaximumApplicationMasterResourcePercent() * queue.getAbsoluteCapacity()));
  assertEquals((int)Math.ceil(expectedMaxActiveAppsUsingAbsCap * (queue.getUserLimit() / 100.0f) * queue.getUserLimitFactor()),queue.getMaximumActiveApplicationsPerUser());
  assertEquals((int)(clusterResource.getMemory() * queue.getAbsoluteCapacity()),queue.getMetrics().getAvailableMB());
  assertEquals((int)CapacitySchedulerConfiguration.UNDEFINED,csConf.getMaximumApplicationsPerQueue(queue.getQueuePath()));
  int expectedMaxApps=(int)(CapacitySchedulerConfiguration.DEFAULT_MAXIMUM_SYSTEM_APPLICATIIONS * queue.getAbsoluteCapacity());
  assertEquals(expectedMaxApps,queue.getMaxApplications());
  int expectedMaxAppsPerUser=(int)(expectedMaxApps * (queue.getUserLimit() / 100.0f) * queue.getUserLimitFactor());
  assertEquals(expectedMaxAppsPerUser,queue.getMaxApplicationsPerUser());
  assertEquals((long)CapacitySchedulerConfiguration.DEFAULT_MAXIMUM_APPLICATIONMASTERS_RESOURCE_PERCENT,(long)csConf.getMaximumApplicationMasterResourcePerQueuePercent(queue.getQueuePath()));
  csConf.setFloat("yarn.scheduler.capacity." + queue.getQueuePath() + ".maximum-am-resource-percent",0.5f);
  queues=new HashMap<String,CSQueue>();
  root=CapacityScheduler.parseQueue(csContext,csConf,null,"root",queues,queues,TestUtils.spyHook);
  clusterResource=Resources.createResource(100 * 16 * GB);
  queue=(LeafQueue)queues.get(A);
  expectedMaxActiveApps=Math.max(1,(int)Math.ceil(((float)clusterResource.getMemory() / (1 * GB)) * csConf.getMaximumApplicationMasterResourcePerQueuePercent(queue.getQueuePath()) * queue.getAbsoluteMaximumCapacity()));
  assertEquals((long)0.5,(long)csConf.getMaximumApplicationMasterResourcePerQueuePercent(queue.getQueuePath()));
  assertEquals(expectedMaxActiveApps,queue.getMaximumActiveApplications());
  csConf.setInt("yarn.scheduler.capacity." + queue.getQueuePath() + ".maximum-applications",9999);
  queues=new HashMap<String,CSQueue>();
  root=CapacityScheduler.parseQueue(csContext,csConf,null,"root",queues,queues,TestUtils.spyHook);
  queue=(LeafQueue)queues.get(A);
  assertEquals(9999,(int)csConf.getMaximumApplicationsPerQueue(queue.getQueuePath()));
  assertEquals(9999,queue.getMaxApplications());
  expectedMaxAppsPerUser=(int)(9999 * (queue.getUserLimit() / 100.0f) * queue.getUserLimitFactor());
  assertEquals(expectedMaxAppsPerUser,queue.getMaxApplicationsPerUser());
}
