{
  boolean syncFolder=(option == DistCpOptionSwitch.SYNC_FOLDERS ? value : this.syncFolder);
  boolean overwrite=(option == DistCpOptionSwitch.OVERWRITE ? value : this.overwrite);
  boolean deleteMissing=(option == DistCpOptionSwitch.DELETE_MISSING ? value : this.deleteMissing);
  boolean atomicCommit=(option == DistCpOptionSwitch.ATOMIC_COMMIT ? value : this.atomicCommit);
  boolean skipCRC=(option == DistCpOptionSwitch.SKIP_CRC ? value : this.skipCRC);
  boolean append=(option == DistCpOptionSwitch.APPEND ? value : this.append);
  if (syncFolder && atomicCommit) {
    throw new IllegalArgumentException("Atomic commit can't be used with " + "sync folder or overwrite options");
  }
  if (deleteMissing && !(overwrite || syncFolder)) {
    throw new IllegalArgumentException("Delete missing is applicable " + "only with update or overwrite options");
  }
  if (overwrite && syncFolder) {
    throw new IllegalArgumentException("Overwrite and update options are " + "mutually exclusive");
  }
  if (!syncFolder && skipCRC) {
    throw new IllegalArgumentException("Skip CRC is valid only with update options");
  }
  if (!syncFolder && append) {
    throw new IllegalArgumentException("Append is valid only with update options");
  }
  if (skipCRC && append) {
    throw new IllegalArgumentException("Append is disallowed when skipping CRC");
  }
}
