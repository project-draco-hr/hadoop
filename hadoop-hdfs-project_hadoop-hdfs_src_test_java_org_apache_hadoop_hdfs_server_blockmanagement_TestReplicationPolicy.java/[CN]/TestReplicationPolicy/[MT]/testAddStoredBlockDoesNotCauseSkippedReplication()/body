{
  FSNamesystem mockNS=mock(FSNamesystem.class);
  when(mockNS.hasWriteLock()).thenReturn(true);
  when(mockNS.hasReadLock()).thenReturn(true);
  BlockManager bm=new BlockManager(mockNS,false,new HdfsConfiguration());
  LowRedundancyBlocks lowRedundancyBlocks=bm.neededReconstruction;
  BlockInfo block1=genBlockInfo(ThreadLocalRandom.current().nextLong());
  BlockInfo block2=genBlockInfo(ThreadLocalRandom.current().nextLong());
  lowRedundancyBlocks.add(block1,0,0,1,1);
  lowRedundancyBlocks.add(block2,0,0,1,1);
  List<List<BlockInfo>> chosenBlocks;
  chosenBlocks=lowRedundancyBlocks.chooseLowRedundancyBlocks(1);
  assertTheChosenBlocks(chosenBlocks,1,0,0,0,0);
  BlockInfoContiguous info=new BlockInfoContiguous(block1,(short)1);
  info.convertToBlockUnderConstruction(BlockUCState.UNDER_CONSTRUCTION,null);
  info.setBlockCollectionId(1000L);
  final INodeFile file=TestINodeFile.createINodeFile(1000L);
  when(mockNS.getBlockCollection(1000L)).thenReturn(file);
  bm.addBlockCollection(info,file);
  bm.addStoredBlockUnderConstruction(new StatefulBlockInfo(info,info,ReplicaState.FINALIZED),storages[0]);
  chosenBlocks=lowRedundancyBlocks.chooseLowRedundancyBlocks(1);
  assertTheChosenBlocks(chosenBlocks,1,0,0,0,0);
}
