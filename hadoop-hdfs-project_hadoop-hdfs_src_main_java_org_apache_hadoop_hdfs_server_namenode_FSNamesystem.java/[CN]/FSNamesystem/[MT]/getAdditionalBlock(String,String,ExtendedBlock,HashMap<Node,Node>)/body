{
  checkBlock(previous);
  Block previousBlock=ExtendedBlock.getLocalBlock(previous);
  long fileLength, blockSize;
  int replication;
  DatanodeDescriptor clientNode=null;
  Block newBlock=null;
  if (NameNode.stateChangeLog.isDebugEnabled()) {
    NameNode.stateChangeLog.debug("BLOCK* NameSystem.getAdditionalBlock: file " + src + " for "+ clientName);
  }
  writeLock();
  try {
    checkOperation(OperationCategory.WRITE);
    if (isInSafeMode()) {
      throw new SafeModeException("Cannot add block to " + src,safeMode);
    }
    checkFsObjectLimit();
    INodeFileUnderConstruction pendingFile=checkLease(src,clientName);
    BlockInfo lastBlockInFile=pendingFile.getLastBlock();
    if (!Block.matchingIdAndGenStamp(previousBlock,lastBlockInFile)) {
      BlockInfo penultimateBlock=pendingFile.getPenultimateBlock();
      if (previous == null && lastBlockInFile != null && lastBlockInFile.getNumBytes() == pendingFile.getPreferredBlockSize() && lastBlockInFile.isComplete()) {
        if (NameNode.stateChangeLog.isDebugEnabled()) {
          NameNode.stateChangeLog.debug("BLOCK* NameSystem.allocateBlock: handling block allocation" + " writing to a file with a complete previous block: src=" + src + " lastBlock="+ lastBlockInFile);
        }
      }
 else       if (Block.matchingIdAndGenStamp(penultimateBlock,previousBlock)) {
        if (lastBlockInFile.getNumBytes() != 0) {
          throw new IOException("Request looked like a retry to allocate block " + lastBlockInFile + " but it already contains "+ lastBlockInFile.getNumBytes()+ " bytes");
        }
        NameNode.stateChangeLog.info("BLOCK* NameSystem.allocateBlock: " + "caught retry for allocation of a new block in " + src + ". Abandoning old block "+ lastBlockInFile);
        dir.removeBlock(src,pendingFile,lastBlockInFile);
        dir.persistBlocks(src,pendingFile);
      }
 else {
        throw new IOException("Cannot allocate block in " + src + ": "+ "passed 'previous' block "+ previous+ " does not match actual "+ "last block in file "+ lastBlockInFile);
      }
    }
    commitOrCompleteLastBlock(pendingFile,previousBlock);
    if (!checkFileProgress(pendingFile,false)) {
      throw new NotReplicatedYetException("Not replicated yet:" + src);
    }
    fileLength=pendingFile.computeContentSummary().getLength();
    blockSize=pendingFile.getPreferredBlockSize();
    clientNode=pendingFile.getClientNode();
    replication=pendingFile.getBlockReplication();
  }
  finally {
    writeUnlock();
  }
  final DatanodeDescriptor targets[]=blockManager.chooseTarget(src,replication,clientNode,excludedNodes,blockSize);
  writeLock();
  try {
    checkOperation(OperationCategory.WRITE);
    if (isInSafeMode()) {
      throw new SafeModeException("Cannot add block to " + src,safeMode);
    }
    INode[] pathINodes=dir.getExistingPathINodes(src);
    int inodesLen=pathINodes.length;
    checkLease(src,clientName,pathINodes[inodesLen - 1]);
    INodeFileUnderConstruction pendingFile=(INodeFileUnderConstruction)pathINodes[inodesLen - 1];
    if (!checkFileProgress(pendingFile,false)) {
      throw new NotReplicatedYetException("Not replicated yet:" + src);
    }
    newBlock=allocateBlock(src,pathINodes,targets);
    for (    DatanodeDescriptor dn : targets) {
      dn.incBlocksScheduled();
    }
    dir.persistBlocks(src,pendingFile);
  }
  finally {
    writeUnlock();
  }
  if (persistBlocks) {
    getEditLog().logSync();
  }
  LocatedBlock b=new LocatedBlock(getExtendedBlock(newBlock),targets,fileLength);
  blockManager.setBlockToken(b,BlockTokenSecretManager.AccessMode.WRITE);
  return b;
}
