{
  LOG.info("Starting services required for active state");
  writeLock();
  try {
    FSEditLog editLog=dir.fsImage.getEditLog();
    if (!editLog.isOpenForWrite()) {
      editLog.initJournalsForWrite();
      editLog.recoverUnclosedStreams();
      LOG.info("Catching up to latest edits from old active before " + "taking over writer role in edits logs");
      editLogTailer.catchupDuringFailover();
      blockManager.setPostponeBlocksFromFuture(false);
      blockManager.getDatanodeManager().markAllDatanodesStale();
      blockManager.clearQueues();
      blockManager.processAllPendingDNMessages();
      if (!isInSafeMode() || (isInSafeMode() && safeMode.isPopulatingReplQueues())) {
        LOG.info("Reprocessing replication and invalidation queues");
        blockManager.processMisReplicatedBlocks();
      }
      if (LOG.isDebugEnabled()) {
        LOG.debug("NameNode metadata after re-processing " + "replication and invalidation queues during failover:\n" + metaSaveAsString());
      }
      long nextTxId=dir.fsImage.getLastAppliedTxId() + 1;
      LOG.info("Will take over writing edit logs at txnid " + nextTxId);
      editLog.setNextTxId(nextTxId);
      dir.fsImage.editLog.openForWrite();
    }
    if (haEnabled) {
      leaseManager.renewAllLeases();
    }
    leaseManager.startMonitor();
    startSecretManagerIfNecessary();
    this.nnrmthread=new Daemon(new NameNodeResourceMonitor());
    nnrmthread.start();
    cacheManager.activate();
    blockManager.getDatanodeManager().setSendCachingCommands(true);
  }
  finally {
    writeUnlock();
  }
}
