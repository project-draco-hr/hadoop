{
  startingActiveService=true;
  LOG.info("Starting services required for active state");
  writeLock();
  try {
    FSEditLog editLog=getFSImage().getEditLog();
    if (!editLog.isOpenForWrite()) {
      editLog.initJournalsForWrite();
      editLog.recoverUnclosedStreams();
      LOG.info("Catching up to latest edits from old active before " + "taking over writer role in edits logs");
      editLogTailer.catchupDuringFailover();
      blockManager.setPostponeBlocksFromFuture(false);
      blockManager.getDatanodeManager().markAllDatanodesStale();
      blockManager.clearQueues();
      blockManager.processAllPendingDNMessages();
      if (!isInSafeMode()) {
        LOG.info("Reprocessing replication and invalidation queues");
        initializeReplQueues();
      }
      if (LOG.isDebugEnabled()) {
        LOG.debug("NameNode metadata after re-processing " + "replication and invalidation queues during failover:\n" + metaSaveAsString());
      }
      long nextTxId=getFSImage().getLastAppliedTxId() + 1;
      LOG.info("Will take over writing edit logs at txnid " + nextTxId);
      editLog.setNextTxId(nextTxId);
      getFSImage().editLog.openForWrite();
    }
    dir.enableQuotaChecks();
    if (haEnabled) {
      leaseManager.renewAllLeases();
    }
    leaseManager.startMonitor();
    startSecretManagerIfNecessary();
    this.nnrmthread=new Daemon(new NameNodeResourceMonitor());
    nnrmthread.start();
    nnEditLogRoller=new Daemon(new NameNodeEditLogRoller(editLogRollerThreshold,editLogRollerInterval));
    nnEditLogRoller.start();
    if (lazyPersistFileScrubIntervalSec > 0) {
      lazyPersistFileScrubber=new Daemon(new LazyPersistFileScrubber(lazyPersistFileScrubIntervalSec));
      lazyPersistFileScrubber.start();
    }
    cacheManager.startMonitorThread();
    blockManager.getDatanodeManager().setShouldSendCachingCommands(true);
  }
  finally {
    startingActiveService=false;
    checkSafeMode();
    writeUnlock();
  }
}
