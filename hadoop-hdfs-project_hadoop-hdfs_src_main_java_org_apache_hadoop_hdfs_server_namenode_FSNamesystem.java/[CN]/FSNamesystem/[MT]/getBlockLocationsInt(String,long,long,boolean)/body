{
  String src=srcArg;
  FSPermissionChecker pc=getPermissionChecker();
  byte[][] pathComponents=FSDirectory.getPathComponentsForReservedPath(src);
  src=dir.resolvePath(pc,src,pathComponents);
  final INodesInPath iip=dir.getINodesInPath(src,true);
  final INodeFile inode=INodeFile.valueOf(iip.getLastINode(),src);
  if (isPermissionEnabled) {
    dir.checkPathAccess(pc,iip,FsAction.READ);
    checkUnreadableBySuperuser(pc,inode,iip.getPathSnapshotId());
  }
  final long fileSize=iip.isSnapshot() ? inode.computeFileSize(iip.getPathSnapshotId()) : inode.computeFileSizeNotIncludingLastUcBlock();
  boolean isUc=inode.isUnderConstruction();
  if (iip.isSnapshot()) {
    length=Math.min(length,fileSize - offset);
    isUc=false;
  }
  final FileEncryptionInfo feInfo=FSDirectory.isReservedRawName(srcArg) ? null : dir.getFileEncryptionInfo(inode,iip.getPathSnapshotId(),iip);
  final LocatedBlocks blocks=blockManager.createLocatedBlocks(inode.getBlocks(iip.getPathSnapshotId()),fileSize,isUc,offset,length,needBlockToken,iip.isSnapshot(),feInfo);
  for (  LocatedBlock lb : blocks.getLocatedBlocks()) {
    cacheManager.setCachedLocations(lb);
  }
  final long now=now();
  boolean updateAccessTime=isAccessTimeSupported() && !isInSafeMode() && !iip.isSnapshot()&& now > inode.getAccessTime() + getAccessTimePrecision();
  return new GetBlockLocationsResult(updateAccessTime ? iip : null,blocks);
}
