{
  BlocksMapUpdateInfo collectedBlocks=new BlocksMapUpdateInfo();
  List<INode> removedINodes=new ChunkedArrayList<INode>();
  FSPermissionChecker pc=getPermissionChecker();
  checkOperation(OperationCategory.WRITE);
  byte[][] pathComponents=FSDirectory.getPathComponentsForReservedPath(src);
  boolean ret=false;
  waitForLoadingFSImage();
  writeLock();
  try {
    checkOperation(OperationCategory.WRITE);
    checkNameNodeSafeMode("Cannot delete " + src);
    src=FSDirectory.resolvePath(src,pathComponents,dir);
    if (!recursive && dir.isNonEmptyDirectory(src)) {
      throw new PathIsNotEmptyDirectoryException(src + " is non empty");
    }
    if (enforcePermission && isPermissionEnabled) {
      checkPermission(pc,src,false,null,FsAction.WRITE,null,FsAction.ALL,true,false);
    }
    final EncryptionZone ez=getEncryptionZoneForPath(src);
    if (ez != null) {
      encryptionZones.remove(src);
    }
    long mtime=now();
    long filesRemoved=dir.delete(src,collectedBlocks,removedINodes,mtime);
    if (filesRemoved < 0) {
      return false;
    }
    getEditLog().logDelete(src,mtime,logRetryCache);
    incrDeletedFileCount(filesRemoved);
    removePathAndBlocks(src,null,null);
    ret=true;
  }
  finally {
    writeUnlock();
  }
  getEditLog().logSync();
  removeBlocks(collectedBlocks);
  collectedBlocks.clear();
  dir.writeLock();
  try {
    dir.removeFromInodeMap(removedINodes);
  }
  finally {
    dir.writeUnlock();
  }
  removedINodes.clear();
  if (NameNode.stateChangeLog.isDebugEnabled()) {
    NameNode.stateChangeLog.debug("DIR* Namesystem.delete: " + src + " is removed");
  }
  return ret;
}
