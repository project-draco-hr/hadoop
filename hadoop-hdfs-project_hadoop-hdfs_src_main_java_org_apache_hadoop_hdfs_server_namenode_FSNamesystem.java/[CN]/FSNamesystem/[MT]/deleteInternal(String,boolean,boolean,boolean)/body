{
  BlocksMapUpdateInfo collectedBlocks=new BlocksMapUpdateInfo();
  List<INode> removedINodes=new ChunkedArrayList<INode>();
  FSPermissionChecker pc=getPermissionChecker();
  checkOperation(OperationCategory.WRITE);
  byte[][] pathComponents=FSDirectory.getPathComponentsForReservedPath(src);
  boolean ret=false;
  waitForLoadingFSImage();
  writeLock();
  try {
    checkOperation(OperationCategory.WRITE);
    checkNameNodeSafeMode("Cannot delete " + src);
    src=dir.resolvePath(pc,src,pathComponents);
    final INodesInPath iip=dir.getINodesInPath4Write(src,false);
    if (!recursive && dir.isNonEmptyDirectory(iip)) {
      throw new PathIsNotEmptyDirectoryException(src + " is non empty");
    }
    if (enforcePermission && isPermissionEnabled) {
      dir.checkPermission(pc,iip,false,null,FsAction.WRITE,null,FsAction.ALL,true);
    }
    long mtime=now();
    long filesRemoved=dir.delete(iip,collectedBlocks,removedINodes,mtime);
    if (filesRemoved < 0) {
      return false;
    }
    getEditLog().logDelete(src,mtime,logRetryCache);
    incrDeletedFileCount(filesRemoved);
    removePathAndBlocks(src,null,removedINodes,true);
    ret=true;
  }
  finally {
    writeUnlock();
  }
  getEditLog().logSync();
  removeBlocks(collectedBlocks);
  collectedBlocks.clear();
  if (NameNode.stateChangeLog.isDebugEnabled()) {
    NameNode.stateChangeLog.debug("DIR* Namesystem.delete: " + src + " is removed");
  }
  return ret;
}
