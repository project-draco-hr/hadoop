{
  final long blockSize;
  final int replication;
  final byte storagePolicyID;
  Node clientNode=null;
  String clientMachine=null;
  if (NameNode.stateChangeLog.isDebugEnabled()) {
    NameNode.stateChangeLog.debug("BLOCK* getAdditionalBlock: " + src + " inodeId "+ fileId+ " for "+ clientName);
  }
  checkOperation(OperationCategory.READ);
  byte[][] pathComponents=FSDirectory.getPathComponentsForReservedPath(src);
  readLock();
  try {
    checkOperation(OperationCategory.READ);
    src=resolvePath(src,pathComponents);
    LocatedBlock[] onRetryBlock=new LocatedBlock[1];
    FileState fileState=analyzeFileState(src,fileId,clientName,previous,onRetryBlock);
    final INodeFile pendingFile=fileState.inode;
    src=fileState.path;
    if (onRetryBlock[0] != null && onRetryBlock[0].getLocations().length > 0) {
      return onRetryBlock[0];
    }
    if (pendingFile.getBlocks().length >= maxBlocksPerFile) {
      throw new IOException("File has reached the limit on maximum number of" + " blocks (" + DFSConfigKeys.DFS_NAMENODE_MAX_BLOCKS_PER_FILE_KEY + "): "+ pendingFile.getBlocks().length+ " >= "+ maxBlocksPerFile);
    }
    blockSize=pendingFile.getPreferredBlockSize();
    clientMachine=pendingFile.getFileUnderConstructionFeature().getClientMachine();
    clientNode=blockManager.getDatanodeManager().getDatanodeByHost(clientMachine);
    replication=pendingFile.getFileReplication();
    storagePolicyID=pendingFile.getStoragePolicyID();
  }
  finally {
    readUnlock();
  }
  if (clientNode == null) {
    clientNode=getClientNode(clientMachine);
  }
  final DatanodeStorageInfo targets[]=getBlockManager().chooseTarget4NewBlock(src,replication,clientNode,excludedNodes,blockSize,favoredNodes,storagePolicyID);
  Block newBlock=null;
  long offset;
  checkOperation(OperationCategory.WRITE);
  waitForLoadingFSImage();
  writeLock();
  try {
    checkOperation(OperationCategory.WRITE);
    LocatedBlock[] onRetryBlock=new LocatedBlock[1];
    FileState fileState=analyzeFileState(src,fileId,clientName,previous,onRetryBlock);
    final INodeFile pendingFile=fileState.inode;
    src=fileState.path;
    if (onRetryBlock[0] != null) {
      if (onRetryBlock[0].getLocations().length > 0) {
        return onRetryBlock[0];
      }
 else {
        BlockInfo lastBlockInFile=pendingFile.getLastBlock();
        ((BlockInfoUnderConstruction)lastBlockInFile).setExpectedLocations(targets);
        offset=pendingFile.computeFileSize();
        return makeLocatedBlock(lastBlockInFile,targets,offset);
      }
    }
    commitOrCompleteLastBlock(pendingFile,ExtendedBlock.getLocalBlock(previous));
    newBlock=createNewBlock();
    INodesInPath inodesInPath=INodesInPath.fromINode(pendingFile);
    saveAllocatedBlock(src,inodesInPath,newBlock,targets);
    persistNewBlock(src,pendingFile);
    offset=pendingFile.computeFileSize();
  }
  finally {
    writeUnlock();
  }
  getEditLog().logSync();
  return makeLocatedBlock(newBlock,targets,offset);
}
