{
  long blockSize;
  int replication;
  DatanodeDescriptor clientNode=null;
  if (NameNode.stateChangeLog.isDebugEnabled()) {
    NameNode.stateChangeLog.debug("BLOCK* NameSystem.getAdditionalBlock: file " + src + " for "+ clientName);
  }
  checkOperation(OperationCategory.READ);
  byte[][] pathComponents=FSDirectory.getPathComponentsForReservedPath(src);
  readLock();
  try {
    checkOperation(OperationCategory.READ);
    src=FSDirectory.resolvePath(src,pathComponents,dir);
    LocatedBlock[] onRetryBlock=new LocatedBlock[1];
    final INode[] inodes=analyzeFileState(src,fileId,clientName,previous,onRetryBlock).getINodes();
    final INodeFileUnderConstruction pendingFile=(INodeFileUnderConstruction)inodes[inodes.length - 1].asFile();
    if (onRetryBlock[0] != null && onRetryBlock[0].getLocations().length > 0) {
      return onRetryBlock[0];
    }
    if (pendingFile.getBlocks().length >= maxBlocksPerFile) {
      throw new IOException("File has reached the limit on maximum number of" + " blocks (" + DFSConfigKeys.DFS_NAMENODE_MAX_BLOCKS_PER_FILE_KEY + "): "+ pendingFile.getBlocks().length+ " >= "+ maxBlocksPerFile);
    }
    blockSize=pendingFile.getPreferredBlockSize();
    clientNode=pendingFile.getClientNode();
    replication=pendingFile.getFileReplication();
  }
  finally {
    readUnlock();
  }
  final DatanodeStorageInfo targets[]=getBlockManager().chooseTarget(src,replication,clientNode,excludedNodes,blockSize,favoredNodes);
  Block newBlock=null;
  long offset;
  checkOperation(OperationCategory.WRITE);
  writeLock();
  try {
    checkOperation(OperationCategory.WRITE);
    LocatedBlock[] onRetryBlock=new LocatedBlock[1];
    INodesInPath inodesInPath=analyzeFileState(src,fileId,clientName,previous,onRetryBlock);
    INode[] inodes=inodesInPath.getINodes();
    final INodeFileUnderConstruction pendingFile=(INodeFileUnderConstruction)inodes[inodes.length - 1].asFile();
    if (onRetryBlock[0] != null) {
      if (onRetryBlock[0].getLocations().length > 0) {
        return onRetryBlock[0];
      }
 else {
        BlockInfo lastBlockInFile=pendingFile.getLastBlock();
        ((BlockInfoUnderConstruction)lastBlockInFile).setExpectedLocations(targets);
        offset=pendingFile.computeFileSize();
        return makeLocatedBlock(lastBlockInFile,targets,offset);
      }
    }
    commitOrCompleteLastBlock(pendingFile,ExtendedBlock.getLocalBlock(previous));
    newBlock=createNewBlock();
    saveAllocatedBlock(src,inodesInPath,newBlock,targets);
    dir.persistBlocks(src,pendingFile,false);
    offset=pendingFile.computeFileSize();
  }
  finally {
    writeUnlock();
  }
  if (persistBlocks) {
    getEditLog().logSync();
  }
  return makeLocatedBlock(newBlock,targets,offset);
}
