{
  this.reporter=reporter;
  this.scheduler=scheduler;
  this.merger=merger;
  this.metrics=metrics;
  this.exceptionReporter=exceptionReporter;
  this.id=++nextId;
  this.reduce=reduceId.getTaskID().getId();
  this.jobTokenSecret=jobTokenSecret;
  ioErrs=reporter.getCounter(SHUFFLE_ERR_GRP_NAME,ShuffleErrors.IO_ERROR.toString());
  wrongLengthErrs=reporter.getCounter(SHUFFLE_ERR_GRP_NAME,ShuffleErrors.WRONG_LENGTH.toString());
  badIdErrs=reporter.getCounter(SHUFFLE_ERR_GRP_NAME,ShuffleErrors.BAD_ID.toString());
  wrongMapErrs=reporter.getCounter(SHUFFLE_ERR_GRP_NAME,ShuffleErrors.WRONG_MAP.toString());
  connectionErrs=reporter.getCounter(SHUFFLE_ERR_GRP_NAME,ShuffleErrors.CONNECTION.toString());
  wrongReduceErrs=reporter.getCounter(SHUFFLE_ERR_GRP_NAME,ShuffleErrors.WRONG_REDUCE.toString());
  if (job.getCompressMapOutput()) {
    Class<? extends CompressionCodec> codecClass=job.getMapOutputCompressorClass(DefaultCodec.class);
    codec=ReflectionUtils.newInstance(codecClass,job);
    decompressor=CodecPool.getDecompressor(codec);
  }
 else {
    codec=null;
    decompressor=null;
  }
  this.connectionTimeout=job.getInt(MRJobConfig.SHUFFLE_CONNECT_TIMEOUT,DEFAULT_STALLED_COPY_TIMEOUT);
  this.readTimeout=job.getInt(MRJobConfig.SHUFFLE_READ_TIMEOUT,DEFAULT_READ_TIMEOUT);
  setName("fetcher#" + id);
  setDaemon(true);
}
