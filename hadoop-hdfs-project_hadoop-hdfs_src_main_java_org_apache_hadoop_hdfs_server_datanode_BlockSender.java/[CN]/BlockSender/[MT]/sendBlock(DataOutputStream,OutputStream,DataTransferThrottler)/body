{
  if (out == null) {
    throw new IOException("out stream is null");
  }
  this.throttler=throttler;
  long initialOffset=offset;
  long totalRead=0;
  OutputStream streamForSendChunks=out;
  final long startTime=ClientTraceLog.isInfoEnabled() ? System.nanoTime() : 0;
  try {
    try {
      checksum.writeHeader(out);
      if (chunkOffsetOK) {
        out.writeLong(offset);
      }
      out.flush();
    }
 catch (    IOException e) {
      throw ioeToSocketException(e);
    }
    int maxChunksPerPacket;
    int pktSize=PacketHeader.PKT_HEADER_LEN;
    if (transferToAllowed && !verifyChecksum && baseStream instanceof SocketOutputStream&& blockIn instanceof FileInputStream) {
      FileChannel fileChannel=((FileInputStream)blockIn).getChannel();
      blockInPosition=fileChannel.position();
      streamForSendChunks=baseStream;
      maxChunksPerPacket=(Math.max(HdfsConstants.IO_FILE_BUFFER_SIZE,MIN_BUFFER_WITH_TRANSFERTO) + bytesPerChecksum - 1) / bytesPerChecksum;
      pktSize+=checksumSize * maxChunksPerPacket;
    }
 else {
      maxChunksPerPacket=Math.max(1,(HdfsConstants.IO_FILE_BUFFER_SIZE + bytesPerChecksum - 1) / bytesPerChecksum);
      pktSize+=(bytesPerChecksum + checksumSize) * maxChunksPerPacket;
    }
    ByteBuffer pktBuf=ByteBuffer.allocate(pktSize);
    while (endOffset > offset) {
      long len=sendChunks(pktBuf,maxChunksPerPacket,streamForSendChunks);
      offset+=len;
      totalRead+=len + ((len + bytesPerChecksum - 1) / bytesPerChecksum * checksumSize);
      seqno++;
    }
    try {
      sendChunks(pktBuf,maxChunksPerPacket,streamForSendChunks);
      out.flush();
    }
 catch (    IOException e) {
      throw ioeToSocketException(e);
    }
    sentEntireByteRange=true;
  }
  finally {
    if (clientTraceFmt != null) {
      final long endTime=System.nanoTime();
      ClientTraceLog.info(String.format(clientTraceFmt,totalRead,initialOffset,endTime - startTime));
    }
    close();
  }
  return totalRead;
}
