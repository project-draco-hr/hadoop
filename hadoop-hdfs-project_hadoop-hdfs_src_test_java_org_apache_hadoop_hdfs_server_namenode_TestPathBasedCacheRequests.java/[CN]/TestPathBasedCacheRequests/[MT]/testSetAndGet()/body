{
  Configuration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    cluster.waitActive();
    final NamenodeProtocols proto=cluster.getNameNodeRpc();
    proto.addCachePool(new CachePoolInfo("pool1").setMode(new FsPermission((short)0777)));
    proto.addCachePool(new CachePoolInfo("pool2").setMode(new FsPermission((short)0777)));
    proto.addCachePool(new CachePoolInfo("pool3").setMode(new FsPermission((short)0777)));
    proto.addCachePool(new CachePoolInfo("pool4").setMode(new FsPermission((short)0)));
    List<Fallible<PathBasedCacheEntry>> addResults1=unprivilegedUser.doAs(new PrivilegedExceptionAction<List<Fallible<PathBasedCacheEntry>>>(){
      @Override public List<Fallible<PathBasedCacheEntry>> run() throws IOException {
        return proto.addPathBasedCacheDirectives(Arrays.asList(new PathBasedCacheDirective[]{new PathBasedCacheDirective("/alpha","pool1"),new PathBasedCacheDirective("/beta","pool2"),new PathBasedCacheDirective("","pool3"),new PathBasedCacheDirective("/zeta","nonexistent_pool"),new PathBasedCacheDirective("/zeta","pool4"),new PathBasedCacheDirective("//illegal/path/","pool1")}));
      }
    }
);
    long ids1[]=new long[2];
    ids1[0]=addResults1.get(0).get().getEntryId();
    ids1[1]=addResults1.get(1).get().getEntryId();
    try {
      addResults1.get(2).get();
      Assert.fail("expected an error when adding an empty path");
    }
 catch (    IOException ioe) {
      Assert.assertTrue(ioe.getCause() instanceof EmptyPathError);
    }
    try {
      addResults1.get(3).get();
      Assert.fail("expected an error when adding to a nonexistent pool.");
    }
 catch (    IOException ioe) {
      Assert.assertTrue(ioe.getCause() instanceof InvalidPoolNameError);
    }
    try {
      addResults1.get(4).get();
      Assert.fail("expected an error when adding to a pool with " + "mode 0 (no permissions for anyone).");
    }
 catch (    IOException ioe) {
      Assert.assertTrue(ioe.getCause() instanceof PoolWritePermissionDeniedError);
    }
    try {
      addResults1.get(5).get();
      Assert.fail("expected an error when adding a malformed path " + "to the cache directives.");
    }
 catch (    IOException ioe) {
    }
    List<Fallible<PathBasedCacheEntry>> addResults2=proto.addPathBasedCacheDirectives(Arrays.asList(new PathBasedCacheDirective[]{new PathBasedCacheDirective("/alpha","pool1"),new PathBasedCacheDirective("/theta",""),new PathBasedCacheDirective("bogus","pool1"),new PathBasedCacheDirective("/gamma","pool1")}));
    long id=addResults2.get(0).get().getEntryId();
    Assert.assertEquals("expected to get back the same ID as last time " + "when re-adding an existing PathBasedCache directive.",ids1[0],id);
    try {
      addResults2.get(1).get();
      Assert.fail("expected an error when adding a PathBasedCache " + "directive with an empty pool name.");
    }
 catch (    IOException ioe) {
      Assert.assertTrue(ioe.getCause() instanceof InvalidPoolNameError);
    }
    try {
      addResults2.get(2).get();
      Assert.fail("expected an error when adding a PathBasedCache " + "directive with a non-absolute path name.");
    }
 catch (    IOException ioe) {
      Assert.assertTrue(ioe.getCause() instanceof InvalidPathNameError);
    }
    long ids2[]=new long[1];
    ids2[0]=addResults2.get(3).get().getEntryId();
    RemoteIterator<PathBasedCacheEntry> iter=proto.listPathBasedCacheEntries(0,null,null);
    validateListAll(iter,ids1[0],ids1[1],ids2[0]);
    iter=proto.listPathBasedCacheEntries(0,null,null);
    validateListAll(iter,ids1[0],ids1[1],ids2[0]);
    iter=proto.listPathBasedCacheEntries(0,"pool3",null);
    Assert.assertFalse(iter.hasNext());
    iter=proto.listPathBasedCacheEntries(0,"pool2",null);
    Assert.assertEquals(addResults1.get(1).get(),iter.next());
    Assert.assertFalse(iter.hasNext());
    List<Fallible<Long>> removeResults1=proto.removePathBasedCacheEntries(Arrays.asList(new Long[]{ids1[1],-42L,999999L}));
    Assert.assertEquals(Long.valueOf(ids1[1]),removeResults1.get(0).get());
    try {
      removeResults1.get(1).get();
      Assert.fail("expected an error when removing a negative ID");
    }
 catch (    IOException ioe) {
      Assert.assertTrue(ioe.getCause() instanceof InvalidIdException);
    }
    try {
      removeResults1.get(2).get();
      Assert.fail("expected an error when removing a nonexistent ID");
    }
 catch (    IOException ioe) {
      Assert.assertTrue(ioe.getCause() instanceof NoSuchIdException);
    }
    iter=proto.listPathBasedCacheEntries(0,"pool2",null);
    Assert.assertFalse(iter.hasNext());
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}
