{
  try {
    ServletContext context=getServletContext();
    final FSImage nnImage=NameNodeHttpServer.getFsImageFromContext(context);
    final GetImageParams parsedParams=new GetImageParams(request,response);
    final Configuration conf=(Configuration)getServletContext().getAttribute(JspHelper.CURRENT_CONF);
    if (UserGroupInformation.isSecurityEnabled() && !isValidRequestor(request.getUserPrincipal().getName(),conf)) {
      response.sendError(HttpServletResponse.SC_FORBIDDEN,"Only Namenode and Secondary Namenode may access this servlet");
      LOG.warn("Received non-NN/SNN request for image or edits from " + request.getUserPrincipal().getName() + " at "+ request.getRemoteHost());
      return;
    }
    String myStorageInfoString=nnImage.getStorage().toColonSeparatedString();
    String theirStorageInfoString=parsedParams.getStorageInfoString();
    if (theirStorageInfoString != null && !myStorageInfoString.equals(theirStorageInfoString)) {
      response.sendError(HttpServletResponse.SC_FORBIDDEN,"This namenode has storage info " + myStorageInfoString + " but the secondary expected "+ theirStorageInfoString);
      LOG.warn("Received an invalid request file transfer request " + "from a secondary with storage info " + theirStorageInfoString);
      return;
    }
    UserGroupInformation.getCurrentUser().doAs(new PrivilegedExceptionAction<Void>(){
      @Override public Void run() throws Exception {
        if (parsedParams.isGetImage()) {
          long txid=parsedParams.getTxId();
          File imageFile=null;
          String errorMessage="Could not find image";
          if (parsedParams.shouldFetchLatest()) {
            imageFile=nnImage.getStorage().getHighestFsImageName();
          }
 else {
            errorMessage+=" with txid " + txid;
            imageFile=nnImage.getStorage().getFsImageName(txid);
          }
          if (imageFile == null) {
            throw new IOException(errorMessage);
          }
          CheckpointFaultInjector.getInstance().beforeGetImageSetsHeaders();
          setFileNameHeaders(response,imageFile);
          setVerificationHeaders(response,imageFile);
          TransferFsImage.getFileServer(response.getOutputStream(),imageFile,getThrottler(conf));
        }
 else         if (parsedParams.isGetEdit()) {
          long startTxId=parsedParams.getStartTxId();
          long endTxId=parsedParams.getEndTxId();
          File editFile=nnImage.getStorage().findFinalizedEditsFile(startTxId,endTxId);
          setVerificationHeaders(response,editFile);
          setFileNameHeaders(response,editFile);
          TransferFsImage.getFileServer(response.getOutputStream(),editFile,getThrottler(conf));
        }
 else         if (parsedParams.isPutImage()) {
          final long txid=parsedParams.getTxId();
          if (!currentlyDownloadingCheckpoints.add(txid)) {
            response.sendError(HttpServletResponse.SC_CONFLICT,"Another checkpointer is already in the process of uploading a" + " checkpoint made at transaction ID " + txid);
            return null;
          }
          try {
            if (nnImage.getStorage().findImageFile(txid) != null) {
              response.sendError(HttpServletResponse.SC_CONFLICT,"Another checkpointer already uploaded an checkpoint " + "for txid " + txid);
              return null;
            }
            MD5Hash downloadImageDigest=TransferFsImage.downloadImageToStorage(parsedParams.getInfoServer(),txid,nnImage.getStorage(),true);
            nnImage.saveDigestAndRenameCheckpointImage(txid,downloadImageDigest);
            nnImage.purgeOldStorage();
          }
  finally {
            currentlyDownloadingCheckpoints.remove(txid);
          }
        }
        return null;
      }
    }
);
  }
 catch (  Throwable t) {
    String errMsg="GetImage failed. " + StringUtils.stringifyException(t);
    response.sendError(HttpServletResponse.SC_GONE,errMsg);
    throw new IOException(errMsg);
  }
 finally {
    response.getOutputStream().close();
  }
}
