{
  if (rmContext.isWorkPreservingRecoveryEnabled() && !rmContext.isSchedulerReadyForAllocatingContainers()) {
    return;
  }
  RMContainer reservedContainer=node.getReservedContainer();
  if (reservedContainer != null) {
    FiCaSchedulerApp reservedApplication=getCurrentAttemptForContainer(reservedContainer.getContainerId());
    LOG.info("Trying to fulfill reservation for application " + reservedApplication.getApplicationId() + " on node: "+ node.getNodeID());
    LeafQueue queue=((LeafQueue)reservedApplication.getQueue());
    CSAssignment assignment=queue.assignContainers(clusterResource,node,false,new ResourceLimits(clusterResource));
    RMContainer excessReservation=assignment.getExcessReservation();
    if (excessReservation != null) {
      Container container=excessReservation.getContainer();
      queue.completedContainer(clusterResource,assignment.getApplication(),node,excessReservation,SchedulerUtils.createAbnormalContainerStatus(container.getId(),SchedulerUtils.UNRESERVED_CONTAINER),RMContainerEventType.RELEASED,null,true);
    }
  }
  if (node.getReservedContainer() == null) {
    if (calculator.computeAvailableContainers(node.getAvailableResource(),minimumAllocation) > 0) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Trying to schedule on node: " + node.getNodeName() + ", available: "+ node.getAvailableResource());
      }
      root.assignContainers(clusterResource,node,false,new ResourceLimits(clusterResource));
    }
  }
 else {
    LOG.info("Skipping scheduling since node " + node.getNodeID() + " is reserved by application "+ node.getReservedContainer().getContainerId().getApplicationAttemptId());
  }
}
