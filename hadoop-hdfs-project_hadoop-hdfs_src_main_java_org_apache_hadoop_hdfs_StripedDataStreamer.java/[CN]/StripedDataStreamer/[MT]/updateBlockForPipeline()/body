{
  if (LOG.isDebugEnabled()) {
    LOG.debug("updateBlockForPipeline(), " + this);
  }
  return new ConcurrentPoll<LocatedBlock>(coordinator.getNewBlocks()){
    @Override void populate() throws IOException {
      final ExtendedBlock bg=coordinator.getBlockGroup();
      final LocatedBlock updated=callUpdateBlockForPipeline(bg);
      final long newGS=updated.getBlock().getGenerationStamp();
      final LocatedBlock[] updatedBlks=StripedBlockUtil.parseStripedBlockGroup((LocatedStripedBlock)updated,cellSize,schema.getNumDataUnits(),schema.getNumParityUnits());
      for (int i=0; i < schema.getNumDataUnits() + schema.getNumParityUnits(); i++) {
        StripedDataStreamer si=coordinator.getStripedDataStreamer(i);
        if (si.isFailed()) {
          continue;
        }
        final ExtendedBlock bi=si.getBlock();
        if (bi != null) {
          final LocatedBlock lb=new LocatedBlock(newBlock(bi,newGS),null,null,null,-1,updated.isCorrupt(),null);
          lb.setBlockToken(updatedBlks[i].getBlockToken());
          queue.offer(i,lb);
        }
 else {
          final MultipleBlockingQueue<LocatedBlock> followingBlocks=coordinator.getFollowingBlocks();
synchronized (followingBlocks) {
            final LocatedBlock lb=followingBlocks.peek(i);
            if (lb != null) {
              lb.getBlock().setGenerationStamp(newGS);
              si.getErrorState().reset();
              continue;
            }
          }
          sleep(100,"updateBlockForPipeline, " + this);
          i--;
        }
      }
    }
  }
.poll(index);
}
