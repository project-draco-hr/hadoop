{
  bm.maxReplicationStreams=0;
  bm.replicationStreamsHardLimit=1;
  long blockId=42;
  Block aBlock=new Block(blockId,0,0);
  List<DatanodeDescriptor> origNodes=getNodes(0,1);
  addBlockOnNodes(blockId,origNodes.subList(0,1));
  List<DatanodeDescriptor> cntNodes=new LinkedList<DatanodeDescriptor>();
  List<DatanodeStorageInfo> liveNodes=new LinkedList<DatanodeStorageInfo>();
  assertNotNull("Chooses source node for a highest-priority replication" + " even if all available source nodes have reached their replication" + " limits below the hard limit.",bm.chooseSourceDatanode(bm.getStoredBlock(aBlock),cntNodes,liveNodes,new NumberReplicas(),UnderReplicatedBlocks.QUEUE_HIGHEST_PRIORITY));
  assertNull("Does not choose a source node for a less-than-highest-priority" + " replication since all available source nodes have reached" + " their replication limits.",bm.chooseSourceDatanode(bm.getStoredBlock(aBlock),cntNodes,liveNodes,new NumberReplicas(),UnderReplicatedBlocks.QUEUE_VERY_UNDER_REPLICATED));
  DatanodeStorageInfo targets[]={origNodes.get(1).getStorageInfos()[0]};
  origNodes.get(0).addBlockToBeReplicated(aBlock,targets);
  assertNull("Does not choose a source node for a highest-priority" + " replication when all available nodes exceed the hard limit.",bm.chooseSourceDatanode(bm.getStoredBlock(aBlock),cntNodes,liveNodes,new NumberReplicas(),UnderReplicatedBlocks.QUEUE_HIGHEST_PRIORITY));
}
