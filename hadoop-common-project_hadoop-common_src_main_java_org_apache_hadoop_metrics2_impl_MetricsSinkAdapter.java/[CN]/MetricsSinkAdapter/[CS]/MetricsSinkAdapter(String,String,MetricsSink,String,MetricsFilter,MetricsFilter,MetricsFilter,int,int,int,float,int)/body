{
  this.name=checkNotNull(name,"name");
  this.description=description;
  this.sink=checkNotNull(sink,"sink object");
  this.context=context;
  this.sourceFilter=sourceFilter;
  this.recordFilter=recordFilter;
  this.metricFilter=metricFilter;
  this.period=checkArg(period,period > 0,"period");
  firstRetryDelay=checkArg(retryDelay,retryDelay > 0,"retry delay");
  this.retryBackoff=checkArg(retryBackoff,retryBackoff > 1,"retry backoff");
  this.retryCount=retryCount;
  this.queue=new SinkQueue<MetricsBuffer>(checkArg(queueCapacity,queueCapacity > 0,"queue capacity"));
  latency=registry.newRate("Sink_" + name,"Sink end to end latency",false);
  dropped=registry.newCounter("Sink_" + name + "Dropped","Dropped updates per sink",0);
  qsize=registry.newGauge("Sink_" + name + "Qsize","Queue size",0);
  sinkThread=new Thread(){
    @Override public void run(){
      publishMetricsFromQueue();
    }
  }
;
  sinkThread.setName(name);
  sinkThread.setDaemon(true);
}
