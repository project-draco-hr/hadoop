{
  src.checkNotSchemeWithRelative();
  dst.checkNotSchemeWithRelative();
  Path qSrc=makeQualified(src);
  Path qDst=makeQualified(dst);
  checkDest(qSrc.getName(),qDst,overwrite);
  FileStatus fs=FileContext.this.getFileStatus(qSrc);
  if (fs.isDirectory()) {
    checkDependencies(qSrc,qDst);
    mkdir(qDst,FsPermission.getDirDefault(),true);
    FileStatus[] contents=listStatus(qSrc);
    for (    FileStatus content : contents) {
      copy(makeQualified(content.getPath()),makeQualified(new Path(qDst,content.getPath().getName())),deleteSource,overwrite);
    }
  }
 else {
    InputStream in=null;
    OutputStream out=null;
    try {
      in=open(qSrc);
      EnumSet<CreateFlag> createFlag=overwrite ? EnumSet.of(CreateFlag.CREATE,CreateFlag.OVERWRITE) : EnumSet.of(CreateFlag.CREATE);
      out=create(qDst,createFlag);
      IOUtils.copyBytes(in,out,conf,true);
    }
 catch (    IOException e) {
      IOUtils.closeStream(out);
      IOUtils.closeStream(in);
      throw e;
    }
  }
  if (deleteSource) {
    return delete(qSrc,true);
  }
 else {
    return true;
  }
}
