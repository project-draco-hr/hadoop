{
  boolean firstReplicationLog=true;
  int lowRedundancyBlocks=0;
  int decommissionOnlyReplicas=0;
  int lowRedundancyInOpenFiles=0;
  while (it.hasNext()) {
    numBlocksChecked++;
    final BlockInfo block=it.next();
    if (blockManager.blocksMap.getStoredBlock(block) == null) {
      LOG.trace("Removing unknown block {}",block);
      it.remove();
      continue;
    }
    long bcId=block.getBlockCollectionId();
    if (bcId == INodeId.INVALID_INODE_ID) {
      continue;
    }
    final BlockCollection bc=blockManager.getBlockCollection(block);
    final NumberReplicas num=blockManager.countNodes(block);
    final int liveReplicas=num.liveReplicas();
    if (blockManager.isNeededReconstruction(block,liveReplicas)) {
      if (!blockManager.neededReconstruction.contains(block) && blockManager.pendingReconstruction.getNumReplicas(block) == 0 && blockManager.isPopulatingReplQueues()) {
        blockManager.neededReconstruction.add(block,liveReplicas,num.readOnlyReplicas(),num.decommissionedAndDecommissioning(),blockManager.getExpectedReplicaNum(block));
      }
    }
    if (isSufficient(block,bc,num)) {
      if (pruneReliableBlocks) {
        it.remove();
      }
      continue;
    }
    if (insufficientList != null) {
      insufficientList.add(block);
    }
    if (firstReplicationLog) {
      logBlockReplicationInfo(block,bc,datanode,num,blockManager.blocksMap.getStorages(block));
      firstReplicationLog=false;
    }
    lowRedundancyBlocks++;
    if (bc.isUnderConstruction()) {
      lowRedundancyInOpenFiles++;
    }
    if ((liveReplicas == 0) && (num.decommissionedAndDecommissioning() > 0)) {
      decommissionOnlyReplicas++;
    }
  }
  datanode.decommissioningStatus.set(lowRedundancyBlocks,decommissionOnlyReplicas,lowRedundancyInOpenFiles);
}
