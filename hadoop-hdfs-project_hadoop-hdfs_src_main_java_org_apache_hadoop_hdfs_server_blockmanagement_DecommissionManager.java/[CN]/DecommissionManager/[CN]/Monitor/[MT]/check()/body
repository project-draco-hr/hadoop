{
  final Iterator<Map.Entry<DatanodeDescriptor,AbstractList<BlockInfo>>> it=new CyclicIteration<>(decomNodeBlocks,iterkey).iterator();
  final LinkedList<DatanodeDescriptor> toRemove=new LinkedList<>();
  while (it.hasNext() && !exceededNumBlocksPerCheck()) {
    numNodesChecked++;
    final Map.Entry<DatanodeDescriptor,AbstractList<BlockInfo>> entry=it.next();
    final DatanodeDescriptor dn=entry.getKey();
    AbstractList<BlockInfo> blocks=entry.getValue();
    boolean fullScan=false;
    if (blocks == null) {
      LOG.debug("Newly-added node {}, doing full scan to find " + "insufficiently-replicated blocks.",dn);
      blocks=handleInsufficientlyStored(dn);
      decomNodeBlocks.put(dn,blocks);
      fullScan=true;
    }
 else {
      LOG.debug("Processing decommission-in-progress node {}",dn);
      pruneReliableBlocks(dn,blocks);
    }
    if (blocks.size() == 0) {
      if (!fullScan) {
        LOG.debug("Node {} has finished replicating current set of " + "blocks, checking with the full block map.",dn);
        blocks=handleInsufficientlyStored(dn);
        decomNodeBlocks.put(dn,blocks);
      }
      final boolean isHealthy=blockManager.isNodeHealthyForDecommission(dn);
      if (blocks.size() == 0 && isHealthy) {
        setDecommissioned(dn);
        toRemove.add(dn);
        LOG.debug("Node {} is sufficiently replicated and healthy, " + "marked as decommissioned.",dn);
      }
 else {
        if (LOG.isDebugEnabled()) {
          StringBuilder b=new StringBuilder("Node {} ");
          if (isHealthy) {
            b.append("is ");
          }
 else {
            b.append("isn't ");
          }
          b.append("healthy and still needs to replicate {} more blocks," + " decommissioning is still in progress.");
          LOG.debug(b.toString(),dn,blocks.size());
        }
      }
    }
 else {
      LOG.debug("Node {} still has {} blocks to replicate " + "before it is a candidate to finish decommissioning.",dn,blocks.size());
    }
    iterkey=dn;
  }
  for (  DatanodeDescriptor dn : toRemove) {
    Preconditions.checkState(dn.isDecommissioned(),"Removing a node that is not yet decommissioned!");
    decomNodeBlocks.remove(dn);
  }
}
