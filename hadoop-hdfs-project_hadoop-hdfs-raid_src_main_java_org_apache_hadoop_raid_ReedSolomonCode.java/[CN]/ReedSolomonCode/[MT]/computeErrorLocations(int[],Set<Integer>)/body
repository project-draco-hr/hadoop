{
  assert(data.length == paritySize + stripeSize && errorLocations != null);
  errorLocations.clear();
  int maxError=paritySize / 2;
  int[][] syndromeMatrix=new int[maxError][];
  for (int i=0; i < syndromeMatrix.length; ++i) {
    syndromeMatrix[i]=new int[maxError + 1];
  }
  int[] syndrome=new int[paritySize];
  if (computeSyndrome(data,syndrome)) {
    return true;
  }
  for (int i=0; i < maxError; ++i) {
    for (int j=0; j < maxError + 1; ++j) {
      syndromeMatrix[i][j]=syndrome[i + j];
    }
  }
  GF.gaussianElimination(syndromeMatrix);
  int[] polynomial=new int[maxError + 1];
  polynomial[0]=1;
  for (int i=0; i < maxError; ++i) {
    polynomial[i + 1]=syndromeMatrix[maxError - 1 - i][maxError];
  }
  for (int i=0; i < paritySize + stripeSize; ++i) {
    int possibleRoot=GF.divide(1,primitivePower[i]);
    if (GF.substitute(polynomial,possibleRoot) == 0) {
      errorLocations.add(i);
    }
  }
  int[] locations=new int[errorLocations.size()];
  int k=0;
  for (  int loc : errorLocations) {
    locations[k++]=loc;
  }
  int[] erasedValue=new int[locations.length];
  decode(data,locations,erasedValue);
  for (int i=0; i < locations.length; ++i) {
    data[locations[i]]=erasedValue[i];
  }
  return computeSyndrome(data,syndrome);
}
