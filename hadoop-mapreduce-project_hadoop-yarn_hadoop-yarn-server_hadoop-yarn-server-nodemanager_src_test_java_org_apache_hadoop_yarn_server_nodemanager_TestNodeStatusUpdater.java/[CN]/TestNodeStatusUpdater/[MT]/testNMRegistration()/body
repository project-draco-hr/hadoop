{
  final NodeManager nm=new NodeManager(){
    @Override protected NodeStatusUpdater createNodeStatusUpdater(    Context context,    Dispatcher dispatcher,    NodeHealthCheckerService healthChecker){
      return new MyNodeStatusUpdater(context,dispatcher,healthChecker,metrics);
    }
  }
;
  YarnConfiguration conf=new YarnConfiguration();
  conf.setInt(YarnConfiguration.NM_VMEM_GB,5);
  conf.set(YarnConfiguration.NM_ADDRESS,"127.0.0.1:12345");
  conf.set(YarnConfiguration.NM_LOCALIZER_ADDRESS,"127.0.0.1:12346");
  conf.set(YarnConfiguration.NM_LOG_DIRS,new Path(basedir,"logs").toUri().getPath());
  conf.set(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,new Path(basedir,"remotelogs").toUri().getPath());
  conf.set(YarnConfiguration.NM_LOCAL_DIRS,new Path(basedir,"nm0").toUri().getPath());
  nm.init(conf);
  new Thread(){
    public void run(){
      try {
        nm.start();
      }
 catch (      Error e) {
        TestNodeStatusUpdater.this.nmStartError=e;
      }
    }
  }
.start();
  System.out.println(" ----- thread already started.." + nm.getServiceState());
  int waitCount=0;
  while (nm.getServiceState() == STATE.INITED && waitCount++ != 20) {
    LOG.info("Waiting for NM to start..");
    Thread.sleep(1000);
  }
  if (nmStartError != null) {
    throw nmStartError;
  }
  if (nm.getServiceState() != STATE.STARTED) {
    Assert.fail("NodeManager failed to start");
  }
  while (heartBeatID <= 3) {
    Thread.sleep(500);
  }
  nm.stop();
}
