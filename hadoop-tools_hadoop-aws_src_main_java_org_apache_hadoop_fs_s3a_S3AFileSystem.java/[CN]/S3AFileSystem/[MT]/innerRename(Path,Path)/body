{
  LOG.debug("Rename path {} to {}",src,dst);
  incrementStatistic(INVOCATION_RENAME);
  String srcKey=pathToKey(src);
  String dstKey=pathToKey(dst);
  if (srcKey.isEmpty() || dstKey.isEmpty()) {
    LOG.debug("rename: source {} or dest {}, is empty",srcKey,dstKey);
    return false;
  }
  S3AFileStatus srcStatus;
  try {
    srcStatus=getFileStatus(src);
  }
 catch (  FileNotFoundException e) {
    LOG.error("rename: src not found {}",src);
    return false;
  }
  if (srcKey.equals(dstKey)) {
    LOG.debug("rename: src and dst refer to the same file or directory: {}",dst);
    return srcStatus.isFile();
  }
  S3AFileStatus dstStatus=null;
  try {
    dstStatus=getFileStatus(dst);
    if (srcStatus.isDirectory() && dstStatus.isFile()) {
      LOG.debug("rename: src {} is a directory and dst {} is a file",src,dst);
      return false;
    }
    if (dstStatus.isDirectory() && !dstStatus.isEmptyDirectory()) {
      return false;
    }
  }
 catch (  FileNotFoundException e) {
    LOG.debug("rename: destination path {} not found",dst);
    Path parent=dst.getParent();
    if (!pathToKey(parent).isEmpty()) {
      try {
        S3AFileStatus dstParentStatus=getFileStatus(dst.getParent());
        if (!dstParentStatus.isDirectory()) {
          return false;
        }
      }
 catch (      FileNotFoundException e2) {
        LOG.debug("rename: destination path {} has no parent {}",dst,parent);
        return false;
      }
    }
  }
  if (srcStatus.isFile()) {
    LOG.debug("rename: renaming file {} to {}",src,dst);
    if (dstStatus != null && dstStatus.isDirectory()) {
      String newDstKey=dstKey;
      if (!newDstKey.endsWith("/")) {
        newDstKey=newDstKey + "/";
      }
      String filename=srcKey.substring(pathToKey(src.getParent()).length() + 1);
      newDstKey=newDstKey + filename;
      copyFile(srcKey,newDstKey,srcStatus.getLen());
    }
 else {
      copyFile(srcKey,dstKey,srcStatus.getLen());
    }
    innerDelete(srcStatus,false);
  }
 else {
    LOG.debug("rename: renaming directory {} to {}",src,dst);
    if (!dstKey.endsWith("/")) {
      dstKey=dstKey + "/";
    }
    if (!srcKey.endsWith("/")) {
      srcKey=srcKey + "/";
    }
    if (dstKey.startsWith(srcKey)) {
      LOG.debug("cannot rename a directory {}" + " to a subdirectory of self: {}",srcKey,dstKey);
      return false;
    }
    List<DeleteObjectsRequest.KeyVersion> keysToDelete=new ArrayList<>();
    if (dstStatus != null && dstStatus.isEmptyDirectory()) {
      keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));
    }
    ListObjectsRequest request=new ListObjectsRequest();
    request.setBucketName(bucket);
    request.setPrefix(srcKey);
    request.setMaxKeys(maxKeys);
    ObjectListing objects=listObjects(request);
    while (true) {
      for (      S3ObjectSummary summary : objects.getObjectSummaries()) {
        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));
        String newDstKey=dstKey + summary.getKey().substring(srcKey.length());
        copyFile(summary.getKey(),newDstKey,summary.getSize());
        if (keysToDelete.size() == MAX_ENTRIES_TO_DELETE) {
          removeKeys(keysToDelete,true,false);
        }
      }
      if (objects.isTruncated()) {
        objects=continueListObjects(objects);
      }
 else {
        if (!keysToDelete.isEmpty()) {
          removeKeys(keysToDelete,false,false);
        }
        break;
      }
    }
  }
  if (src.getParent() != dst.getParent()) {
    deleteUnnecessaryFakeDirectories(dst.getParent());
    createFakeDirectoryIfNecessary(src.getParent());
  }
  return true;
}
