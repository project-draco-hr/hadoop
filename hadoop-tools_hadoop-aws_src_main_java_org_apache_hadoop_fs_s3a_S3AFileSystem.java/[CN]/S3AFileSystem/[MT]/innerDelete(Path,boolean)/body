{
  LOG.debug("Delete path {} - recursive {}",f,recursive);
  S3AFileStatus status;
  try {
    status=getFileStatus(f);
  }
 catch (  FileNotFoundException e) {
    LOG.debug("Couldn't delete {} - does not exist",f);
    instrumentation.errorIgnored();
    return false;
  }
  String key=pathToKey(f);
  if (status.isDirectory()) {
    LOG.debug("delete: Path is a directory: {}",f);
    if (!recursive && !status.isEmptyDirectory()) {
      throw new IOException("Path is a folder: " + f + " and it is not an empty directory");
    }
    if (!key.endsWith("/")) {
      key=key + "/";
    }
    if (key.equals("/")) {
      LOG.info("s3a cannot delete the root directory");
      return false;
    }
    if (status.isEmptyDirectory()) {
      LOG.debug("Deleting fake empty directory {}",key);
      deleteObject(key);
      instrumentation.directoryDeleted();
    }
 else {
      LOG.debug("Getting objects for directory prefix {} to delete",key);
      ListObjectsRequest request=new ListObjectsRequest();
      request.setBucketName(bucket);
      request.setPrefix(key);
      request.setMaxKeys(maxKeys);
      ObjectListing objects=listObjects(request);
      List<DeleteObjectsRequest.KeyVersion> keys=new ArrayList<>(objects.getObjectSummaries().size());
      while (true) {
        for (        S3ObjectSummary summary : objects.getObjectSummaries()) {
          keys.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));
          LOG.debug("Got object to delete {}",summary.getKey());
          if (keys.size() == MAX_ENTRIES_TO_DELETE) {
            removeKeys(keys,true);
          }
        }
        if (objects.isTruncated()) {
          objects=continueListObjects(objects);
        }
 else {
          if (!keys.isEmpty()) {
            removeKeys(keys,false);
          }
          break;
        }
      }
    }
  }
 else {
    LOG.debug("delete: Path is a file");
    instrumentation.fileDeleted(1);
    deleteObject(key);
  }
  createFakeDirectoryIfNecessary(f.getParent());
  return true;
}
