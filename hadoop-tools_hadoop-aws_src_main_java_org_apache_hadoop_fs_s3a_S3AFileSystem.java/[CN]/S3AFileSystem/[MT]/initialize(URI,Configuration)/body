{
  super.initialize(name,conf);
  uri=URI.create(name.getScheme() + "://" + name.getAuthority());
  workingDir=new Path("/user",System.getProperty("user.name")).makeQualified(this.uri,this.getWorkingDirectory());
  String accessKey=conf.get(ACCESS_KEY,null);
  String secretKey=conf.get(SECRET_KEY,null);
  String userInfo=name.getUserInfo();
  if (userInfo != null) {
    int index=userInfo.indexOf(':');
    if (index != -1) {
      accessKey=userInfo.substring(0,index);
      secretKey=userInfo.substring(index + 1);
    }
 else {
      accessKey=userInfo;
    }
  }
  AWSCredentialsProviderChain credentials=new AWSCredentialsProviderChain(new BasicAWSCredentialsProvider(accessKey,secretKey),new InstanceProfileCredentialsProvider(),new AnonymousAWSCredentialsProvider());
  bucket=name.getHost();
  ClientConfiguration awsConf=new ClientConfiguration();
  awsConf.setMaxConnections(conf.getInt(MAXIMUM_CONNECTIONS,DEFAULT_MAXIMUM_CONNECTIONS));
  boolean secureConnections=conf.getBoolean(SECURE_CONNECTIONS,DEFAULT_SECURE_CONNECTIONS);
  awsConf.setProtocol(secureConnections ? Protocol.HTTPS : Protocol.HTTP);
  awsConf.setMaxErrorRetry(conf.getInt(MAX_ERROR_RETRIES,DEFAULT_MAX_ERROR_RETRIES));
  awsConf.setConnectionTimeout(conf.getInt(ESTABLISH_TIMEOUT,DEFAULT_ESTABLISH_TIMEOUT));
  awsConf.setSocketTimeout(conf.getInt(SOCKET_TIMEOUT,DEFAULT_SOCKET_TIMEOUT));
  String signerOverride=conf.getTrimmed(SIGNING_ALGORITHM,"");
  if (!signerOverride.isEmpty()) {
    awsConf.setSignerOverride(signerOverride);
  }
  String proxyHost=conf.getTrimmed(PROXY_HOST,"");
  int proxyPort=conf.getInt(PROXY_PORT,-1);
  if (!proxyHost.isEmpty()) {
    awsConf.setProxyHost(proxyHost);
    if (proxyPort >= 0) {
      awsConf.setProxyPort(proxyPort);
    }
 else {
      if (secureConnections) {
        LOG.warn("Proxy host set without port. Using HTTPS default 443");
        awsConf.setProxyPort(443);
      }
 else {
        LOG.warn("Proxy host set without port. Using HTTP default 80");
        awsConf.setProxyPort(80);
      }
    }
    String proxyUsername=conf.getTrimmed(PROXY_USERNAME);
    String proxyPassword=conf.getTrimmed(PROXY_PASSWORD);
    if ((proxyUsername == null) != (proxyPassword == null)) {
      String msg="Proxy error: " + PROXY_USERNAME + " or "+ PROXY_PASSWORD+ " set without the other.";
      LOG.error(msg);
      throw new IllegalArgumentException(msg);
    }
    awsConf.setProxyUsername(proxyUsername);
    awsConf.setProxyPassword(proxyPassword);
    awsConf.setProxyDomain(conf.getTrimmed(PROXY_DOMAIN));
    awsConf.setProxyWorkstation(conf.getTrimmed(PROXY_WORKSTATION));
    if (LOG.isDebugEnabled()) {
      LOG.debug("Using proxy server {}:{} as user {} with password {} on " + "domain {} as workstation {}",awsConf.getProxyHost(),awsConf.getProxyPort(),String.valueOf(awsConf.getProxyUsername()),awsConf.getProxyPassword(),awsConf.getProxyDomain(),awsConf.getProxyWorkstation());
    }
  }
 else   if (proxyPort >= 0) {
    String msg="Proxy error: " + PROXY_PORT + " set without "+ PROXY_HOST;
    LOG.error(msg);
    throw new IllegalArgumentException(msg);
  }
  s3=new AmazonS3Client(credentials,awsConf);
  String endPoint=conf.getTrimmed(ENDPOINT,"");
  if (!endPoint.isEmpty()) {
    try {
      s3.setEndpoint(endPoint);
    }
 catch (    IllegalArgumentException e) {
      String msg="Incorrect endpoint: " + e.getMessage();
      LOG.error(msg);
      throw new IllegalArgumentException(msg,e);
    }
  }
  maxKeys=conf.getInt(MAX_PAGING_KEYS,DEFAULT_MAX_PAGING_KEYS);
  partSize=conf.getLong(MULTIPART_SIZE,DEFAULT_MULTIPART_SIZE);
  multiPartThreshold=conf.getLong(MIN_MULTIPART_THRESHOLD,DEFAULT_MIN_MULTIPART_THRESHOLD);
  if (partSize < 5 * 1024 * 1024) {
    LOG.error(MULTIPART_SIZE + " must be at least 5 MB");
    partSize=5 * 1024 * 1024;
  }
  if (multiPartThreshold < 5 * 1024 * 1024) {
    LOG.error(MIN_MULTIPART_THRESHOLD + " must be at least 5 MB");
    multiPartThreshold=5 * 1024 * 1024;
  }
  int maxThreads=conf.getInt(MAX_THREADS,DEFAULT_MAX_THREADS);
  int coreThreads=conf.getInt(CORE_THREADS,DEFAULT_CORE_THREADS);
  if (maxThreads == 0) {
    maxThreads=Runtime.getRuntime().availableProcessors() * 8;
  }
  if (coreThreads == 0) {
    coreThreads=Runtime.getRuntime().availableProcessors() * 8;
  }
  long keepAliveTime=conf.getLong(KEEPALIVE_TIME,DEFAULT_KEEPALIVE_TIME);
  LinkedBlockingQueue<Runnable> workQueue=new LinkedBlockingQueue<>(maxThreads * conf.getInt(MAX_TOTAL_TASKS,DEFAULT_MAX_TOTAL_TASKS));
  threadPoolExecutor=new ThreadPoolExecutor(coreThreads,maxThreads,keepAliveTime,TimeUnit.SECONDS,workQueue,newDaemonThreadFactory("s3a-transfer-shared-"));
  threadPoolExecutor.allowCoreThreadTimeOut(true);
  TransferManagerConfiguration transferConfiguration=new TransferManagerConfiguration();
  transferConfiguration.setMinimumUploadPartSize(partSize);
  transferConfiguration.setMultipartUploadThreshold(multiPartThreshold);
  transfers=new TransferManager(s3,threadPoolExecutor);
  transfers.setConfiguration(transferConfiguration);
  String cannedACLName=conf.get(CANNED_ACL,DEFAULT_CANNED_ACL);
  if (!cannedACLName.isEmpty()) {
    cannedACL=CannedAccessControlList.valueOf(cannedACLName);
  }
 else {
    cannedACL=null;
  }
  if (!s3.doesBucketExist(bucket)) {
    throw new IOException("Bucket " + bucket + " does not exist");
  }
  boolean purgeExistingMultipart=conf.getBoolean(PURGE_EXISTING_MULTIPART,DEFAULT_PURGE_EXISTING_MULTIPART);
  long purgeExistingMultipartAge=conf.getLong(PURGE_EXISTING_MULTIPART_AGE,DEFAULT_PURGE_EXISTING_MULTIPART_AGE);
  if (purgeExistingMultipart) {
    Date purgeBefore=new Date(new Date().getTime() - purgeExistingMultipartAge * 1000);
    transfers.abortMultipartUploads(bucket,purgeBefore);
  }
  serverSideEncryptionAlgorithm=conf.get(SERVER_SIDE_ENCRYPTION_ALGORITHM);
  setConf(conf);
}
