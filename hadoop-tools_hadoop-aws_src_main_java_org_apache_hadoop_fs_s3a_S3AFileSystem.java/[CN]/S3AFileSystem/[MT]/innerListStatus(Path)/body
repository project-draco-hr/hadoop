{
  String key=pathToKey(f);
  LOG.debug("List status for path: {}",f);
  incrementStatistic(INVOCATION_LIST_STATUS);
  final List<FileStatus> result=new ArrayList<FileStatus>();
  final FileStatus fileStatus=getFileStatus(f);
  if (fileStatus.isDirectory()) {
    if (!key.isEmpty()) {
      key=key + "/";
    }
    ListObjectsRequest request=new ListObjectsRequest();
    request.setBucketName(bucket);
    request.setPrefix(key);
    request.setDelimiter("/");
    request.setMaxKeys(maxKeys);
    LOG.debug("listStatus: doing listObjects for directory {}",key);
    ObjectListing objects=listObjects(request);
    Path fQualified=f.makeQualified(uri,workingDir);
    while (true) {
      for (      S3ObjectSummary summary : objects.getObjectSummaries()) {
        Path keyPath=keyToPath(summary.getKey()).makeQualified(uri,workingDir);
        if (keyPath.equals(fQualified) || summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {
          LOG.debug("Ignoring: {}",keyPath);
        }
 else {
          S3AFileStatus status=createFileStatus(keyPath,summary,getDefaultBlockSize(keyPath));
          result.add(status);
          LOG.debug("Adding: {}",status);
        }
      }
      for (      String prefix : objects.getCommonPrefixes()) {
        Path keyPath=keyToPath(prefix).makeQualified(uri,workingDir);
        if (!keyPath.equals(f)) {
          result.add(new S3AFileStatus(true,false,keyPath));
          LOG.debug("Adding: rd: {}",keyPath);
        }
      }
      if (objects.isTruncated()) {
        LOG.debug("listStatus: list truncated - getting next batch");
        objects=continueListObjects(objects);
      }
 else {
        break;
      }
    }
  }
 else {
    LOG.debug("Adding: rd (not a dir): {}",f);
    result.add(fileStatus);
  }
  return result.toArray(new FileStatus[result.size()]);
}
