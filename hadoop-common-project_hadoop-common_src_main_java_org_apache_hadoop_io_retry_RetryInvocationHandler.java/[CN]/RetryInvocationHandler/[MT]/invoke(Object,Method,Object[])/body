{
  RetryPolicy policy=methodNameToPolicyMap.get(method.getName());
  if (policy == null) {
    policy=defaultPolicy;
  }
  int invocationFailoverCount=0;
  final boolean isRpc=isRpcInvocation();
  final int callId=isRpc ? Client.nextCallId() : RpcConstants.INVALID_CALL_ID;
  int retries=0;
  while (true) {
    long invocationAttemptFailoverCount;
synchronized (proxyProvider) {
      invocationAttemptFailoverCount=proxyProviderFailoverCount;
    }
    if (isRpc) {
      Client.setCallIdAndRetryCount(callId,retries);
    }
    try {
      Object ret=invokeMethod(method,args);
      hasMadeASuccessfulCall=true;
      return ret;
    }
 catch (    Exception e) {
      boolean isMethodIdempotent=proxyProvider.getInterface().getMethod(method.getName(),method.getParameterTypes()).isAnnotationPresent(Idempotent.class);
      RetryAction action=policy.shouldRetry(e,retries++,invocationFailoverCount,isMethodIdempotent);
      if (action.action == RetryAction.RetryDecision.FAIL) {
        if (action.reason != null) {
          LOG.warn("Exception while invoking " + currentProxy.getClass() + "."+ method.getName()+ ". Not retrying because "+ action.reason,e);
        }
        throw e;
      }
 else {
        boolean worthLogging=!(invocationFailoverCount == 0 && !hasMadeASuccessfulCall);
        worthLogging|=LOG.isDebugEnabled();
        if (action.action == RetryAction.RetryDecision.FAILOVER_AND_RETRY && worthLogging) {
          String msg="Exception while invoking " + method.getName() + " of class "+ currentProxy.getClass().getSimpleName();
          if (invocationFailoverCount > 0) {
            msg+=" after " + invocationFailoverCount + " fail over attempts";
          }
          msg+=". Trying to fail over " + formatSleepMessage(action.delayMillis);
          if (LOG.isDebugEnabled()) {
            LOG.debug(msg,e);
          }
 else {
            LOG.warn(msg);
          }
        }
 else {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Exception while invoking " + method.getName() + " of class "+ currentProxy.getClass().getSimpleName()+ ". Retrying "+ formatSleepMessage(action.delayMillis),e);
          }
        }
        if (action.delayMillis > 0) {
          ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);
        }
        if (action.action == RetryAction.RetryDecision.FAILOVER_AND_RETRY) {
synchronized (proxyProvider) {
            if (invocationAttemptFailoverCount == proxyProviderFailoverCount) {
              proxyProvider.performFailover(currentProxy);
              proxyProviderFailoverCount++;
              currentProxy=proxyProvider.getProxy();
            }
 else {
              LOG.warn("A failover has occurred since the start of this method" + " invocation attempt.");
            }
          }
          invocationFailoverCount++;
        }
      }
    }
  }
}
