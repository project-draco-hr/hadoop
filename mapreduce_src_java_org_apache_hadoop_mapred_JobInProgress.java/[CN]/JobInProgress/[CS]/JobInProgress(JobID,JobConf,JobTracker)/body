{
  this.conf=conf;
  this.jobId=jobid;
  this.numMapTasks=conf.getNumMapTasks();
  this.numReduceTasks=conf.getNumReduceTasks();
  this.maxLevel=NetworkTopology.DEFAULT_HOST_LEVEL;
  this.anyCacheLevel=this.maxLevel + 1;
  this.jobtracker=tracker;
  this.restartCount=0;
  this.profile=new JobProfile(conf.getUser(),jobid,"","",conf.getJobName(),conf.getQueueName());
  this.memoryPerMap=conf.getMemoryForMapTask();
  this.memoryPerReduce=conf.getMemoryForReduceTask();
  this.maxTaskFailuresPerTracker=conf.getMaxTaskFailuresPerTracker();
  hasSpeculativeMaps=conf.getMapSpeculativeExecution();
  hasSpeculativeReduces=conf.getReduceSpeculativeExecution();
  this.nonLocalMaps=new LinkedList<TaskInProgress>();
  this.nonLocalRunningMaps=new LinkedHashSet<TaskInProgress>();
  this.runningMapCache=new IdentityHashMap<Node,Set<TaskInProgress>>();
  this.nonRunningReduces=new LinkedList<TaskInProgress>();
  this.runningReduces=new LinkedHashSet<TaskInProgress>();
  this.resourceEstimator=new ResourceEstimator(this);
  this.status=new JobStatus(jobid,0.0f,0.0f,JobStatus.PREP,this.profile.getUser(),this.profile.getJobName(),this.profile.getJobFile(),"");
  this.jobtracker.getInstrumentation().addPrepJob(conf,jobid);
  this.taskCompletionEvents=new ArrayList<TaskCompletionEvent>(numMapTasks + numReduceTasks + 10);
  this.slowTaskThreshold=Math.max(0.0f,conf.getFloat(MRJobConfig.SPECULATIVE_SLOWTASK_THRESHOLD,1.0f));
  this.speculativeCap=conf.getFloat(MRJobConfig.SPECULATIVECAP,0.1f);
  this.slowNodeThreshold=conf.getFloat(MRJobConfig.SPECULATIVE_SLOWNODE_THRESHOLD,1.0f);
  this.jobSetupCleanupNeeded=conf.getBoolean(MRJobConfig.SETUP_CLEANUP_NEEDED,true);
  this.taskCleanupNeeded=conf.getBoolean(MRJobConfig.TASK_CLEANUP_NEEDED,true);
  if (tracker != null) {
    this.jobHistory=tracker.getJobHistory();
  }
  this.tokenStorage=null;
}
