{
  if (lazyPreempionEnabled) {
    syncKillableContainersFromScheduler();
  }
  Set<String> partitions=new HashSet<>();
  partitions.addAll(scheduler.getRMContext().getNodeLabelManager().getClusterNodeLabelNames());
  partitions.add(RMNodeLabelsManager.NO_LABEL);
  this.allPartitions=ImmutableSet.copyOf(partitions);
synchronized (scheduler) {
    queueToPartitions.clear();
    for (    String partitionToLookAt : allPartitions) {
      cloneQueues(root,nlm.getResourceByLabel(partitionToLookAt,clusterResources),partitionToLookAt);
    }
  }
  this.leafQueueNames=ImmutableSet.copyOf(getLeafQueueNames(getQueueByPartition(CapacitySchedulerConfiguration.ROOT,RMNodeLabelsManager.NO_LABEL)));
  Resource totalPreemptionAllowed=Resources.multiply(clusterResources,percentageClusterPreemptionAllowed);
  Map<ApplicationAttemptId,Set<RMContainer>> toPreempt=null;
  for (  PreemptionCandidatesSelector selector : candidatesSelectionPolicies) {
    toPreempt=selector.selectCandidates(toPreempt,clusterResources,totalPreemptionAllowed);
  }
  if (LOG.isDebugEnabled()) {
    logToCSV(new ArrayList<>(leafQueueNames));
  }
  if (observeOnly) {
    return;
  }
  preemptOrkillSelectedContainerAfterWait(toPreempt);
  cleanupStaledPreemptionCandidates();
}
