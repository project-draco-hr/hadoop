{
  Set<String> allPartitions=new HashSet<>();
  allPartitions.addAll(scheduler.getRMContext().getNodeLabelManager().getClusterNodeLabelNames());
  allPartitions.add(RMNodeLabelsManager.NO_LABEL);
synchronized (scheduler) {
    queueToPartitions.clear();
    for (    String partitionToLookAt : allPartitions) {
      cloneQueues(root,nlm.getResourceByLabel(partitionToLookAt,clusterResources),partitionToLookAt);
    }
  }
  Resource totalPreemptionAllowed=Resources.multiply(clusterResources,percentageClusterPreemptionAllowed);
  Set<String> leafQueueNames=null;
  for (  String partition : allPartitions) {
    TempQueuePerPartition tRoot=getQueueByPartition(CapacitySchedulerConfiguration.ROOT,partition);
    tRoot.idealAssigned=tRoot.guaranteed;
    leafQueueNames=recursivelyComputeIdealAssignment(tRoot,totalPreemptionAllowed);
  }
  Map<ApplicationAttemptId,Set<RMContainer>> toPreempt=getContainersToPreempt(leafQueueNames,clusterResources);
  if (LOG.isDebugEnabled()) {
    logToCSV(new ArrayList<String>(leafQueueNames));
  }
  if (observeOnly) {
    return;
  }
  for (  Map.Entry<ApplicationAttemptId,Set<RMContainer>> e : toPreempt.entrySet()) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Send to scheduler: in app=" + e.getKey() + " #containers-to-be-preempted="+ e.getValue().size());
    }
    for (    RMContainer container : e.getValue()) {
      if (preempted.get(container) != null && preempted.get(container) + maxWaitTime < clock.getTime()) {
        dispatcher.handle(new ContainerPreemptEvent(e.getKey(),container,ContainerPreemptEventType.KILL_CONTAINER));
        preempted.remove(container);
      }
 else {
        dispatcher.handle(new ContainerPreemptEvent(e.getKey(),container,ContainerPreemptEventType.PREEMPT_CONTAINER));
        if (preempted.get(container) == null) {
          preempted.put(container,clock.getTime());
        }
      }
    }
  }
  for (Iterator<RMContainer> i=preempted.keySet().iterator(); i.hasNext(); ) {
    RMContainer id=i.next();
    if (preempted.get(id) + 2 * maxWaitTime < clock.getTime()) {
      i.remove();
    }
  }
}
