{
  Map<ApplicationAttemptId,Set<RMContainer>> list=new HashMap<ApplicationAttemptId,Set<RMContainer>>();
  for (  TempQueue qT : queues) {
    if (Resources.greaterThan(rc,clusterResource,qT.current,Resources.multiply(qT.guaranteed,1.0 + maxIgnoredOverCapacity))) {
      Resource resToObtain=Resources.multiply(qT.toBePreempted,naturalTerminationFactor);
synchronized (qT.leafQueue) {
        NavigableSet<FiCaSchedulerApp> ns=(NavigableSet<FiCaSchedulerApp>)qT.leafQueue.getApplications();
        Iterator<FiCaSchedulerApp> desc=ns.descendingIterator();
        qT.actuallyPreempted=Resources.clone(resToObtain);
        while (desc.hasNext()) {
          FiCaSchedulerApp fc=desc.next();
          if (Resources.lessThanOrEqual(rc,clusterResource,resToObtain,Resources.none())) {
            break;
          }
          list.put(fc.getApplicationAttemptId(),preemptFrom(fc,clusterResource,resToObtain));
        }
      }
    }
  }
  return list;
}
