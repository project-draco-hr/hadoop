{
  Map<ApplicationAttemptId,Set<RMContainer>> preemptMap=new HashMap<ApplicationAttemptId,Set<RMContainer>>();
  List<RMContainer> skippedAMContainerlist=new ArrayList<RMContainer>();
  for (  TempQueue qT : queues) {
    if (Resources.greaterThan(rc,clusterResource,qT.current,Resources.multiply(qT.guaranteed,1.0 + maxIgnoredOverCapacity))) {
      Resource resToObtain=Resources.multiply(qT.toBePreempted,naturalTerminationFactor);
      Resource skippedAMSize=Resource.newInstance(0,0);
synchronized (qT.leafQueue) {
        NavigableSet<FiCaSchedulerApp> ns=(NavigableSet<FiCaSchedulerApp>)qT.leafQueue.getApplications();
        Iterator<FiCaSchedulerApp> desc=ns.descendingIterator();
        qT.actuallyPreempted=Resources.clone(resToObtain);
        while (desc.hasNext()) {
          FiCaSchedulerApp fc=desc.next();
          if (Resources.lessThanOrEqual(rc,clusterResource,resToObtain,Resources.none())) {
            break;
          }
          preemptMap.put(fc.getApplicationAttemptId(),preemptFrom(fc,clusterResource,resToObtain,skippedAMContainerlist,skippedAMSize));
        }
        Resource maxAMCapacityForThisQueue=Resources.multiply(Resources.multiply(clusterResource,qT.leafQueue.getAbsoluteCapacity()),qT.leafQueue.getMaxAMResourcePerQueuePercent());
        preemptAMContainers(clusterResource,preemptMap,skippedAMContainerlist,resToObtain,skippedAMSize,maxAMCapacityForThisQueue);
      }
    }
  }
  return preemptMap;
}
