{
  TempQueuePerPartition ret;
synchronized (curQueue) {
    String queueName=curQueue.getQueueName();
    QueueCapacities qc=curQueue.getQueueCapacities();
    float absCap=qc.getAbsoluteCapacity(partitionToLookAt);
    float absMaxCap=qc.getAbsoluteMaximumCapacity(partitionToLookAt);
    boolean preemptionDisabled=curQueue.getPreemptionDisabled();
    Resource current=Resources.clone(curQueue.getQueueResourceUsage().getUsed(partitionToLookAt));
    Resource killable=Resources.none();
    Resource reserved=Resources.clone(curQueue.getQueueResourceUsage().getReserved(partitionToLookAt));
    if (null != preemptableQueues.get(queueName)) {
      killable=Resources.clone(preemptableQueues.get(queueName).getKillableResource(partitionToLookAt));
    }
    try {
      if (!scheduler.getRMContext().getNodeLabelManager().isExclusiveNodeLabel(partitionToLookAt)) {
        absMaxCap=1.0f;
      }
    }
 catch (    IOException e) {
    }
    ret=new TempQueuePerPartition(queueName,current,preemptionDisabled,partitionToLookAt,killable,absCap,absMaxCap,partitionResource,reserved,curQueue);
    if (curQueue instanceof ParentQueue) {
      for (      CSQueue c : curQueue.getChildQueues()) {
        TempQueuePerPartition subq=cloneQueues(c,partitionResource,partitionToLookAt);
        ret.addChild(subq);
      }
    }
  }
  addTempQueuePartition(ret);
  return ret;
}
