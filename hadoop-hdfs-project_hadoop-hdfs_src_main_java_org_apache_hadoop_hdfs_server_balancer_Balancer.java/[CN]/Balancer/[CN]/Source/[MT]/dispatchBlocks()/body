{
  long startTime=Time.now();
  long scheduledSize=getScheduledSize();
  this.blocksToReceive=2 * scheduledSize;
  boolean isTimeUp=false;
  int noPendingBlockIteration=0;
  while (!isTimeUp && getScheduledSize() > 0 && (!srcBlockList.isEmpty() || blocksToReceive > 0)) {
    PendingBlockMove pendingBlock=chooseNextBlockToMove();
    if (pendingBlock != null) {
      pendingBlock.scheduleBlockMove();
      continue;
    }
    filterMovedBlocks();
    if (shouldFetchMoreBlocks()) {
      try {
        blocksToReceive-=getBlockList();
        continue;
      }
 catch (      IOException e) {
        LOG.warn("Exception while getting block list",e);
        return;
      }
    }
 else {
      noPendingBlockIteration++;
      if (noPendingBlockIteration >= MAX_NO_PENDING_BLOCK_ITERATIONS) {
        setScheduledSize(0);
      }
    }
    if (Time.now() - startTime > MAX_ITERATION_TIME) {
      isTimeUp=true;
      continue;
    }
    try {
synchronized (Balancer.this) {
        Balancer.this.wait(1000);
      }
    }
 catch (    InterruptedException ignored) {
    }
  }
}
