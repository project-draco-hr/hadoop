{
  final long size=Math.min(MAX_BLOCKS_SIZE_TO_FETCH,blocksToReceive);
  final BlockWithLocations[] newBlocks=nnc.namenode.getBlocks(getDatanode(),size).getBlocks();
  long bytesReceived=0;
  for (  BlockWithLocations blk : newBlocks) {
    bytesReceived+=blk.getBlock().getNumBytes();
    BalancerBlock block;
synchronized (globalBlockList) {
      block=globalBlockList.get(blk.getBlock());
      if (block == null) {
        block=new BalancerBlock(blk.getBlock());
        globalBlockList.put(blk.getBlock(),block);
      }
 else {
        block.clearLocations();
      }
synchronized (block) {
        final String[] datanodeUuids=blk.getDatanodeUuids();
        final StorageType[] storageTypes=blk.getStorageTypes();
        for (int i=0; i < datanodeUuids.length; i++) {
          final BalancerDatanode.StorageGroup g=storageGroupMap.get(datanodeUuids[i],storageTypes[i]);
          if (g != null) {
            block.addLocation(g);
          }
        }
      }
      if (!srcBlockList.contains(block) && isGoodBlockCandidate(block)) {
        srcBlockList.add(block);
      }
    }
  }
  return bytesReceived;
}
