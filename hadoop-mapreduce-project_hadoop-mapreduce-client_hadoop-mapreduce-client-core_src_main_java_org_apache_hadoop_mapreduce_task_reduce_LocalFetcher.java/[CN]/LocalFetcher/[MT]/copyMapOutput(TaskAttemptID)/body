{
  Path mapOutputFileName=localMapFiles.get(mapTaskId).getOutputFile();
  Path indexFileName=mapOutputFileName.suffix(".index");
  SpillRecord sr=new SpillRecord(indexFileName,job);
  IndexRecord ir=sr.getIndex(reduce);
  long compressedLength=ir.partLength;
  long decompressedLength=ir.rawLength;
  compressedLength-=CryptoUtils.cryptoPadding(job);
  decompressedLength-=CryptoUtils.cryptoPadding(job);
  MapOutput<K,V> mapOutput=merger.reserve(mapTaskId,decompressedLength,id);
  if (mapOutput == null) {
    LOG.info("fetcher#" + id + " - MergeManager returned Status.WAIT ...");
    return false;
  }
  LOG.info("localfetcher#" + id + " about to shuffle output of map "+ mapOutput.getMapId()+ " decomp: "+ decompressedLength+ " len: "+ compressedLength+ " to "+ mapOutput.getDescription());
  FileSystem localFs=FileSystem.getLocal(job).getRaw();
  FSDataInputStream inStream=localFs.open(mapOutputFileName);
  inStream=CryptoUtils.wrapIfNecessary(job,inStream);
  try {
    inStream.seek(ir.startOffset + CryptoUtils.cryptoPadding(job));
    mapOutput.shuffle(LOCALHOST,inStream,compressedLength,decompressedLength,metrics,reporter);
  }
  finally {
    try {
      inStream.close();
    }
 catch (    IOException ioe) {
      LOG.warn("IOException closing inputstream from map output: " + ioe.toString());
    }
  }
  scheduler.copySucceeded(mapTaskId,LOCALHOST,compressedLength,0,0,mapOutput);
  return true;
}
