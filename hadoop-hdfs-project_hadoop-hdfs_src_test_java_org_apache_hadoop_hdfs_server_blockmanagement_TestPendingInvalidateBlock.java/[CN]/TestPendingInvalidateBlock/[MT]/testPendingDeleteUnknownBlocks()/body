{
  final int fileNum=5;
  final Path[] files=new Path[fileNum];
  final DataNodeProperties[] dnprops=new DataNodeProperties[REPLICATION];
  for (int i=0; i < fileNum; i++) {
    files[i]=new Path("/file" + i);
    DFSTestUtil.createFile(dfs,files[i],BLOCKSIZE,REPLICATION,i);
  }
  waitForReplication();
  for (int i=REPLICATION - 1; i >= 0; i--) {
    dnprops[i]=cluster.stopDataNode(i);
  }
  Thread.sleep(2000);
  for (int i=0; i < 2; i++) {
    dfs.delete(files[i],true);
  }
  cluster.restartNameNode(false);
  InvalidateBlocks invalidateBlocks=(InvalidateBlocks)Whitebox.getInternalState(cluster.getNamesystem().getBlockManager(),"invalidateBlocks");
  InvalidateBlocks mockIb=Mockito.spy(invalidateBlocks);
  Mockito.doReturn(1L).when(mockIb).getInvalidationDelay();
  Whitebox.setInternalState(cluster.getNamesystem().getBlockManager(),"invalidateBlocks",mockIb);
  Assert.assertEquals(0L,cluster.getNamesystem().getPendingDeletionBlocks());
  for (int i=0; i < REPLICATION; i++) {
    cluster.restartDataNode(dnprops[i],true);
  }
  cluster.waitActive();
  for (int i=0; i < REPLICATION; i++) {
    DataNodeTestUtils.triggerBlockReport(cluster.getDataNodes().get(i));
  }
  Thread.sleep(2000);
  Assert.assertEquals(3,cluster.getNamesystem().getBlocksTotal());
  Assert.assertEquals(4,cluster.getNamesystem().getPendingDeletionBlocks());
  cluster.restartNameNode(true);
  Thread.sleep(6000);
  Assert.assertEquals(3,cluster.getNamesystem().getBlocksTotal());
  Assert.assertEquals(0,cluster.getNamesystem().getPendingDeletionBlocks());
}
