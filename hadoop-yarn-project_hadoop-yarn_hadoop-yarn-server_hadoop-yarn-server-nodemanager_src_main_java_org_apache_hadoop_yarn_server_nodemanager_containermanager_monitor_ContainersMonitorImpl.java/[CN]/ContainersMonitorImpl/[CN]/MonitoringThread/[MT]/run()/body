{
  while (true) {
    if (LOG.isDebugEnabled()) {
      StringBuilder tmp=new StringBuilder("[ ");
      for (      ProcessTreeInfo p : trackingContainers.values()) {
        tmp.append(p.getPID());
        tmp.append(" ");
      }
      LOG.debug("Current ProcessTree list : " + tmp.substring(0,tmp.length()) + "]");
    }
synchronized (containersToBeAdded) {
      for (      Entry<ContainerId,ProcessTreeInfo> entry : containersToBeAdded.entrySet()) {
        ContainerId containerId=entry.getKey();
        ProcessTreeInfo processTreeInfo=entry.getValue();
        LOG.info("Starting resource-monitoring for " + containerId);
        trackingContainers.put(containerId,processTreeInfo);
      }
      containersToBeAdded.clear();
    }
synchronized (containersToBeRemoved) {
      for (      ContainerId containerId : containersToBeRemoved) {
        if (containerMetricsEnabled) {
          ContainerMetrics.forContainer(containerId,containerMetricsPeriodMs).finished();
        }
        trackingContainers.remove(containerId);
        LOG.info("Stopping resource-monitoring for " + containerId);
      }
      containersToBeRemoved.clear();
    }
    long vmemUsageByAllContainers=0;
    long pmemByAllContainers=0;
    long cpuUsagePercentPerCoreByAllContainers=0;
    long cpuUsageTotalCoresByAllContainers=0;
    for (Iterator<Map.Entry<ContainerId,ProcessTreeInfo>> it=trackingContainers.entrySet().iterator(); it.hasNext(); ) {
      Map.Entry<ContainerId,ProcessTreeInfo> entry=it.next();
      ContainerId containerId=entry.getKey();
      ProcessTreeInfo ptInfo=entry.getValue();
      try {
        String pId=ptInfo.getPID();
        if (pId == null) {
          pId=containerExecutor.getProcessId(ptInfo.getContainerId());
          if (pId != null) {
            LOG.debug("Tracking ProcessTree " + pId + " for the first time");
            ResourceCalculatorProcessTree pt=ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId,processTreeClass,conf);
            ptInfo.setPid(pId);
            ptInfo.setProcessTree(pt);
            if (containerMetricsEnabled) {
              ContainerMetrics usageMetrics=ContainerMetrics.forContainer(containerId,containerMetricsPeriodMs);
              int cpuVcores=ptInfo.getCpuVcores();
              final int vmemLimit=(int)(ptInfo.getVmemLimit() >> 20);
              final int pmemLimit=(int)(ptInfo.getPmemLimit() >> 20);
              usageMetrics.recordResourceLimit(vmemLimit,pmemLimit,cpuVcores);
              usageMetrics.recordProcessId(pId);
            }
          }
        }
        if (pId == null) {
          continue;
        }
        LOG.debug("Constructing ProcessTree for : PID = " + pId + " ContainerId = "+ containerId);
        ResourceCalculatorProcessTree pTree=ptInfo.getProcessTree();
        pTree.updateProcessTree();
        long currentVmemUsage=pTree.getVirtualMemorySize();
        long currentPmemUsage=pTree.getRssMemorySize();
        float cpuUsagePercentPerCore=pTree.getCpuUsagePercent();
        float cpuUsageTotalCoresPercentage=cpuUsagePercentPerCore / resourceCalculatorPlugin.getNumProcessors();
        int milliVcoresUsed=(int)(cpuUsageTotalCoresPercentage * 1000 * maxVCoresAllottedForContainers / nodeCpuPercentageForYARN);
        long curMemUsageOfAgedProcesses=pTree.getVirtualMemorySize(1);
        long curRssMemUsageOfAgedProcesses=pTree.getRssMemorySize(1);
        long vmemLimit=ptInfo.getVmemLimit();
        long pmemLimit=ptInfo.getPmemLimit();
        if (LOG.isDebugEnabled()) {
          LOG.debug(String.format("Memory usage of ProcessTree %s for container-id %s: ",pId,containerId.toString()) + formatUsageString(currentVmemUsage,vmemLimit,currentPmemUsage,pmemLimit));
        }
        if (containerMetricsEnabled) {
          ContainerMetrics.forContainer(containerId,containerMetricsPeriodMs).recordMemoryUsage((int)(currentPmemUsage >> 20));
          ContainerMetrics.forContainer(containerId,containerMetricsPeriodMs).recordCpuUsage((int)cpuUsagePercentPerCore,milliVcoresUsed);
        }
        boolean isMemoryOverLimit=false;
        String msg="";
        int containerExitStatus=ContainerExitStatus.INVALID;
        if (isVmemCheckEnabled() && isProcessTreeOverLimit(containerId.toString(),currentVmemUsage,curMemUsageOfAgedProcesses,vmemLimit)) {
          msg=formatErrorMessage("virtual",currentVmemUsage,vmemLimit,currentPmemUsage,pmemLimit,pId,containerId,pTree);
          isMemoryOverLimit=true;
          containerExitStatus=ContainerExitStatus.KILLED_EXCEEDED_VMEM;
        }
 else         if (isPmemCheckEnabled() && isProcessTreeOverLimit(containerId.toString(),currentPmemUsage,curRssMemUsageOfAgedProcesses,pmemLimit)) {
          msg=formatErrorMessage("physical",currentVmemUsage,vmemLimit,currentPmemUsage,pmemLimit,pId,containerId,pTree);
          isMemoryOverLimit=true;
          containerExitStatus=ContainerExitStatus.KILLED_EXCEEDED_PMEM;
        }
        vmemUsageByAllContainers+=currentVmemUsage;
        pmemByAllContainers+=currentPmemUsage;
        cpuUsagePercentPerCoreByAllContainers+=cpuUsagePercentPerCore;
        cpuUsageTotalCoresByAllContainers+=cpuUsagePercentPerCore;
        if (isMemoryOverLimit) {
          LOG.warn(msg);
          if (!pTree.checkPidPgrpidForMatch()) {
            LOG.error("Killed container process with PID " + pId + " but it is not a process group leader.");
          }
          eventDispatcher.getEventHandler().handle(new ContainerKillEvent(containerId,containerExitStatus,msg));
          it.remove();
          LOG.info("Removed ProcessTree with root " + pId);
        }
      }
 catch (      Exception e) {
        LOG.warn("Uncaught exception in ContainerMemoryManager " + "while managing memory of " + containerId,e);
      }
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("Total Resource Usage stats in NM by all containers : " + "Virtual Memory= " + vmemUsageByAllContainers + ", Physical Memory= "+ pmemByAllContainers+ ", Total CPU usage= "+ cpuUsageTotalCoresByAllContainers+ ", Total CPU(% per core) usage"+ cpuUsagePercentPerCoreByAllContainers);
    }
    try {
      Thread.sleep(monitoringInterval);
    }
 catch (    InterruptedException e) {
      LOG.warn(ContainersMonitorImpl.class.getName() + " is interrupted. Exiting.");
      break;
    }
  }
}
