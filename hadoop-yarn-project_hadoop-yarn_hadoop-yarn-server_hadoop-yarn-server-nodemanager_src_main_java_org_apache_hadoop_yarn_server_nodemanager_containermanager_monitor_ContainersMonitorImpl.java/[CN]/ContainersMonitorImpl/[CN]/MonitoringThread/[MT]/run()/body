{
  while (!stopped && !Thread.currentThread().isInterrupted()) {
    if (LOG.isDebugEnabled()) {
      StringBuilder tmp=new StringBuilder("[ ");
      for (      ProcessTreeInfo p : trackingContainers.values()) {
        tmp.append(p.getPID());
        tmp.append(" ");
      }
      LOG.debug("Current ProcessTree list : " + tmp.substring(0,tmp.length()) + "]");
    }
    ResourceUtilization trackedContainersUtilization=ResourceUtilization.newInstance(0,0,0.0f);
    long vmemUsageByAllContainers=0;
    long pmemByAllContainers=0;
    long cpuUsagePercentPerCoreByAllContainers=0;
    long cpuUsageTotalCoresByAllContainers=0;
    for (    Entry<ContainerId,ProcessTreeInfo> entry : trackingContainers.entrySet()) {
      ContainerId containerId=entry.getKey();
      ProcessTreeInfo ptInfo=entry.getValue();
      ContainerEntity entity=new ContainerEntity();
      entity.setId(containerId.toString());
      try {
        String pId=ptInfo.getPID();
        if (pId == null) {
          pId=containerExecutor.getProcessId(ptInfo.getContainerId());
          if (pId != null) {
            LOG.debug("Tracking ProcessTree " + pId + " for the first time");
            ResourceCalculatorProcessTree pt=ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId,processTreeClass,conf);
            ptInfo.setPid(pId);
            ptInfo.setProcessTree(pt);
            if (containerMetricsEnabled) {
              ContainerMetrics usageMetrics=ContainerMetrics.forContainer(containerId,containerMetricsPeriodMs,containerMetricsUnregisterDelayMs);
              usageMetrics.recordProcessId(pId);
            }
          }
        }
        if (pId == null) {
          continue;
        }
        LOG.debug("Constructing ProcessTree for : PID = " + pId + " ContainerId = "+ containerId);
        ResourceCalculatorProcessTree pTree=ptInfo.getProcessTree();
        pTree.updateProcessTree();
        long currentVmemUsage=pTree.getVirtualMemorySize();
        long currentPmemUsage=pTree.getRssMemorySize();
        long currentTime=System.currentTimeMillis();
        float cpuUsagePercentPerCore=pTree.getCpuUsagePercent();
        if (cpuUsagePercentPerCore < 0) {
          LOG.info("Skipping monitoring container " + containerId + " since CPU usage is not yet available.");
          continue;
        }
        float cpuUsageTotalCoresPercentage=cpuUsagePercentPerCore / resourceCalculatorPlugin.getNumProcessors();
        int milliVcoresUsed=(int)(cpuUsageTotalCoresPercentage * 1000 * maxVCoresAllottedForContainers / nodeCpuPercentageForYARN);
        long curMemUsageOfAgedProcesses=pTree.getVirtualMemorySize(1);
        long curRssMemUsageOfAgedProcesses=pTree.getRssMemorySize(1);
        long vmemLimit=ptInfo.getVmemLimit();
        long pmemLimit=ptInfo.getPmemLimit();
        if (LOG.isDebugEnabled()) {
          LOG.debug(String.format("Memory usage of ProcessTree %s for container-id %s: ",pId,containerId.toString()) + formatUsageString(currentVmemUsage,vmemLimit,currentPmemUsage,pmemLimit));
        }
        trackedContainersUtilization.addTo((int)(currentPmemUsage >> 20),(int)(currentVmemUsage >> 20),milliVcoresUsed / 1000.0f);
        if (containerMetricsEnabled) {
          ContainerMetrics.forContainer(containerId,containerMetricsPeriodMs,containerMetricsUnregisterDelayMs).recordMemoryUsage((int)(currentPmemUsage >> 20));
          ContainerMetrics.forContainer(containerId,containerMetricsPeriodMs,containerMetricsUnregisterDelayMs).recordCpuUsage((int)cpuUsagePercentPerCore,milliVcoresUsed);
        }
        if (publishContainerMetricsToTimelineService) {
          if (currentPmemUsage != ResourceCalculatorProcessTree.UNAVAILABLE) {
            TimelineMetric memoryMetric=new TimelineMetric();
            memoryMetric.setId(ContainerMetric.MEMORY.toString() + pId);
            memoryMetric.addTimeSeriesData(currentTime,currentPmemUsage);
            entity.addMetric(memoryMetric);
          }
          if (cpuUsageTotalCoresPercentage != ResourceCalculatorProcessTree.UNAVAILABLE) {
            TimelineMetric cpuMetric=new TimelineMetric();
            cpuMetric.setId(ContainerMetric.CPU.toString() + pId);
            cpuMetric.addTimeSeriesData(currentTime,cpuUsageTotalCoresPercentage);
            entity.addMetric(cpuMetric);
          }
        }
        boolean isMemoryOverLimit=false;
        String msg="";
        int containerExitStatus=ContainerExitStatus.INVALID;
        if (isVmemCheckEnabled() && isProcessTreeOverLimit(containerId.toString(),currentVmemUsage,curMemUsageOfAgedProcesses,vmemLimit)) {
          msg=formatErrorMessage("virtual",currentVmemUsage,vmemLimit,currentPmemUsage,pmemLimit,pId,containerId,pTree);
          isMemoryOverLimit=true;
          containerExitStatus=ContainerExitStatus.KILLED_EXCEEDED_VMEM;
        }
 else         if (isPmemCheckEnabled() && isProcessTreeOverLimit(containerId.toString(),currentPmemUsage,curRssMemUsageOfAgedProcesses,pmemLimit)) {
          msg=formatErrorMessage("physical",currentVmemUsage,vmemLimit,currentPmemUsage,pmemLimit,pId,containerId,pTree);
          isMemoryOverLimit=true;
          containerExitStatus=ContainerExitStatus.KILLED_EXCEEDED_PMEM;
        }
        vmemUsageByAllContainers+=currentVmemUsage;
        pmemByAllContainers+=currentPmemUsage;
        cpuUsagePercentPerCoreByAllContainers+=cpuUsagePercentPerCore;
        cpuUsageTotalCoresByAllContainers+=cpuUsagePercentPerCore;
        if (isMemoryOverLimit) {
          LOG.warn(msg);
          if (!pTree.checkPidPgrpidForMatch()) {
            LOG.error("Killed container process with PID " + pId + " but it is not a process group leader.");
          }
          eventDispatcher.getEventHandler().handle(new ContainerKillEvent(containerId,containerExitStatus,msg));
          trackingContainers.remove(containerId);
          LOG.info("Removed ProcessTree with root " + pId);
        }
      }
 catch (      Exception e) {
        LOG.warn("Uncaught exception in ContainersMonitorImpl " + "while monitoring resource of " + containerId,e);
      }
      if (publishContainerMetricsToTimelineService) {
        try {
          TimelineClient timelineClient=context.getApplications().get(containerId.getApplicationAttemptId().getApplicationId()).getTimelineClient();
          putEntityWithoutBlocking(timelineClient,entity);
        }
 catch (        Exception e) {
          LOG.error("Exception in ContainersMonitorImpl in putting " + "resource usage metrics to timeline service.",e);
        }
      }
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("Total Resource Usage stats in NM by all containers : " + "Virtual Memory= " + vmemUsageByAllContainers + ", Physical Memory= "+ pmemByAllContainers+ ", Total CPU usage= "+ cpuUsageTotalCoresByAllContainers+ ", Total CPU(% per core) usage"+ cpuUsagePercentPerCoreByAllContainers);
    }
    setContainersUtilization(trackedContainersUtilization);
    try {
      Thread.sleep(monitoringInterval);
    }
 catch (    InterruptedException e) {
      LOG.warn(ContainersMonitorImpl.class.getName() + " is interrupted. Exiting.");
      break;
    }
  }
}
