{
  final List<InputSplit> splits=new ArrayList<InputSplit>();
  final int reds=(mapTasksOnly) ? 0 : jobdesc.getNumberReduces();
  final int maps=jobdesc.getNumberMaps();
  for (int i=0; i < maps; ++i) {
    final int nSpec=reds / maps + ((reds % maps) > i ? 1 : 0);
    final long[] redDurations=new long[nSpec];
    for (int j=0; j < nSpec; ++j) {
      final ReduceTaskAttemptInfo info=(ReduceTaskAttemptInfo)getSuccessfulAttemptInfo(TaskType.REDUCE,i + j * maps);
      redDurations[j]=Math.min(reduceMaxSleepTime,info.getMergeRuntime() + info.getReduceRuntime());
      if (LOG.isDebugEnabled()) {
        LOG.debug(String.format("SPEC(%d) %d -> %d %d/%d",id(),i,i + j * maps,redDurations[j],info.getRuntime()));
      }
    }
    final TaskAttemptInfo info=getSuccessfulAttemptInfo(TaskType.MAP,i);
    ArrayList<String> locations=new ArrayList<String>(fakeLocations);
    if (fakeLocations > 0) {
      selector.reset();
    }
    for (int k=0; k < fakeLocations; ++k) {
      int index=selector.next();
      if (index < 0)       break;
      locations.add(hosts[index]);
    }
    splits.add(new SleepSplit(i,Math.min(info.getRuntime(),mapMaxSleepTime),redDurations,maps,locations.toArray(new String[locations.size()])));
  }
  pushDescription(id(),splits);
}
