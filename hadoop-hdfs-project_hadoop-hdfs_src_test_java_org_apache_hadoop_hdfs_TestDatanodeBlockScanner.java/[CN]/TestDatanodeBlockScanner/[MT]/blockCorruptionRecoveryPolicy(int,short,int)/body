{
  Configuration conf=new HdfsConfiguration();
  conf.setLong(DFSConfigKeys.DFS_BLOCKREPORT_INTERVAL_MSEC_KEY,30L);
  conf.setLong(DFSConfigKeys.DFS_NAMENODE_REPLICATION_INTERVAL_KEY,3);
  conf.setLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,3L);
  conf.setBoolean(DFSConfigKeys.DFS_NAMENODE_REPLICATION_CONSIDERLOAD_KEY,false);
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(numDataNodes).build();
  cluster.waitActive();
  FileSystem fs=cluster.getFileSystem();
  Path file1=new Path("/tmp/testBlockCorruptRecovery/file");
  DFSTestUtil.createFile(fs,file1,1024,numReplicas,0);
  ExtendedBlock block=DFSTestUtil.getFirstBlock(fs,file1);
  DFSTestUtil.waitReplication(fs,file1,numReplicas);
  int[] corruptReplicasDNIDs=new int[numCorruptReplicas];
  for (int i=0, j=0; (j != numCorruptReplicas) && (i < numDataNodes); i++) {
    if (corruptReplica(block,i)) {
      corruptReplicasDNIDs[j++]=i;
      LOG.info("successfully corrupted block " + block + " on node "+ i+ " "+ cluster.getDataNodes().get(i).getDisplayName());
    }
  }
  for (int i=numCorruptReplicas - 1; i >= 0; i--) {
    LOG.info("restarting node with corrupt replica: position " + i + " node "+ corruptReplicasDNIDs[i]+ " "+ cluster.getDataNodes().get(corruptReplicasDNIDs[i]).getDisplayName());
    cluster.restartDataNode(corruptReplicasDNIDs[i]);
  }
  DFSTestUtil.waitCorruptReplicas(fs,cluster.getNamesystem(),file1,block,numCorruptReplicas);
  DFSTestUtil.waitReplication(fs,file1,numReplicas);
  assertFalse(DFSTestUtil.allBlockReplicasCorrupt(cluster,file1,0));
  DFSTestUtil.waitCorruptReplicas(fs,cluster.getNamesystem(),file1,block,0);
  cluster.shutdown();
}
