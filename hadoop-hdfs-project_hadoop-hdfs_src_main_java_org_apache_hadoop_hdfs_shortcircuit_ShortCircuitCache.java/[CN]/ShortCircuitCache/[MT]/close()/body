{
  try {
    lock.lock();
    if (closed)     return;
    closed=true;
    LOG.info(this + ": closing");
    maxNonMmappedEvictableLifespanMs=0;
    maxEvictableMmapedSize=0;
    IOUtils.cleanup(LOG,cacheCleaner);
    while (true) {
      Entry<Long,ShortCircuitReplica> entry=evictable.firstEntry();
      if (entry == null)       break;
      purge(entry.getValue());
    }
    while (true) {
      Entry<Long,ShortCircuitReplica> entry=evictableMmapped.firstEntry();
      if (entry == null)       break;
      purge(entry.getValue());
    }
  }
  finally {
    lock.unlock();
  }
  releaserExecutor.shutdown();
  cleanerExecutor.shutdown();
  try {
    if (!releaserExecutor.awaitTermination(30,TimeUnit.SECONDS)) {
      LOG.error("Forcing SlotReleaserThreadPool to shutdown!");
      releaserExecutor.shutdownNow();
    }
  }
 catch (  InterruptedException e) {
    releaserExecutor.shutdownNow();
    Thread.currentThread().interrupt();
    LOG.error("Interrupted while waiting for SlotReleaserThreadPool " + "to terminate",e);
  }
  try {
    if (!cleanerExecutor.awaitTermination(30,TimeUnit.SECONDS)) {
      LOG.error("Forcing CleanerThreadPool to shutdown!");
      cleanerExecutor.shutdownNow();
    }
  }
 catch (  InterruptedException e) {
    cleanerExecutor.shutdownNow();
    Thread.currentThread().interrupt();
    LOG.error("Interrupted while waiting for CleanerThreadPool " + "to terminate",e);
  }
  IOUtils.cleanup(LOG,shmManager);
}
