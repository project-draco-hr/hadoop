{
  this.remoteRootLogDir=new Path(conf.get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));
  this.remoteRootLogDirSuffix=conf.get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR_SUFFIX,YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR_SUFFIX);
  int threadPoolSize=getAggregatorThreadPoolSize(conf);
  this.threadPool=HadoopExecutors.newFixedThreadPool(threadPoolSize,new ThreadFactoryBuilder().setNameFormat("LogAggregationService #%d").build());
  rollingMonitorInterval=conf.getLong(YarnConfiguration.NM_LOG_AGGREGATION_ROLL_MONITORING_INTERVAL_SECONDS,YarnConfiguration.DEFAULT_NM_LOG_AGGREGATION_ROLL_MONITORING_INTERVAL_SECONDS);
  boolean logAggregationDebugMode=conf.getBoolean(NM_LOG_AGGREGATION_DEBUG_ENABLED,false);
  if (rollingMonitorInterval > 0 && rollingMonitorInterval < MIN_LOG_ROLLING_INTERVAL) {
    if (logAggregationDebugMode) {
      LOG.info("Log aggregation debug mode enabled. rollingMonitorInterval = " + rollingMonitorInterval);
    }
 else {
      LOG.warn("rollingMonitorIntervall should be more than or equal to " + MIN_LOG_ROLLING_INTERVAL + " seconds. Using "+ MIN_LOG_ROLLING_INTERVAL+ " seconds instead.");
      this.rollingMonitorInterval=MIN_LOG_ROLLING_INTERVAL;
    }
  }
 else   if (rollingMonitorInterval <= 0) {
    LOG.info("rollingMonitorInterval is set as " + rollingMonitorInterval + ". The log rolling monitoring interval is disabled. "+ "The logs will be aggregated after this application is finished.");
  }
 else {
    LOG.info("rollingMonitorInterval is set as " + rollingMonitorInterval + ". The logs will be aggregated every "+ rollingMonitorInterval+ " seconds");
  }
  super.serviceInit(conf);
}
