{
  html._(MetricsOverviewTable.class);
  ResourceScheduler sched=rm.getResourceScheduler();
  String type=$(NODE_STATE);
  TBODY<TABLE<Hamlet>> tbody=html.table("#nodes").thead().tr().th(".rack","Rack").th(".state","Node State").th(".nodeaddress","Node Address").th(".nodehttpaddress","Node HTTP Address").th(".healthStatus","Health-status").th(".lastHealthUpdate","Last health-update").th(".healthReport","Health-report").th(".containers","Containers").th(".mem","Mem Used").th(".mem","Mem Avail")._()._().tbody();
  RMNodeState stateFilter=null;
  if (type != null && !type.isEmpty()) {
    stateFilter=RMNodeState.valueOf(type.toUpperCase());
  }
  Collection<RMNode> rmNodes=this.rmContext.getRMNodes().values();
  boolean isInactive=false;
  if (stateFilter != null) {
switch (stateFilter) {
case DECOMMISSIONED:
case LOST:
case REBOOTED:
      rmNodes=this.rmContext.getInactiveRMNodes().values();
    isInactive=true;
  break;
}
}
for (RMNode ni : rmNodes) {
if (stateFilter != null) {
RMNodeState state=ni.getState();
if (!stateFilter.equals(state)) {
  continue;
}
}
NodeInfo info=new NodeInfo(ni,sched);
int usedMemory=(int)info.getUsedMemory();
int availableMemory=(int)info.getAvailableMemory();
TR<TBODY<TABLE<Hamlet>>> row=tbody.tr().td(info.getRack()).td(info.getState()).td(info.getNodeId());
if (isInactive) {
row.td()._("N/A")._();
}
 else {
String httpAddress=info.getNodeHTTPAddress();
row.td().a("http://" + httpAddress,httpAddress)._();
}
row.td(info.getHealthStatus()).td(Times.format(info.getLastHealthUpdate())).td(info.getHealthReport()).td(String.valueOf(info.getNumContainers())).td().br().$title(String.valueOf(usedMemory))._()._(StringUtils.byteDesc(usedMemory * BYTES_IN_MB))._().td().br().$title(String.valueOf(usedMemory))._()._(StringUtils.byteDesc(availableMemory * BYTES_IN_MB))._()._();
}
tbody._()._();
}
