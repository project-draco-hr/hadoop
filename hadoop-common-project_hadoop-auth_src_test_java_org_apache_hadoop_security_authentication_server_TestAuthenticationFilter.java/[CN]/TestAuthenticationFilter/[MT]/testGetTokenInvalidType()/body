{
  AuthenticationFilter filter=new AuthenticationFilter();
  try {
    FilterConfig config=Mockito.mock(FilterConfig.class);
    Mockito.when(config.getInitParameter("management.operation.return")).thenReturn("true");
    Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(DummyAuthenticationHandler.class.getName());
    Mockito.when(config.getInitParameter(AuthenticationFilter.SIGNATURE_SECRET)).thenReturn("secret");
    Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE,AuthenticationFilter.SIGNATURE_SECRET,"management.operation.return")).elements());
    filter.init(config);
    AuthenticationToken token=new AuthenticationToken("u","p","invalidtype");
    token.setExpires(System.currentTimeMillis() + TOKEN_VALIDITY_SEC);
    Signer signer=new Signer("secret".getBytes());
    String tokenSigned=signer.sign(token.toString());
    Cookie cookie=new Cookie(AuthenticatedURL.AUTH_COOKIE,tokenSigned);
    HttpServletRequest request=Mockito.mock(HttpServletRequest.class);
    Mockito.when(request.getCookies()).thenReturn(new Cookie[]{cookie});
    boolean failed=false;
    try {
      filter.getToken(request);
    }
 catch (    AuthenticationException ex) {
      Assert.assertEquals("Invalid AuthenticationToken type",ex.getMessage());
      failed=true;
    }
 finally {
      Assert.assertTrue("token not invalid type",failed);
    }
  }
  finally {
    filter.destroy();
  }
}
