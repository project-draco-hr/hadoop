{
  int dataLen=decodingState.decodeLength;
  CoderUtil.resetOutputBuffers(decodingState.outputs,decodingState.outputOffsets,dataLen);
  int[] erasedOrNotToReadIndexes=CoderUtil.getNullIndexes(decodingState.inputs);
  for (int i=0; i < erasedOrNotToReadIndexes.length; i++) {
    adjustedByteArrayOutputsParameter[i]=null;
    adjustedOutputOffsets[i]=0;
  }
  for (int outputIdx=0, i=0; i < decodingState.erasedIndexes.length; i++) {
    boolean found=false;
    for (int j=0; j < erasedOrNotToReadIndexes.length; j++) {
      if (decodingState.erasedIndexes[i] == erasedOrNotToReadIndexes[j]) {
        found=true;
        adjustedByteArrayOutputsParameter[j]=CoderUtil.resetBuffer(decodingState.outputs[outputIdx],decodingState.outputOffsets[outputIdx],dataLen);
        adjustedOutputOffsets[j]=decodingState.outputOffsets[outputIdx];
        outputIdx++;
      }
    }
    if (!found) {
      throw new HadoopIllegalArgumentException("Inputs not fully corresponding to erasedIndexes in null places");
    }
  }
  for (int bufferIdx=0, i=0; i < erasedOrNotToReadIndexes.length; i++) {
    if (adjustedByteArrayOutputsParameter[i] == null) {
      adjustedByteArrayOutputsParameter[i]=CoderUtil.resetBuffer(checkGetBytesArrayBuffer(bufferIdx,dataLen),0,dataLen);
      adjustedOutputOffsets[i]=0;
      bufferIdx++;
    }
  }
  doDecodeImpl(decodingState.inputs,decodingState.inputOffsets,dataLen,erasedOrNotToReadIndexes,adjustedByteArrayOutputsParameter,adjustedOutputOffsets);
}
