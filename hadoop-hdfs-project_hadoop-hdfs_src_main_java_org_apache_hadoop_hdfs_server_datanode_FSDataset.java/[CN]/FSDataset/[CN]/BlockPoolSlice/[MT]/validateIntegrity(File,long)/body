{
  DataInputStream checksumIn=null;
  InputStream blockIn=null;
  try {
    File metaFile=new File(getMetaFileName(blockFile.toString(),genStamp));
    long blockFileLen=blockFile.length();
    long metaFileLen=metaFile.length();
    int crcHeaderLen=DataChecksum.getChecksumHeaderSize();
    if (!blockFile.exists() || blockFileLen == 0 || !metaFile.exists() || metaFileLen < (long)crcHeaderLen) {
      return 0;
    }
    checksumIn=new DataInputStream(new BufferedInputStream(new FileInputStream(metaFile),FSConstants.IO_FILE_BUFFER_SIZE));
    BlockMetadataHeader header=BlockMetadataHeader.readHeader(checksumIn);
    short version=header.getVersion();
    if (version != FSDataset.METADATA_VERSION) {
      DataNode.LOG.warn("Wrong version (" + version + ") for metadata file "+ metaFile+ " ignoring ...");
    }
    DataChecksum checksum=header.getChecksum();
    int bytesPerChecksum=checksum.getBytesPerChecksum();
    int checksumSize=checksum.getChecksumSize();
    long numChunks=Math.min((blockFileLen + bytesPerChecksum - 1) / bytesPerChecksum,(metaFileLen - crcHeaderLen) / checksumSize);
    if (numChunks == 0) {
      return 0;
    }
    IOUtils.skipFully(checksumIn,(numChunks - 1) * checksumSize);
    blockIn=new FileInputStream(blockFile);
    long lastChunkStartPos=(numChunks - 1) * bytesPerChecksum;
    IOUtils.skipFully(blockIn,lastChunkStartPos);
    int lastChunkSize=(int)Math.min(bytesPerChecksum,blockFileLen - lastChunkStartPos);
    byte[] buf=new byte[lastChunkSize + checksumSize];
    checksumIn.readFully(buf,lastChunkSize,checksumSize);
    IOUtils.readFully(blockIn,buf,0,lastChunkSize);
    checksum.update(buf,0,lastChunkSize);
    if (checksum.compare(buf,lastChunkSize)) {
      return lastChunkStartPos + lastChunkSize;
    }
 else {
      return lastChunkStartPos;
    }
  }
 catch (  IOException e) {
    DataNode.LOG.warn(e);
    return 0;
  }
 finally {
    IOUtils.closeStream(checksumIn);
    IOUtils.closeStream(blockIn);
  }
}
