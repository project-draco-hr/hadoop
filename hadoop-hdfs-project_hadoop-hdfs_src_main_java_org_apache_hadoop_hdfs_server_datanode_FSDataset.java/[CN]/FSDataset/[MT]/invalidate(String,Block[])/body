{
  boolean error=false;
  for (int i=0; i < invalidBlks.length; i++) {
    File f=null;
    final FSVolume v;
synchronized (this) {
      f=getFile(bpid,invalidBlks[i].getBlockId());
      ReplicaInfo dinfo=volumeMap.get(bpid,invalidBlks[i]);
      if (dinfo == null || dinfo.getGenerationStamp() != invalidBlks[i].getGenerationStamp()) {
        DataNode.LOG.warn("Unexpected error trying to delete block " + invalidBlks[i] + ". BlockInfo not found in volumeMap.");
        error=true;
        continue;
      }
      v=(FSVolume)dinfo.getVolume();
      if (f == null) {
        DataNode.LOG.warn("Unexpected error trying to delete block " + invalidBlks[i] + ". Block not found in blockMap."+ ((v == null) ? " " : " Block found in volumeMap."));
        error=true;
        continue;
      }
      if (v == null) {
        DataNode.LOG.warn("Unexpected error trying to delete block " + invalidBlks[i] + ". No volume for this block."+ " Block found in blockMap. "+ f+ ".");
        error=true;
        continue;
      }
      File parent=f.getParentFile();
      if (parent == null) {
        DataNode.LOG.warn("Unexpected error trying to delete block " + invalidBlks[i] + ". Parent not found for file "+ f+ ".");
        error=true;
        continue;
      }
      ReplicaState replicaState=dinfo.getState();
      if (replicaState == ReplicaState.FINALIZED || (replicaState == ReplicaState.RUR && ((ReplicaUnderRecovery)dinfo).getOriginalReplica().getState() == ReplicaState.FINALIZED)) {
        v.clearPath(bpid,parent);
      }
      volumeMap.remove(bpid,invalidBlks[i]);
    }
    File metaFile=DatanodeUtil.getMetaFile(f,invalidBlks[i].getGenerationStamp());
    asyncDiskService.deleteAsync(v,f,metaFile,new ExtendedBlock(bpid,invalidBlks[i]));
  }
  if (error) {
    throw new IOException("Error in deleting blocks.");
  }
}
