{
  final long blockSize;
  final short numTargets;
  final byte storagePolicyID;
  String clientMachine;
  final boolean isStriped;
  INodesInPath iip=fsn.dir.resolvePath(pc,src,fileId);
  FileState fileState=analyzeFileState(fsn,iip,fileId,clientName,previous,onRetryBlock);
  if (onRetryBlock[0] != null && onRetryBlock[0].getLocations().length > 0) {
    return null;
  }
  final INodeFile pendingFile=fileState.inode;
  if (!fsn.checkFileProgress(src,pendingFile,false)) {
    throw new NotReplicatedYetException("Not replicated yet: " + src);
  }
  if (pendingFile.getBlocks().length >= fsn.maxBlocksPerFile) {
    throw new IOException("File has reached the limit on maximum number of" + " blocks (" + DFSConfigKeys.DFS_NAMENODE_MAX_BLOCKS_PER_FILE_KEY + "): "+ pendingFile.getBlocks().length+ " >= "+ fsn.maxBlocksPerFile);
  }
  blockSize=pendingFile.getPreferredBlockSize();
  clientMachine=pendingFile.getFileUnderConstructionFeature().getClientMachine();
  isStriped=pendingFile.isStriped();
  ErasureCodingPolicy ecPolicy=null;
  if (isStriped) {
    ecPolicy=FSDirErasureCodingOp.getErasureCodingPolicy(fsn,src);
    numTargets=(short)(ecPolicy.getSchema().getNumDataUnits() + ecPolicy.getSchema().getNumParityUnits());
  }
 else {
    numTargets=pendingFile.getFileReplication();
  }
  storagePolicyID=pendingFile.getStoragePolicyID();
  return new ValidateAddBlockResult(blockSize,numTargets,storagePolicyID,clientMachine,isStriped);
}
