{
  final Call call=createCall(rpcKind,rpcRequest);
  final Connection connection=getConnection(remoteId,call,serviceClass,fallbackToSimpleAuth);
  try {
    checkAsyncCall();
    try {
      connection.sendRpcRequest(call);
    }
 catch (    RejectedExecutionException e) {
      throw new IOException("connection has been closed",e);
    }
catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
      LOG.warn("interrupted waiting to send rpc request to server",e);
      throw new IOException(e);
    }
  }
 catch (  Exception e) {
    if (isAsynchronousMode()) {
      releaseAsyncCall();
    }
    throw e;
  }
  if (isAsynchronousMode()) {
    final AsyncGet<Writable,IOException> asyncGet=new AsyncGet<Writable,IOException>(){
      @Override public Writable get(      long timeout,      TimeUnit unit) throws IOException, TimeoutException {
        boolean done=true;
        try {
          final Writable w=getRpcResponse(call,connection,timeout,unit);
          if (w == null) {
            done=false;
            throw new TimeoutException(call + " timed out " + timeout+ " "+ unit);
          }
          return w;
        }
  finally {
          if (done) {
            releaseAsyncCall();
          }
        }
      }
    }
;
    ASYNC_RPC_RESPONSE.set(new AsyncGetFuture<>(asyncGet));
    return null;
  }
 else {
    return getRpcResponse(call,connection,-1,null);
  }
}
