{
  this.remoteId=remoteId;
  this.server=remoteId.getAddress();
  if (server.isUnresolved()) {
    throw NetUtils.wrapException(server.getHostName(),server.getPort(),null,0,new UnknownHostException());
  }
  this.maxResponseLength=remoteId.conf.getInt(CommonConfigurationKeys.IPC_MAXIMUM_RESPONSE_LENGTH,CommonConfigurationKeys.IPC_MAXIMUM_RESPONSE_LENGTH_DEFAULT);
  this.rpcTimeout=remoteId.getRpcTimeout();
  this.maxIdleTime=remoteId.getMaxIdleTime();
  this.connectionRetryPolicy=remoteId.connectionRetryPolicy;
  this.maxRetriesOnSasl=remoteId.getMaxRetriesOnSasl();
  this.maxRetriesOnSocketTimeouts=remoteId.getMaxRetriesOnSocketTimeouts();
  this.tcpNoDelay=remoteId.getTcpNoDelay();
  this.tcpLowLatency=remoteId.getTcpLowLatency();
  this.doPing=remoteId.getDoPing();
  if (doPing) {
    ResponseBuffer buf=new ResponseBuffer();
    RpcRequestHeaderProto pingHeader=ProtoUtil.makeRpcRequestHeader(RpcKind.RPC_PROTOCOL_BUFFER,OperationProto.RPC_FINAL_PACKET,PING_CALL_ID,RpcConstants.INVALID_RETRY_COUNT,clientId);
    pingHeader.writeDelimitedTo(buf);
    pingRequest=buf.toByteArray();
  }
  this.pingInterval=remoteId.getPingInterval();
  if (rpcTimeout > 0) {
    this.soTimeout=(doPing && pingInterval < rpcTimeout) ? pingInterval : rpcTimeout;
  }
 else {
    this.soTimeout=pingInterval;
  }
  this.serviceClass=serviceClass;
  if (LOG.isDebugEnabled()) {
    LOG.debug("The ping interval is " + this.pingInterval + " ms.");
  }
  UserGroupInformation ticket=remoteId.getTicket();
  boolean trySasl=UserGroupInformation.isSecurityEnabled() || (ticket != null && !ticket.getTokens().isEmpty());
  this.authProtocol=trySasl ? AuthProtocol.SASL : AuthProtocol.NONE;
  this.setName("IPC Client (" + socketFactory.hashCode() + ") connection to "+ server.toString()+ " from "+ ((ticket == null) ? "an unknown user" : ticket.getUserName()));
  this.setDaemon(true);
}
