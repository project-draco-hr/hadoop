{
  final int NUM_PATHS=5;
  getClusterBuilder().setMaxLockedMemory(NUM_PATHS * BLOCK_SIZE).build();
  final String METHOD_NAME=GenericTestUtils.getMethodName();
  Path paths[]=new Path[NUM_PATHS * 2];
  for (int i=0; i < paths.length; i++) {
    paths[i]=new Path("/" + METHOD_NAME + "."+ i+ ".dat");
  }
  for (int i=0; i < NUM_PATHS; i++) {
    makeTestFile(paths[i],BLOCK_SIZE,true);
  }
  waitForMetric("RamDiskBlocksLazyPersisted",NUM_PATHS);
  for (int i=0; i < NUM_PATHS; ++i) {
    ensureFileReplicasOnStorageType(paths[i],RAM_DISK);
  }
  ArrayList<Integer> indexes=new ArrayList<Integer>(NUM_PATHS);
  for (int i=0; i < NUM_PATHS; ++i) {
    indexes.add(i);
  }
  Collections.shuffle(indexes);
  for (int i=0; i < NUM_PATHS; ++i) {
    LOG.info("Touching file " + paths[indexes.get(i)]);
    DFSTestUtil.readFile(fs,paths[indexes.get(i)]);
  }
  for (int i=0; i < NUM_PATHS; ++i) {
    makeTestFile(paths[i + NUM_PATHS],BLOCK_SIZE,true);
    triggerBlockReport();
    Thread.sleep(3000);
    ensureFileReplicasOnStorageType(paths[i + NUM_PATHS],RAM_DISK);
    ensureFileReplicasOnStorageType(paths[indexes.get(i)],DEFAULT);
    for (int j=i + 1; j < NUM_PATHS; ++j) {
      ensureFileReplicasOnStorageType(paths[indexes.get(j)],RAM_DISK);
    }
  }
  verifyRamDiskJMXMetric("RamDiskBlocksWrite",NUM_PATHS * 2);
  verifyRamDiskJMXMetric("RamDiskBlocksWriteFallback",0);
  verifyRamDiskJMXMetric("RamDiskBytesWrite",BLOCK_SIZE * NUM_PATHS * 2);
  verifyRamDiskJMXMetric("RamDiskBlocksReadHits",NUM_PATHS);
  verifyRamDiskJMXMetric("RamDiskBlocksEvicted",NUM_PATHS);
  verifyRamDiskJMXMetric("RamDiskBlocksEvictedWithoutRead",0);
  verifyRamDiskJMXMetric("RamDiskBlocksDeletedBeforeLazyPersisted",0);
}
