{
  Path[] parents=new Path[1];
  int level=0;
  final Path pathPattern=fixRelativePart(inPathPattern);
  String filename=pathPattern.toUri().getPath();
  if ("".equals(filename) || Path.SEPARATOR.equals(filename)) {
    Path p=pathPattern.makeQualified(uri,null);
    return getFileStatus(new Path[]{p});
  }
  String[] components=filename.split(Path.SEPARATOR);
  if (pathPattern.isAbsolute()) {
    parents[0]=new Path(Path.SEPARATOR);
    level=1;
  }
 else {
    parents[0]=new Path(Path.CUR_DIR);
  }
  boolean[] hasGlob=new boolean[]{false};
  Path[] relParentPaths=globPathsLevel(parents,components,level,hasGlob);
  FileStatus[] results;
  if (relParentPaths == null || relParentPaths.length == 0) {
    results=null;
  }
 else {
    Path[] parentPaths=new Path[relParentPaths.length];
    for (int i=0; i < relParentPaths.length; i++) {
      parentPaths[i]=relParentPaths[i].makeQualified(uri,null);
    }
    GlobFilter fp=new GlobFilter(components[components.length - 1],filter);
    if (fp.hasPattern()) {
      results=listStatus(parentPaths,fp);
      hasGlob[0]=true;
    }
 else {
      ArrayList<Path> filteredPaths=new ArrayList<Path>(parentPaths.length);
      for (int i=0; i < parentPaths.length; i++) {
        parentPaths[i]=new Path(parentPaths[i],components[components.length - 1]);
        if (fp.accept(parentPaths[i])) {
          filteredPaths.add(parentPaths[i]);
        }
      }
      results=getFileStatus(filteredPaths.toArray(new Path[filteredPaths.size()]));
    }
  }
  if (results == null) {
    if (hasGlob[0]) {
      results=new FileStatus[0];
    }
  }
 else {
    if (results.length == 0) {
      if (!hasGlob[0]) {
        results=null;
      }
    }
 else {
      Arrays.sort(results);
    }
  }
  return results;
}
