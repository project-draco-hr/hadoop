{
  final int maxAttempts=50;
  LogAggregationContext logAggregationContextWithInterval=Records.newRecord(LogAggregationContext.class);
  logAggregationContextWithInterval.setRollingIntervalSeconds(5000);
  this.conf.set(YarnConfiguration.NM_LOG_DIRS,localLogDir.getAbsolutePath());
  this.conf.set(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,this.remoteRootLogDir.getAbsolutePath());
  this.conf.setLong(YarnConfiguration.DEBUG_NM_DELETE_DELAY_SEC,3600);
  DrainDispatcher dispatcher=createDispatcher();
  EventHandler<ApplicationEvent> appEventHandler=mock(EventHandler.class);
  dispatcher.register(ApplicationEventType.class,appEventHandler);
  ApplicationId application=BuilderUtils.newApplicationId(123456,1);
  ApplicationAttemptId appAttemptId=BuilderUtils.newApplicationAttemptId(application,1);
  ContainerId container=BuilderUtils.newContainerId(appAttemptId,1);
  Context context=spy(this.context);
  ConcurrentMap<ApplicationId,Application> maps=new ConcurrentHashMap<ApplicationId,Application>();
  Application app=mock(Application.class);
  Map<ContainerId,Container> containers=new HashMap<ContainerId,Container>();
  containers.put(container,mock(Container.class));
  maps.put(application,app);
  when(app.getContainers()).thenReturn(containers);
  when(context.getApplications()).thenReturn(maps);
  LogAggregationService logAggregationService=new LogAggregationService(dispatcher,context,this.delSrvc,super.dirsHandler);
  logAggregationService.init(this.conf);
  logAggregationService.start();
  File appLogDir=new File(localLogDir,ConverterUtils.toString(application));
  appLogDir.mkdir();
  logAggregationService.handle(new LogHandlerAppStartedEvent(application,this.user,null,ContainerLogsRetentionPolicy.ALL_CONTAINERS,this.acls,logAggregationContextWithInterval));
  String[] logFiles1=new String[]{"stdout","stderr","syslog"};
  writeContainerLogs(appLogDir,container,logFiles1);
  AppLogAggregatorImpl aggregator=(AppLogAggregatorImpl)logAggregationService.getAppLogAggregators().get(application);
  aggregator.doLogAggregationOutOfBand();
  int count=0;
  while (numOfLogsAvailable(logAggregationService,application) != 1 && count <= maxAttempts) {
    Thread.sleep(100);
    count++;
  }
  verifyContainerLogs(logAggregationService,application,new ContainerId[]{container},logFiles1,3,true);
  aggregator.doLogAggregationOutOfBand();
  Assert.assertEquals(numOfLogsAvailable(logAggregationService,application),1);
  String[] logFiles2=new String[]{"stdout_1","stderr_1","syslog_1"};
  writeContainerLogs(appLogDir,container,logFiles2);
  aggregator.doLogAggregationOutOfBand();
  count=0;
  while (numOfLogsAvailable(logAggregationService,application) != 2 && count <= maxAttempts) {
    Thread.sleep(100);
    count++;
  }
  verifyContainerLogs(logAggregationService,application,new ContainerId[]{container},logFiles2,3,true);
  String[] logFiles3=new String[]{"stdout_2","stderr_2","syslog_2"};
  writeContainerLogs(appLogDir,container,logFiles3);
  logAggregationService.handle(new LogHandlerContainerFinishedEvent(container,0));
  dispatcher.await();
  logAggregationService.handle(new LogHandlerAppFinishedEvent(application));
  count=0;
  while (numOfLogsAvailable(logAggregationService,application) != 3 && count <= maxAttempts) {
    Thread.sleep(100);
    count++;
  }
  verifyContainerLogs(logAggregationService,application,new ContainerId[]{container},logFiles3,3,true);
  logAggregationService.stop();
  assertEquals(0,logAggregationService.getNumAggregators());
  dispatcher.stop();
}
