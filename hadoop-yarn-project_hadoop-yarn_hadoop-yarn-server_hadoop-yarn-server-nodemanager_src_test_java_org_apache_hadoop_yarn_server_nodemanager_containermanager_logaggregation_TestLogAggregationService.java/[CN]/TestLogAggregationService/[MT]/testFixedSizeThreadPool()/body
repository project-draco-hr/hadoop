{
  int initThreadPoolSize=conf.getInt(YarnConfiguration.NM_LOG_AGGREGATION_THREAD_POOL_SIZE,YarnConfiguration.DEFAULT_NM_LOG_AGGREGATION_THREAD_POOL_SIZE);
  int threadPoolSize=3;
  conf.setInt(YarnConfiguration.NM_LOG_AGGREGATION_THREAD_POOL_SIZE,threadPoolSize);
  DeletionService delSrvc=mock(DeletionService.class);
  LocalDirsHandlerService dirSvc=mock(LocalDirsHandlerService.class);
  when(dirSvc.getLogDirs()).thenThrow(new RuntimeException());
  LogAggregationService logAggregationService=new LogAggregationService(dispatcher,this.context,delSrvc,dirSvc);
  logAggregationService.init(this.conf);
  logAggregationService.start();
  ExecutorService executorService=logAggregationService.threadPool;
  final ReadWriteLock rwLock=new ReentrantReadWriteLock();
  final Lock rLock=rwLock.readLock();
  final Lock wLock=rwLock.writeLock();
  try {
    wLock.lock();
    Runnable runnable=new Runnable(){
      @Override public void run(){
        try {
          rLock.tryLock(35000,TimeUnit.MILLISECONDS);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
 finally {
          rLock.unlock();
        }
      }
    }
;
    for (int i=0; i < threadPoolSize + 1; i++) {
      executorService.submit(runnable);
    }
    int runningThread=((ThreadPoolExecutor)executorService).getActiveCount();
    assertEquals(threadPoolSize,runningThread);
  }
  finally {
    wLock.unlock();
  }
  logAggregationService.stop();
  logAggregationService.close();
  conf.setInt(YarnConfiguration.NM_LOG_AGGREGATION_THREAD_POOL_SIZE,initThreadPoolSize);
}
