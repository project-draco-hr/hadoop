{
  LogAggregationContext logAggregationContextWithInterval=Records.newRecord(LogAggregationContext.class);
  logAggregationContextWithInterval.setRollingIntervalSeconds(5000);
  this.conf.set(YarnConfiguration.NM_LOG_DIRS,localLogDir.getAbsolutePath());
  this.conf.set(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,this.remoteRootLogDir.getAbsolutePath());
  if (retentionSizeLimitation) {
    this.conf.setInt(YarnConfiguration.NM_PREFIX + "log-aggregation.num-log-files-per-app",1);
  }
  this.conf.setLong(YarnConfiguration.DEBUG_NM_DELETE_DELAY_SEC,3600);
  DrainDispatcher dispatcher=createDispatcher();
  EventHandler<ApplicationEvent> appEventHandler=mock(EventHandler.class);
  dispatcher.register(ApplicationEventType.class,appEventHandler);
  ApplicationId application=BuilderUtils.newApplicationId(123456,1);
  ApplicationAttemptId appAttemptId=BuilderUtils.newApplicationAttemptId(application,1);
  ContainerId container=BuilderUtils.newContainerId(appAttemptId,1);
  Context context=spy(this.context);
  ConcurrentMap<ApplicationId,Application> maps=new ConcurrentHashMap<ApplicationId,Application>();
  Application app=mock(Application.class);
  Map<ContainerId,Container> containers=new HashMap<ContainerId,Container>();
  containers.put(container,mock(Container.class));
  maps.put(application,app);
  when(app.getContainers()).thenReturn(containers);
  when(context.getApplications()).thenReturn(maps);
  LogAggregationService logAggregationService=new LogAggregationService(dispatcher,context,this.delSrvc,super.dirsHandler);
  logAggregationService.init(this.conf);
  logAggregationService.start();
  File appLogDir=new File(localLogDir,ConverterUtils.toString(application));
  appLogDir.mkdir();
  logAggregationService.handle(new LogHandlerAppStartedEvent(application,this.user,null,ContainerLogsRetentionPolicy.ALL_CONTAINERS,this.acls,logAggregationContextWithInterval));
  String[] logFiles1=new String[]{"stdout","stderr","syslog"};
  writeContainerLogs(appLogDir,container,logFiles1);
  AppLogAggregatorImpl aggregator=(AppLogAggregatorImpl)logAggregationService.getAppLogAggregators().get(application);
  aggregator.doLogAggregationOutOfBand();
  if (retentionSizeLimitation) {
    Assert.assertTrue(waitAndCheckLogNum(logAggregationService,application,50,1,true,null));
  }
 else {
    Assert.assertTrue(waitAndCheckLogNum(logAggregationService,application,50,1,false,null));
  }
  String logFileInLastCycle=null;
  logFileInLastCycle=verifyContainerLogs(logAggregationService,application,new ContainerId[]{container},logFiles1,3,true);
  Thread.sleep(2000);
  aggregator.doLogAggregationOutOfBand();
  Assert.assertEquals(numOfLogsAvailable(logAggregationService,application,true,null),1);
  Thread.sleep(2000);
  String[] logFiles2=new String[]{"stdout_1","stderr_1","syslog_1"};
  writeContainerLogs(appLogDir,container,logFiles2);
  aggregator.doLogAggregationOutOfBand();
  if (retentionSizeLimitation) {
    Assert.assertTrue(waitAndCheckLogNum(logAggregationService,application,50,1,true,logFileInLastCycle));
  }
 else {
    Assert.assertTrue(waitAndCheckLogNum(logAggregationService,application,50,2,false,null));
  }
  logFileInLastCycle=verifyContainerLogs(logAggregationService,application,new ContainerId[]{container},logFiles2,3,true);
  Thread.sleep(2000);
  String[] logFiles3=new String[]{"stdout_2","stderr_2","syslog_2"};
  writeContainerLogs(appLogDir,container,logFiles3);
  logAggregationService.handle(new LogHandlerContainerFinishedEvent(container,0));
  dispatcher.await();
  logAggregationService.handle(new LogHandlerAppFinishedEvent(application));
  if (retentionSizeLimitation) {
    Assert.assertTrue(waitAndCheckLogNum(logAggregationService,application,50,1,true,logFileInLastCycle));
  }
 else {
    Assert.assertTrue(waitAndCheckLogNum(logAggregationService,application,50,3,false,null));
  }
  verifyContainerLogs(logAggregationService,application,new ContainerId[]{container},logFiles3,3,true);
  logAggregationService.stop();
  assertEquals(0,logAggregationService.getNumAggregators());
  dispatcher.stop();
}
