{
  DBIterator iterator=null;
  try {
    KeyBuilder kb=KeyBuilder.newInstance().add(base).add(entityType);
    byte[] prefix=kb.getBytesForLookup();
    if (endtime == null) {
      endtime=Long.MAX_VALUE;
    }
    byte[] revts=writeReverseOrderedLong(endtime);
    kb.add(revts);
    byte[] first=kb.getBytesForLookup();
    byte[] last=null;
    if (starttime != null) {
      last=KeyBuilder.newInstance().add(base).add(entityType).add(writeReverseOrderedLong(starttime)).getBytesForLookup();
    }
    if (limit == null) {
      limit=DEFAULT_LIMIT;
    }
    TimelineEntities entities=new TimelineEntities();
    iterator=db.iterator();
    iterator.seek(first);
    while (entities.getEntities().size() < limit && iterator.hasNext()) {
      byte[] key=iterator.peekNext().getKey();
      if (!prefixMatches(prefix,prefix.length,key) || (last != null && WritableComparator.compareBytes(key,0,key.length,last,0,last.length) > 0))       break;
      KeyParser kp=new KeyParser(key,prefix.length);
      Long startTime=kp.getNextLong();
      String entityId=kp.getNextString();
      TimelineEntity entity=getEntity(entityId,entityType,startTime,fields,iterator,key,kp.getOffset());
      if (entity == null)       continue;
      boolean filterPassed=true;
      if (secondaryFilters != null) {
        for (        NameValuePair filter : secondaryFilters) {
          Object v=entity.getOtherInfo().get(filter.getName());
          if (v == null) {
            Set<Object> vs=entity.getPrimaryFilters().get(filter.getName());
            if (vs != null && !vs.contains(filter.getValue())) {
              filterPassed=false;
              break;
            }
          }
 else           if (!v.equals(filter.getValue())) {
            filterPassed=false;
            break;
          }
        }
      }
      if (filterPassed)       entities.addEntity(entity);
    }
    return entities;
  }
  finally {
    IOUtils.cleanup(LOG,iterator);
  }
}
