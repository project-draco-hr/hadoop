{
  Principal user=getPrincipal(securityContext);
  KMSClientProvider.checkNotEmpty(versionName,"versionName");
  KMSClientProvider.checkNotNull(eekOp,"eekOp");
  String keyName=(String)jsonPayload.get(KMSRESTConstants.NAME_FIELD);
  String ivStr=(String)jsonPayload.get(KMSRESTConstants.IV_FIELD);
  String encMaterialStr=(String)jsonPayload.get(KMSRESTConstants.MATERIAL_FIELD);
  Object retJSON;
  if (eekOp.equals(KMSRESTConstants.EEK_DECRYPT)) {
    assertAccess(KMSACLs.Type.DECRYPT_EEK,user,DECRYPT_EEK,versionName);
    KMSClientProvider.checkNotNull(ivStr,KMSRESTConstants.IV_FIELD);
    byte[] iv=Base64.decodeBase64(ivStr);
    KMSClientProvider.checkNotNull(encMaterialStr,KMSRESTConstants.MATERIAL_FIELD);
    byte[] encMaterial=Base64.decodeBase64(encMaterialStr);
    KeyProvider.KeyVersion retKeyVersion=provider.decryptEncryptedKey(new KMSClientProvider.KMSEncryptedKeyVersion(keyName,versionName,iv,KeyProviderCryptoExtension.EEK,encMaterial));
    retJSON=KMSServerJSONUtils.toJSON(retKeyVersion);
    KMSAudit.ok(user,DECRYPT_EEK,versionName,"");
  }
 else {
    throw new IllegalArgumentException("Wrong " + KMSRESTConstants.EEK_OP + " value, it must be "+ KMSRESTConstants.EEK_GENERATE+ " or "+ KMSRESTConstants.EEK_DECRYPT);
  }
  KMSWebApp.getDecryptEEKCallsMeter().mark();
  return Response.ok().type(MediaType.APPLICATION_JSON).entity(retJSON).build();
}
