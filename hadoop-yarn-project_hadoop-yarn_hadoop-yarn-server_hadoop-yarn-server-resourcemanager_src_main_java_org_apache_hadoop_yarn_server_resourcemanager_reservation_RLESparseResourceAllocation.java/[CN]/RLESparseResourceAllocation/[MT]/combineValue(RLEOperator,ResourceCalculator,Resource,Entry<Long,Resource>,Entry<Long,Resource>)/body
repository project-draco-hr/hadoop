{
  if (eA == null || eA.getValue() == null) {
    if (eB == null || eB.getValue() == null) {
      return null;
    }
    if (op == RLEOperator.subtract) {
      return Resources.negate(eB.getValue());
    }
 else {
      return eB.getValue();
    }
  }
  if (eB == null || eB.getValue() == null) {
    return eA.getValue();
  }
  Resource a=eA.getValue();
  Resource b=eB.getValue();
switch (op) {
case add:
    return Resources.add(a,b);
case subtract:
  return Resources.subtract(a,b);
case subtractTestNonNegative:
if (!Resources.fitsIn(b,a)) {
  throw new PlanningException("RLESparseResourceAllocation: merge failed as the " + "resulting RLESparseResourceAllocation would be negative");
}
 else {
  return Resources.subtract(a,b);
}
case min:
return Resources.min(resCalc,clusterResource,a,b);
case max:
return Resources.max(resCalc,clusterResource,a,b);
default :
return null;
}
}
